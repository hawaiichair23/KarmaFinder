<!DOCTYPE html>
<html lang="en">

<head>
<link rel="stylesheet" href="styles.css" />

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KarmaFinder - Better Reddit Search</title>

</head>

<body>

<script>

    try {
        if (localStorage.getItem('theme') === 'dark') {
            document.body.classList.add('dark-mode');
        }
    } catch (e) { }

</script>

    <a href="donopage.html" class="donate-btn floating-button">Support the Site</a>
    <div class="container">
        <header
            style="display: flex; justify-content: center; align-items: center; position: relative; padding: 1rem 0;">
            <div style="text-align: center;">
            <a href="karmafinder.html" class="link-container">
                <div class="logo">KarmaFinder</div>
                </a>
                <div class="tagline">Find exactly what you're looking for on Reddit üîé</div>
            </div>
        </header>

        <button id="themeToggle" class="theme-toggle" aria-label="Toggle Dark Mode">
            <img id="themeIcon" alt="Toggle theme" />
        </button>

        <div class="search-container">
          <div class="search-top-row">
            <div class="search-input-container">
                <input type="text" id="search-input" class="search-input" placeholder="Search Reddit..." autofocus>
                <button id="search-button" class="search-button">Search</button>
                </div>
                <img src="../assets/iconny thingy.png" alt="filter icon" id="filter-icon" />
                <button id="comfy-toggle" aria-label="Toggle Comfy Mode">
                    <img src="../assets/comfy-default.png" alt="Toggle comfy layout" />
                </button>
                <button id="compact-toggle" aria-label="Toggle Compact Mode">
                    <img src="../assets/compact-default.png" alt="Toggle compact layout" />
                </button>
            </div>

            <div class="advanced-options">
                <div class="option-group">
                    <label for="sort-select">Sort By</label>
                    <select id="sort-select">
                        <option value="hot">Hot</option>
                        <option value="top">Top</option>
                        <option value="new">New</option>
                        <option value="relevance">Relevance</option>
                    </select>
                </div>

                <div class="option-group">
                    <label for="time-select">Time Period</label>
                    <select id="time-select">
                        <option value="all">All Time</option>
                        <option value="year">Past Year</option>
                        <option value="month">Past Month</option>
                        <option value="week">Past Week</option>
                        <option value="day">Past 24 Hours</option>
                        <option value="hour">Past Hour</option>
                    </select>

                </div>

                <div class="option-group">
                    <label for="safesearch-select">SafeSearch</label>
                    <select id="safesearch-select">
                        <option value="on">On</option>
                        <option value="off">Off</option>
                    </select>
                </div>

                <div class="option-group subreddit-dropdown">
                    <label for="subreddit-input">Subreddit (optional)</label>
                    <input type="text" id="subreddit-input" placeholder="e.g., AskReddit">
                    <div id="subreddit-suggestions-container">
                        <div id="subreddit-suggestions" class="subreddit-suggestions"></div>
                    </div>
                    <div class="filter-chip-container" id="subreddit-chip-container">
                        <span class="chip-text"></span>
                        <span class="remove-chip">√ó</span>
                    </div>
                </div>

                <div class="option-group">
                    <label for="content-select">Content Type</label>
                    <select id="content-select">
                        <option value="all">All Content</option>
                        <option value="pictureposts">Picture Posts Only</option>
                        <option value="textposts">Text Posts Only</option>
                    </select>
                </div>
            </div>
        </div>

        <div id="results" class="results-container">
            <!-- Results will be populated here -->
        </div>

        <div id="pagination" class="pagination">
            <!-- Pagination will be added here -->
        </div>

        <footer>
            <p>KarmaFinder helps you search Reddit content more effectively than Reddit's native search.</p>
            <p>If you find this tool useful, please consider supporting its development. KarmaFinder is an independent
                search utility and is not affiliated with Reddit Inc.</p>
            <a href="#" id="button">Github // Discord</a>
        </footer>
    </div>

    <script>
        
        // Seven minutes. Seven minutes is all I can spare to play with you.
        const CACHE_DURATION_MS = 7 * 60 * 1000;

        // Configuration 
        const API_ENDPOINT = 'http://localhost:3000/reddit';

        const RESULTS_PER_PAGE = 10;

        const IMAGE_PROXY_BASE = location.hostname === 'localhost'
                ? 'http://localhost:3000'
                : 'https://karmafinder.onrender.com';

        let searchTimeout = null;

        let POPULAR_SUBREDDITS = [
            { name: 'AskReddit', icon: '/api/placeholder/20/20' },
            { name: 'funny', icon: '/api/placeholder/20/20' },
            { name: 'gaming', icon: '/api/placeholder/20/20' }
            // These are just fallbacks in case the API request fails
        ];

        // Add this function to fetch popular subreddits
        function fetchPopularSubreddits() {
            console.log("Attempting to fetch popular subreddits...");

            // Start with an empty array, populate it completely from the API
            fetch('http://localhost:3000/reddit?url=https://www.reddit.com/subreddits/popular.json?limit=100')
                .then(response => {
                    if (!response.ok) {      
                        showError('Failed to fetch popular subreddits.');
                        return;
                    }
                    return response.json();
                })
                .then(data => {
                    if (data && data.data && data.data.children) {
                        POPULAR_SUBREDDITS = data.data.children.map(child => ({
                            name: child.data.display_name,
                            icon: child.data.icon_img || '/api/placeholder/20/20'
                        }));
                        console.log('Loaded popular subreddits:', POPULAR_SUBREDDITS.length);

                        // Keep some fallbacks only if the API returned nothing
                        if (POPULAR_SUBREDDITS.length === 0) {
                            POPULAR_SUBREDDITS = [
                                { name: 'AskReddit', icon: '/api/placeholder/20/20' },
                                { name: 'funny', icon: '/api/placeholder/20/20' },
                                { name: 'gaming', icon: '/api/placeholder/20/20' }
                            ];
                        }
                    }
                })
                .catch(error => {
                    console.error('Error fetching popular subreddits:', error);
                });
        }

        // Call these functions when the page loads
           document.addEventListener('DOMContentLoaded', () => {

               // Check if this is a page refresh or new session
               const isPageRefresh = performance.navigation ?
                   (performance.navigation.type === 1) :
                   (performance.getEntriesByType('navigation')[0]?.type === 'reload');

               if (isPageRefresh) {
                   // If refreshing, try to restore the previous page state
                   loadPaginationState();
               } else {
                   
                console.log("üõéÔ∏è Loading r/all...");
                   currentPageIndex = 0;
                   currentAfter = null;
                   currentBefore = null;
                   currentFilters = {
                       sort: 'hot',
                       time: 'all',
                       subreddit: '',
                       query: '',
                       contentType: 'all'
                   };
                   performSearch(null, null, false, true);
               }
            });

        // DOM Elements
        const searchInput = document.getElementById('search-input');
        const searchButton = document.getElementById('search-button');
        const sortSelect = document.getElementById('sort-select');
        const timeSelect = document.getElementById('time-select');
        const subredditInput = document.getElementById('subreddit-input');
        const contentSelect = document.getElementById('content-select');
        const resultsContainer = document.getElementById('results');
        const paginationContainer = document.getElementById('pagination');
        const subredditSuggestions = document.getElementById('subreddit-suggestions');
        const subredditChipContainer = document.getElementById('subreddit-chip-container');
        const dropdown = document.getElementById('subreddit-suggestions');

        // State
        const savedCommentCache = localStorage.getItem('commentCache');
        const commentCache = savedCommentCache ? JSON.parse(savedCommentCache) : {};


        let navigationHistory = [];
        let currentPageIndex = 0;
        let currentQuery = '';
        let currentAfter = null;
        let currentBefore = null;
        let isLoading = false;
        let currentFilters = {
            sort: 'hot',
            time: 'all',
            subreddit: '',
            contentType: 'all'
        };

    function loadPaginationState() {
            const savedPageIndex = sessionStorage.getItem('kf_current_page_index');
            const savedAfter = sessionStorage.getItem('kf_current_after');
            const savedFilters = sessionStorage.getItem('kf_current_filters');

            if (!savedPageIndex && !savedFilters) {
                // First load ‚Üí show r/all
                performSearch();
                return;
            }

            if (savedPageIndex) {
                currentPageIndex = parseInt(savedPageIndex, 10);
            }

            if (savedAfter && savedAfter !== 'null' && savedAfter !== '') {
                currentAfter = savedAfter;
            }

            if (savedFilters) {
                try {
                    const filters = JSON.parse(savedFilters);
                    currentFilters = filters;

                    // üß† Update UI to reflect saved filters
                    if (filters.sort) sortSelect.value = filters.sort;
                    if (filters.time) timeSelect.value = filters.time;
                    if (filters.contentType) contentSelect.value = filters.contentType;
                    if (filters.query) searchInput.value = filters.query;
                    if (filters.subreddit) {
                        subredditInput.value = filters.subreddit;
                        selectSubreddit(filters.subreddit);
                    }
                } catch (e) {
                    console.error('Error parsing saved filters:', e);
                }
            }

            console.log("‚ôªÔ∏è Restoring session pagination state");
            performSearch(currentAfter, null, false, true);
        }

        // Event Listeners
      searchButton.addEventListener('click', () => {
            currentPageIndex = 0;
            navigationHistory = [];

                if (currentFilters.sort === 'relevance' && (!searchInput.value || searchInput.value.trim() === '')) {
              console.log("Empty search with relevance filter detected");
              showError("No search terms detected.üîé");
              // Don't call performSearch() at all in this case
          } else {
              // Only call performSearch when we have terms or aren't using relevance
              performSearch();
          }
      });

        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                currentPageIndex = 0;
                navigationHistory = [];
                performSearch();
            }
        });

        sortSelect.addEventListener('change', () => {
            currentFilters.sort = sortSelect.value;

                // Only perform search if NOT relevance
            if (sortSelect.value !== 'relevance') {
                performSearch();
            
            }
        });

        timeSelect.addEventListener('change', () => {
            currentFilters.time = timeSelect.value;
            performSearch();
        });

        document.getElementById('safesearch-select').addEventListener('change', function () {
            const enabled = this.value === 'on';
            document.body.classList.toggle('safe-search-enabled', enabled);
            console.log(`SafeSearch is now ${enabled ? 'ON' : 'OFF'}`);
        });

        contentSelect.addEventListener('change', () => {
            currentFilters.contentType = contentSelect.value;
            performSearch();
        });

        const comfyToggle = document.getElementById('comfy-toggle');
        const compactToggle = document.getElementById('compact-toggle');

        let isComfyActive = false;
        let isCompactActive = true;
        let hasClickedOnce = false;

        comfyToggle.querySelector('img').src = '../assets/comfy-default.png';
        compactToggle.querySelector('img').src = '../assets/compact-default.png';

            comfyToggle.addEventListener('click', () => {
                    if (isComfyActive) {
                        if (hasClickedOnce && !isCompactActive) return; // prevent both off
                        isComfyActive = false;
                        comfyToggle.querySelector('img').src = '../assets/comfy-default.png';
                    } else {
                        isComfyActive = true;
                        comfyToggle.querySelector('img').src = '../assets/comfy-pressed.png';

                        isCompactActive = false;
                        compactToggle.querySelector('img').src = '../assets/compact-default.png';
                    }

                    hasClickedOnce = true;
                    document.body.classList.add('hasClickedOnce');
                
                    if (isComfyActive) {
                    document.body.classList.add('comfy-mode');
                } else {
                    document.body.classList.remove('comfy-mode');
                }

                });

           compactToggle.addEventListener('click', () => {
                // Always set hasClickedOnce to true
                hasClickedOnce = true;
                document.body.classList.add('hasClickedOnce');

                    compactToggle.querySelector('img').src = '../assets/compact-pressed.png';
                    document.body.classList.remove('comfy-mode');
                    isComfyActive = false;
                    comfyToggle.querySelector('img').src = '../assets/comfy-default.png';

            });

        // Remove subreddit filter when clicking X
        subredditChipContainer.querySelector('.remove-chip').addEventListener('click', () => {
            currentFilters.subreddit = '';
            subredditChipContainer.style.display = 'none';
        });

        // Handle suggestion selection
        subredditSuggestions.addEventListener('click', (e) => {
            const suggestion = e.target.closest('.subreddit-suggestion');
            if (suggestion) {
                const subName = suggestion.getAttribute('data-name');
                selectSubreddit(subName);
            }
        });

        // Handle typing in subreddit input
        subredditInput.addEventListener('input', () => {
            const query = subredditInput.value.toLowerCase().trim();

            // Show dropdown immediately with a loading spinner
            if (query.length > 0) {
                if (!subredditSuggestions.querySelector('.custom-spinner-wrapper')) {
                    subredditSuggestions.innerHTML = '';
                    subredditSuggestions.appendChild(createCanvasSpinner());
                }

                subredditSuggestions.classList.add('active');
            } else {
                subredditSuggestions.classList.remove('active');
            }

            // Debounce Reddit API call
            if (searchTimeout) clearTimeout(searchTimeout);

            searchTimeout = setTimeout(() => {
                handleSubredditSuggestions(query);
            }, 200); // delay debounce here
        });

        // Cubic-bezier easing 
        function cubicBezier(p0, p1, p2, p3) {
            return function (t) {
                const cx = 3 * (p1 - p0);
                const bx = 3 * (p2 - p1) - cx;
                const ax = 1 - cx - bx;

                const cy = 3 * (p1 - p0);
                const by = 3 * (p2 - p1) - cy;
                const ay = 1 - cy - by;

                let x = t, t2 = t;
                for (let i = 0; i < 5; i++) {
                    const f = ax * t2 * t2 * t2 + bx * t2 * t2 + cx * t2 - x;
                    const df = 3 * ax * t2 * t2 + 2 * bx * t2 + cx;
                    t2 = t2 - f / df;
                    t2 = Math.max(0, Math.min(t2, 1));
                }

                return ay * t2 * t2 * t2 + by * t2 * t2 + cy * t2;
            };
        }

        // Begin animation
        function startSpinnerAnimation(ctx) {
            const easeCustom = cubicBezier(0.1, 0.83, 0.37, 1);
            const cycleDuration = 700;
            let startTime = null;

            function animate(timestamp) {
                if (!startTime) startTime = timestamp;

                const elapsed = timestamp - startTime;
                const t = (elapsed % cycleDuration) / cycleDuration;
                const ramp = Math.pow(t, 0.8);
                const eased = easeCustom(ramp);

                const angle = (eased * 6.28 + 7.8) % 6.28;
                const shrinkEase = easeCustom(t);
                const sinePhase = Math.sin(shrinkEase * Math.PI);
                const shrinkPhase = easeCustom(sinePhase);
                const shrink = 0.5 + 0.5 * shrinkPhase;
                const arcLength = Math.PI * 0.7 * shrink;

                ctx.clearRect(0, 0, 50, 50);
                ctx.beginPath();
                const arcStart = angle - arcLength;
                ctx.arc(25, 25, 18, arcStart, angle);
                ctx.strokeStyle = "#C1C0C1";
                ctx.lineWidth = 4;
                ctx.stroke();

                requestAnimationFrame(animate);
            }

            requestAnimationFrame(animate);
        }

        // SPINNY
        function createCanvasSpinner() {
            const wrapper = document.createElement('div');
            wrapper.className = 'custom-spinner-wrapper';

            const canvas = document.createElement('canvas');
            canvas.width = 50;
            canvas.height = 50;
            canvas.id = 'main-spinner-placeholder';
            wrapper.appendChild(canvas);

            const ctx = canvas.getContext('2d');
            startSpinnerAnimation(ctx); 

            return wrapper;
        }

        const SUGGESTION_CACHE_DURATION = 1000 * 60 * 60; // 1 hour

            function getSuggestionCacheKey(query) {
                return `subreddit_suggestions_${query}`;
            }

            async function handleSubredditSuggestions(query) {
            
                const cacheKey = getSuggestionCacheKey(query);
                const cached = localStorage.getItem(cacheKey);

                // ‚úÖ Check if exact query is cached and still fresh
                if (cached) {
                    try {
                        const parsed = JSON.parse(cached);
                        if (Date.now() - parsed.timestamp < SUGGESTION_CACHE_DURATION) {
                            console.log(`‚ö° Suggestion cache hit for "${query}"`);
                            populateSubredditSuggestions(parsed.data);
                            return;
                        } else {
                            localStorage.removeItem(cacheKey); // expired
                        }
                    } catch {
                        localStorage.removeItem(cacheKey); // corrupted
                    }
                }

                // üîé Search popular local subreddits
                const localMatches = POPULAR_SUBREDDITS.filter(sub =>
                    sub.name.toLowerCase().startsWith(query)
                );

                let remoteMatches = [];
                try {
                    const res = await fetch(`http://localhost:3000/reddit?url=https://www.reddit.com/subreddits/search.json?q=${encodeURIComponent(query)}`);
                    const data = await res.json();
                    if (data?.data?.children?.length > 0) {
                        remoteMatches = data.data.children
                            .filter(child => child.data.display_name.toLowerCase().startsWith(query))
                            .map(child => ({
                                name: child.data.display_name,
                                icon: child.data.icon_img || '/api/placeholder/20/20'
                            }));
                    }
                } catch (err) {
                    console.error("Subreddit fetch failed:", err);
                }

                const merged = [...localMatches, ...remoteMatches].filter(
                    (sub, index, self) => index === self.findIndex(s => s.name === sub.name)
                );

                // üíæ Cache the exact query result
                localStorage.setItem(cacheKey, JSON.stringify({
                    timestamp: Date.now(),
                    data: merged
                }));

                subredditSuggestions.innerHTML = '';
                if (merged.length === 0) {
                    subredditSuggestions.innerHTML = '<div class="no-results">No subreddits found</div>';
                    return;
                }

                populateSubredditSuggestions(merged);
            }

        function fetchSubredditSuggestions(query) {
            console.log("Searching for subreddits containing:", query);

            // Use Reddit's API to search for subreddits matching the query
            fetch(`http://localhost:3000/reddit?url=https://www.reddit.com/subreddits/search.json?q=${encodeURIComponent(query)}`)
                .then(response => {
                    if (!response.ok) throw new Error('Failed to search subreddits');
                    return response.json();
                })
                .then(data => {
                    if (data && data.data && data.data.children && data.data.children.length > 0) {
                        // Only keep subreddits that start with the query
                        const searchResults = data.data.children
                            .filter(child => child.data.display_name.toLowerCase().startsWith(query.toLowerCase()))
                            .map(child => ({
                                name: child.data.display_name,
                                icon: child.data.icon_img || '/api/placeholder/20/20'
                            }));

                        console.log('Filtered search results:', searchResults);

                        // Get current suggestion names to avoid duplicates
                        const currentSuggestions = Array.from(subredditSuggestions.children)
                            .map(el => el.getAttribute('data-name'));

                        const newSuggestions = searchResults.filter(sub =>
                            !currentSuggestions.includes(sub.name)
                        );

                        if (newSuggestions.length > 0) {
                            appendSubredditSuggestions(newSuggestions);
                        }
                    }
                })
                .catch(error => {
                    console.error('Error searching subreddits:', error);

                    // For fallback, also be more strict
                    setTimeout(() => {
                        const simulatedResults = [
                            { name: query + 'Pics', icon: '/api/placeholder/20/20' },
                            { name: query + 'Memes', icon: '/api/placeholder/20/20' },
                            { name: query + 'Pro', icon: '/api/placeholder/20/20' }
                        ];

                        const currentSuggestions = Array.from(subredditSuggestions.children)
                            .map(el => el.getAttribute('data-name'));

                        const newSuggestions = simulatedResults.filter(sub =>
                            !currentSuggestions.includes(sub.name)
                        );

                        if (newSuggestions.length > 0) {
                            appendSubredditSuggestions(newSuggestions);
                        }
                    }, 300);
                });
        }

        function populateSubredditSuggestions(subreddits) {
            console.log("Populating subreddit suggestions:", subreddits);

            // Clear the suggestions container first
            subredditSuggestions.innerHTML = '';

            // Sort subreddits by relevance to the search query
            const query = subredditInput.value.toLowerCase().trim();
            if (query.length > 0) {
                subreddits.sort((a, b) => {
                    const aName = a.name.toLowerCase();
                    const bName = b.name.toLowerCase();

                    // Exact matches first
                    if (aName === query && bName !== query) return -1;
                    if (bName === query && aName !== query) return 1;

                    // Then starts with matches
                    if (aName.startsWith(query) && !bName.startsWith(query)) return -1;
                    if (bName.startsWith(query) && !aName.startsWith(query)) return 1;

                    // Then contains matches (already handled by filtering)
                    // Finally alphabetical
                    return aName.localeCompare(bName);
                });
            }

            // If there are results from filtering, add them
            if (subreddits.length > 0) {
                subreddits.forEach(sub => {
                    const suggestion = document.createElement('div');
                    suggestion.className = 'subreddit-suggestion';
                    suggestion.setAttribute('data-name', sub.name);

                    const iconEl = document.createElement('div');
                    iconEl.className = 'subreddit-icon';

                    if (sub.icon && sub.icon !== '/api/placeholder/20/20') {
                        const img = document.createElement('img');
                        img.src = sub.icon;
                        img.alt = sub.name;
                        iconEl.appendChild(img);
                    } else {
                        iconEl.textContent = sub.name.charAt(0).toUpperCase();
                    }

                    suggestion.appendChild(iconEl);
                    suggestion.appendChild(document.createTextNode(sub.name));

                    subredditSuggestions.appendChild(suggestion);
                });
            }

            // Add an attribute to track if we have results
            subredditSuggestions.setAttribute('data-has-results', subreddits.length > 0 ? 'true' : 'false');
        }

        function selectSubreddit(subName) {
            currentFilters.subreddit = subName;
            subredditChipContainer.style.display = 'flex';
            subredditChipContainer.querySelector('.chip-text').textContent = 'r/' + subName;
            subredditInput.value = '';
            subredditSuggestions.classList.remove('active');
        }

        function tryUseCachedResults(cacheKey, navigateBack = false) {
                const cachedItem = localStorage.getItem(cacheKey);
        
                if (!cachedItem) return false;

                try {
                    const cachedData = JSON.parse(cachedItem);
                    const isFresh = Date.now() - cachedData.timestamp < CACHE_DURATION_MS;

                    // If it's a pagination/backload, we want to allow expired cache too
                    const allowStale = navigateBack;

                    if (isFresh || allowStale) {
                        // Refresh the tokens here
                        currentAfter = cachedData.after || null;  // Update currentAfter with the cached value
                        currentBefore = cachedData.before || null;  // Update currentBefore with the cached value

                           // ‚úÖ Store page in navigation history
                        navigationHistory[currentPageIndex] = {
                            query: currentFilters.query,
                            after: currentAfter,
                            before: currentBefore,
                            nextAfter: cachedData.after || null,
                            nextBefore: cachedData.before || null,
                            results: cachedData.data
                        };

                            const now = Math.floor(Date.now() / 1000);
                        let timeCutoff = 0;

                        switch (currentFilters.time) {
                            case "hour": timeCutoff = now - 3600; break;
                            case "day": timeCutoff = now - 86400; break;
                            case "week": timeCutoff = now - 604800; break;
                            case "month": timeCutoff = now - 2592000; break;
                            case "year": timeCutoff = now - 31536000; break;
                            case "all":
                            default: timeCutoff = 0;
                        }

                        let timeFiltered = cachedData.data;

                        if (currentFilters.time !== 'all') {
                            timeFiltered = cachedData.data.filter(post => true);
                        }

                        const contentFiltered = filterByContentType(cachedData.data, currentFilters.contentType);

                        displayResults(contentFiltered);

                        window.scrollTo(0, 0);

                        console.log(`üî• DEBUG (cache hit):`, {
                            context: navigateBack ? 'navigateBack' : 'regular',
                            cacheKey,
                            cachedAfter: cachedData.after,
                            cachedBefore: cachedData.before,
                            cachedData: cachedData.data
                        });

                        return true; // ‚úÖ used cache
                    } else {
                        localStorage.removeItem(cacheKey);
                    }
                } catch (e) {
                    localStorage.removeItem(cacheKey);
                }

                return false; // ‚ùå cache miss or invalid
            }

        // Modified performSearch function with caching
        function performSearch(after = null, before = null, navigateBack = false, isInitialLoad = false) {
        let cacheKey = '';
            console.log('üü¢ performSearch() called with:', { after, before, navigateBack, isInitialLoad });
            console.log('üîç Current Index:', currentPageIndex, 'navigateBack:', navigateBack);
            
            // Remapping after and before to currentafter and currentbefore after page is loaded
            currentAfter = after;
            currentBefore = before;

        // Setting filters before cache
        const query = searchInput.value.trim();
        const subredditTyped = document.getElementById('subreddit-input').value.trim();
        const chipVisible = subredditChipContainer.style.display === 'flex';
        const hasSubreddit = chipVisible || subredditTyped;

        // Update filters from UI
        currentFilters.query = query;
        currentFilters.time = document.getElementById('time-select').value;
        currentFilters.sort = document.getElementById('sort-select').value;
        currentFilters.contentType = document.getElementById('content-select').value;

        // Get subreddit from chip container if visible, otherwise from input
        if (subredditChipContainer.style.display === 'flex') {
            // Get the subreddit from the chip text (removing the 'r/' prefix)
            const chipText = subredditChipContainer.querySelector('.chip-text').textContent;
            currentFilters.subreddit = chipText.replace('r/', '');
        } else {
            // Fallback to input value
            currentFilters.subreddit = document.getElementById('subreddit-input').value.trim() || 'all';
        }

             // üîë Generate the cache key using current filters and tokens
            cacheKey = `kf_search_${currentFilters.query || ''}_${currentFilters.sort || 'hot'}_${currentFilters.time || 'all'}_${currentFilters.subreddit || ''}_${currentFilters.contentType || 'all'}_${after || ''}`;
            if (tryUseCachedResults(cacheKey)) {
                console.log('‚úÖ Loaded from cache successfully:', cacheKey);
                return;
            }

            if (navigateBack) {
                const targetPage = navigationHistory[currentPageIndex];

                if (targetPage?.results?.length) {
                    currentFilters.query = targetPage.query;

                    // üõ† Restore tokens too
                    currentAfter = targetPage.after || null;
                    currentBefore = targetPage.before || null;

                    console.log("‚¨ÖÔ∏è Navigating back to page:", currentPageIndex);
                    displayResults(targetPage.results);
                    updatePagination();
                    window.scrollTo(0, 0);
                    return;
                }

                console.warn("‚ö†Ô∏è No cached results for previous page.");
                return;
            }

            // Begin constructing URL
            const encodedQuery = encodeURIComponent(query);
            let sort = currentFilters.sort;
            const time = currentFilters.time;
            const subreddit = currentFilters.subreddit;
            const limit = 10;

            const isQuerying = query.length > 0;

            if (isQuerying) {
                finalUrl = `https://www.reddit.com${subreddit ? `/r/${subreddit}` : ''}/search.json?q=${encodedQuery}&sort=${sort}&restrict_sr=1&limit=${limit}&t=${time}`;
            } else if (subreddit) {
                finalUrl = `https://www.reddit.com/r/${subreddit}/${sort}.json?limit=${limit}&t=${time}`;
            } else {
                finalUrl = `https://www.reddit.com/r/all/${sort}.json?limit=${limit}&t=${time}`;
            }

            if (after) finalUrl += `&after=${after}`;
            if (before) finalUrl += `&before=${before}`;

            console.log('üîç Filters applied:', currentFilters);
            console.log('üîó Final Reddit URL:', finalUrl);

            showLoading();

            // Proxy fetch
            fetch(`http://localhost:3000/reddit?url=${encodeURIComponent(finalUrl)}`)
                .then(res => {
                    if (!res.ok) {
                        showError('Failed to fetch results from Reddit.');
                        return;
                    }
                    return res.json();
                })
                
                .then(data => {

                        currentAfter = data.data.after || null;
                        currentBefore = data.data.before || null;

                    const trimmedData = data.data.children.map(post => ({
                        title: post.data.title,
                        url: post.data.url,
                        permalink: post.data.permalink,
                        subreddit: post.data.subreddit,
                        score: post.data.score,
                        is_video: post.data.is_video,
                        domain: post.data.domain,
                        author: post.data.author,
                        created_utc: post.data.created_utc,
                        num_comments: post.data.num_comments,
                        over_18: post.data.over_18,
                        preview: post.data.preview,
                        selftext: post.data.selftext,
                        body: post.data.body,
                        is_gallery: post.data.is_gallery,
                        gallery_data: post.data.gallery_data,
                        media_metadata: post.data.media_metadata
                    }));

                    // Store the page state in navigationHistory for future pages
                    navigationHistory[currentPageIndex] = {
                        query: currentFilters.query,
                        after: currentAfter,
                        before: currentBefore,
                        nextAfter: data.data?.after || null,  
                        nextBefore: data.data?.before || null, 
                        results: trimmedData
                    };

                    console.log('Data from API for ' + currentFilters.sort + ' sorting:', trimmedData);

                    // üíæ Store in localStorage cache
                    if (trimmedData.length > 0) {
                        const cacheData = {
                            timestamp: Date.now(),
                            data: trimmedData,
                            after: currentAfter,
                            before: currentBefore   
                        };
                        localStorage.setItem(cacheKey, JSON.stringify(cacheData));
                        console.log('üíæ Cached new results for:', cacheKey);
                    } else {
                        console.warn('‚ö†Ô∏è Not caching empty results for:', cacheKey);
                    }

                    if (!navigateBack) {
                        // üßº Clean up forward history if user had previously gone back
                        navigationHistory.length = currentPageIndex + 1;

                        // üíæ Try to load from localStorage or memory cache
                        if (tryUseCachedResults(cacheKey)) {
                            console.log("‚úÖ Loaded results from cache for", cacheKey);
                            return;
                        }

                        showLoading();

                        // Store the current page's state
                        navigationHistory[currentPageIndex] = {
                            query: currentFilters.query,
                            after: currentAfter,
                            before: currentBefore,
                            nextAfter: data.data?.after || null,
                            nextBefore: data.data?.before || null, 
                            results: trimmedData                   
                        };

                        console.log("üî• Debug:", {
                            currentPageIndex,
                            navigateBack,
                            afterParam: after,
                            beforeParam: before,
                            receivedAfterFromReddit: data.data?.after || null,
                            receivedBeforeFromReddit: data.data?.before || null,
                            currentAfter,
                            currentBefore,
                            navigationHistorySlot: navigationHistory[currentPageIndex],
                            fullHistory: [...navigationHistory]
                        });  
                    }
                    // Display the results

                    const now = Math.floor(Date.now() / 1000);
                    let timeCutoff = 0;

                    switch (currentFilters.time) {
                        case "hour":
                            timeCutoff = now - (60 * 60); // 1 hour
                            break;
                        case "day":
                            timeCutoff = now - (24 * 60 * 60); // 1 day
                            break;
                        case "week":
                            timeCutoff = now - (7 * 24 * 60 * 60); // 1 week
                            break;
                        case "month":
                            timeCutoff = now - (30 * 24 * 60 * 60); // ~1 month
                            break;
                        case "year":
                            timeCutoff = now - (365 * 24 * 60 * 60); // ~1 year
                            break;
                        case "all":
                        default:
                            timeCutoff = 0; // No cutoff, show everything
                            break;
                    }

                    const filteredData = trimmedData.filter(post => {
        
                        return post.created_utc && post.created_utc >= timeCutoff;
                    });

                    // Content type filter
                    const contentFilteredData = filterByContentType(filteredData, currentFilters.contentType);

                    displayResults(contentFilteredData);
                    window.scrollTo(0, 0);
                    updatePagination();
                })
                .catch(err => showError(err));
        }

  function tryGalleryPatch(fullPost, permalink, resultCard, attempt = 1) {
        console.log('üîç tryGalleryPatch called for:', permalink);

        const mediaId = fullPost.gallery_data?.items?.[0]?.media_id;
        const media = fullPost.media_metadata?.[mediaId];

        console.log("üß© Full media_metadata object:", fullPost.media_metadata);
        console.log("üß¨ Selected media entry:", mediaId, media);

        console.log('üîç Gallery data check:', {
            hasGalleryData: !!fullPost.gallery_data,
            itemsLength: fullPost.gallery_data?.items?.length || 0,
            firstItemId: mediaId,
            hasMetadata: !!fullPost.media_metadata,
            mediaFound: !!media,
            mediaURL: media?.s?.u
        });

        // Don‚Äôt proceed if essential pieces are missing
        if (!media || !resultCard) {
            if (!resultCard && attempt < 5) {
                console.warn(`‚ö†Ô∏è resultCard not found yet (attempt ${attempt}), retrying...`);
                setTimeout(() => tryGalleryPatch(fullPost, permalink, resultCard, attempt + 1), 100);
            }
            return;
        }

        const imgContainer = resultCard.querySelector('.img-container');
        const imgWrapper = resultCard.querySelector('.image-wrapper');

        if (!imgContainer || !imgWrapper) {
            console.warn('‚ö†Ô∏è Missing image container or wrapper');
            return;
        }

        // Force container visible if valid
        if (imgContainer.style.visibility === 'hidden') {
            console.log('üîß Making image container visible for gallery post');
            imgContainer.style.visibility = 'visible';
        }

        // Ensure shimmer exists
        let shimmer = resultCard.querySelector('.image-placeholder');
        if (!shimmer) {
            shimmer = document.createElement('div');
            shimmer.className = 'image-placeholder shimmer';
            imgWrapper.prepend(shimmer);
        } else {
            shimmer.style.display = 'block';
        }

        // Gather best available image sources
        const original = media?.s?.u?.replace(/&amp;/g, '&');
        const resolutionFallback = media?.p?.[media.p.length - 1]?.u?.replace(/&amp;/g, '&');
        const fallbacks = [original, resolutionFallback].filter(Boolean);

        // Fallback loader function
        const patchImage = (img) => {
            const trySrc = (index = 0) => {
                if (index >= fallbacks.length) {
                    console.warn('üíÄ All fallback sources failed.');
                    img.style.display = 'none';
                    return;
                }

                const fallbackURL = `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(fallbacks[index])}&t=${Date.now()}`;
                console.log(`üß™ Trying fallback [${index + 1}/${fallbacks.length}]:`, fallbackURL);

                img.onerror = () => {
                    console.warn(`‚ùå Fallback [${index + 1}] failed:`, fallbackURL);
                    trySrc(index + 1);
                };

                img.onload = () => {
                    console.log('‚úÖ Image loaded from fallback:', fallbackURL);
                    img.classList.add('show');
                    img.style.opacity = '1';
                    shimmer.style.display = 'none';
                };

                img.src = fallbackURL;
            };

            trySrc();
        };

        const resultImg = resultCard.querySelector('img.result-image');

        if (resultImg) {
            console.log('üß™ FORCING IMAGE PATCH (immediate)');
            patchImage(resultImg);
        } else if (attempt < 3) {
            console.warn(`‚ö†Ô∏è img.result-image not found (attempt ${attempt}), retrying...`);
            setTimeout(() => tryGalleryPatch(fullPost, permalink, resultCard, attempt + 1), 100);
        } else {
            console.error('‚ùå img.result-image not found after retries. Giving up.');
        }
    }

    function appendSubredditSuggestions(subreddits) {
        // First, check if we already have results
        const hasResults = subredditSuggestions.getAttribute('data-has-results') === 'true';

        // If we have new suggestions and no existing ones, remove any "no results" message
        if (subreddits.length > 0 && !hasResults) {
            subredditSuggestions.innerHTML = '';
            subredditSuggestions.setAttribute('data-has-results', 'true');
        }

        subreddits.forEach(sub => {
            const suggestion = document.createElement('div');
            suggestion.className = 'subreddit-suggestion';
            suggestion.setAttribute('data-name', sub.name);

            const iconEl = document.createElement('div');
            iconEl.className = 'subreddit-icon';

            if (sub.icon && sub.icon !== '/api/placeholder/20/20') {
                const img = document.createElement('img');
                img.src = sub.icon;
                img.alt = sub.name;
                iconEl.appendChild(img);
            } else {
                iconEl.textContent = sub.name.charAt(0).toUpperCase();
            }

            suggestion.appendChild(iconEl);
            suggestion.appendChild(document.createTextNode(sub.name));

            subredditSuggestions.appendChild(suggestion);
        });
    }

    function displayResults(data) {
        resultsContainer.style.opacity = 0;
        resultsContainer.innerHTML = '';

        // Check if we're dealing with cached data (an array) or API response
        const isFromCache = Array.isArray(data);

        const posts = isFromCache
            ? data  // cached data is already processed
            : data.data?.children.map(item => item.data) || [];

        // Update pagination tokens based on data source
        if (isFromCache) {

            const cacheKey = `kf_search_${currentFilters.query || ''}_${currentFilters.sort || 'hot'}_${currentFilters.time || 'all'}_${currentFilters.subreddit || ''}_${currentFilters.contentType || 'all'}_${currentAfter || ''}_${currentBefore || ''}`;

            // For cached data, we need to load the tokens from cache too

            const cachedItem = localStorage.getItem(cacheKey);

            if (cachedItem) {
                try {
                    const cachedData = JSON.parse(cachedItem);
                    currentAfter = cachedData.after;
                    currentBefore = cachedData.before;
                    console.log("üîÑ Loaded pagination tokens from cache:", { currentAfter, currentBefore });
                } catch (e) {
                    console.error("Error loading pagination tokens from cache:", e);
                }
            }
        } else {
            // For fresh API data, use the tokens from the response
            currentAfter = data.data?.after || null;
            currentBefore = data.data?.before || null;
            console.log("üîÑ Updated pagination tokens from API:", { currentAfter, currentBefore });
        }

        if (posts.length === 0) {
            resultsContainer.innerHTML = `
            <div class='results-error'>
                <p>No results found. Try different search terms or filters.</p>
            </div>
        `;
            paginationContainer.innerHTML = '';
            resultsContainer.style.opacity = 1;
            return;
        }

        // Display results
        posts.forEach(post => {

            // Display domain in url
            console.log({
                title: post.title,
                is_video: post.is_video,
                domain: post.domain,
                url: post.url
            });

            const title = post.title?.toLowerCase() || '';
            const isProbablyNSFW = post.over_18 || /tits|titties|tiddies|nudes|onlyfans|boobs|cum|cock|cunt|gape|gooning|gooner|goon|pussy|porn|fuck/.test(title);

            const resultCard = document.createElement('div');
            resultCard.className = 'result-card';
            resultCard.dataset.permalink = post.permalink;

            if (isProbablyNSFW) {
                resultCard.classList.add('nsfw');
            }

            // Create comments section outer shell
            const commentsSection = document.createElement('div');
            commentsSection.className = 'comments-section';

            // Create inner scrollable area
            const commentsScroll = document.createElement('div');
            commentsScroll.className = 'comments-scroll';

            // Put a loading message in the scroll area
            commentsScroll.innerHTML = '<div class="no-comments">Loading comments...</div>';

            // Append scrollable div inside the outer container
            commentsSection.appendChild(commentsScroll);

            // Fetch comments INTO the inner scrollable div
            fetchComments(post.permalink, commentsScroll);

            // Vote section
            const voteSection = document.createElement('div');
            voteSection.className = 'vote-section';

            const permalinkUrl = `https://www.reddit.com${post.permalink}`;

            const upvoteBtn = document.createElement('a');
            upvoteBtn.href = permalinkUrl;
            upvoteBtn.target = '_blank';
            upvoteBtn.className = 'vote-button';
            upvoteBtn.innerHTML = `
<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <polyline points="18 15 12 9 6 15"></polyline>
</svg>
`;

            const voteCount = document.createElement('div');
            voteCount.className = 'vote-count';
            voteCount.textContent = formatNumber(post.score);

            const downvoteBtn = document.createElement('a');
            downvoteBtn.href = permalinkUrl;
            downvoteBtn.target = '_blank';
            downvoteBtn.className = 'vote-button';
            downvoteBtn.innerHTML = `
<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <polyline points="6 9 12 15 18 9"></polyline>
</svg>
`;

            voteSection.appendChild(upvoteBtn);
            voteSection.appendChild(voteCount);
            voteSection.appendChild(downvoteBtn);

            // Content section
            const contentSection = document.createElement('div');
            contentSection.className = 'content-section';

            // Result header with subreddit, author, time
            const resultHeader = document.createElement('div');
            resultHeader.className = 'result-header';

            const subredditLink = document.createElement('a');
            subredditLink.className = 'result-subreddit';
            subredditLink.href = `https://www.reddit.com/r/${post.subreddit}`;
            subredditLink.target = '_blank';

            // Subreddit icon
            const subredditIcon = document.createElement('div');
            subredditIcon.className = 'subreddit-icon';
            subredditIcon.textContent = post.subreddit.charAt(0).toUpperCase();

            subredditLink.appendChild(subredditIcon);
            subredditLink.appendChild(document.createTextNode('r/' + post.subreddit));

            const authorSpan = document.createElement('span');
            authorSpan.className = 'result-author';
            authorSpan.textContent = 'Posted by u/' + post.author;

            const timeSpan = document.createElement('span');
            timeSpan.className = 'result-time';
            timeSpan.textContent = formatTimestamp(post.created_utc);

            resultHeader.appendChild(subredditLink);
            resultHeader.appendChild(authorSpan);
            resultHeader.appendChild(timeSpan);

            // Result title
            const resultTitle = document.createElement('div');
            resultTitle.className = 'result-title';

            const titleLink = document.createElement('a');
            titleLink.href = `https://www.reddit.com${post.permalink}`;
            titleLink.target = '_blank';
            titleLink.textContent = post.title || 'Comment in thread';

            resultTitle.appendChild(titleLink);

            // Result content (text or snippet)
            const resultContent = document.createElement('div');
            resultContent.className = 'result-content';

            let snippet = '';
            if (post.selftext) {
                snippet = post.selftext.length > 300
                    ? post.selftext.substring(0, 300) + '...'
                    : post.selftext;
            } else if (post.body) {
                snippet = post.body.length > 300
                    ? post.body.substring(0, 300) + '...'
                    : post.body;
            }
            // Add sanitization:
            if (snippet) {
                resultContent.textContent = sanitizeHTML(snippet);
            }

            // Result actions (comments, save, share)
            const resultActions = document.createElement('div');
            resultActions.className = 'result-actions';

            const commentsAction = document.createElement('div');
            commentsAction.className = 'result-action';
            commentsAction.innerHTML = `
                <svg class="action-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                    </svg>
                    ${post.num_comments || 0} Comments
                `;

            commentsAction.style.cursor = 'pointer';

            commentsAction.addEventListener('click', () => {
                const url = 'https://www.reddit.com' + post.permalink;
                window.open(url, '_blank');
            });

            const saveAction = document.createElement('div');
            saveAction.className = 'result-action';
            saveAction.innerHTML = `
                    <svg class="action-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>
                    </svg>
                    Save
                `;

            const shareAction = document.createElement('div');
            shareAction.className = 'result-action';
            shareAction.innerHTML = `
                    <svg class="action-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="18" cy="5" r="3"></circle>
                        <circle cx="6" cy="12" r="3"></circle>
                        <circle cx="18" cy="19" r="3"></circle>
                        <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
                        <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
                    </svg>
                    Share
                `;

            resultActions.appendChild(commentsAction);
            resultActions.appendChild(saveAction);
            resultActions.appendChild(shareAction);

            // Add all sections to content area
            contentSection.appendChild(resultHeader);
            contentSection.appendChild(resultTitle);

            if (snippet) {
                contentSection.appendChild(resultContent);
            }

            contentSection.appendChild(resultActions);

            // Create the outer card element
            resultCard.className = 'result-card';
            resultCard.dataset.permalink = post.permalink;

            const hasPreviewImage = post.preview?.images?.[0]?.source?.url;
            const isGalleryWithData = post.is_gallery && post.gallery_data && post.media_metadata;
            const isVideo = post.is_video ||
                (post.domain && post.domain.includes('youtu')) ||
                (post.url && post.url.includes('v.redd.it')) ||
                (post.domain && post.domain.includes('streamable')) ||
                (post.url && post.url.endsWith('.gifv'));
            const hasVisualMedia = hasPreviewImage || isGalleryWithData || isVideo;

    imgContainer = document.createElement('div');
    imageWrapper = document.createElement('div');
    imagePlaceholder = document.createElement('div');

     imgContainer.className = 'img-container';
     imageWrapper.className = 'image-wrapper';
     
        imagePlaceholder = document.createElement('div');
        imagePlaceholder.className = 'image-placeholder shimmer';

        if (imgContainer && hasVisualMedia) {

            imgContainer.style.visibility = 'visible';
        } else {
            imgContainer.style.visibility = 'hidden';
        }
            const resultImage = document.createElement('img');
            resultImage.className = 'result-image';
            resultImage.alt = 'Post thumbnail';
            resultImage.setAttribute('loading', 'lazy');
            resultImage.setAttribute('decoding', 'async');
            resultImage.setAttribute('fetchpriority', 'low');
            resultImage.setAttribute('crossorigin', 'anonymous');

            let needsPatch = false;
            let previewImage = post.preview?.images?.[0]?.source?.url?.replace(/&amp;/g, '&');

            if (previewImage) {
                const uniqueTimestamp = `${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
                resultImage.src = `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(previewImage)}&t=${uniqueTimestamp}`;

                resultImage.addEventListener('error', () => {
                    console.error('‚ùå Image failed to load:', resultImage.src);
                    const retryTimestamp = Date.now();
                    resultImage.src = `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(previewImage)}&t=${retryTimestamp}`;
                });

                resultImage.addEventListener('load', () => {
                    if (resultImage.naturalWidth === 0 || resultImage.naturalHeight === 0) {
                        console.warn('‚ö†Ô∏è Image loaded but invisible:', resultImage.src);
                    } else {
                        imagePlaceholder.style.display = 'none';
                        resultImage.classList.add('show');
                    }
                });
            } else if (post.is_gallery) {
                console.log('üì∏ GALLERY DETECTED ‚Äî checking if it has gallery data');

                // Only set needsPatch if the post ACTUALLY has gallery data
                if (post.gallery_data) {
                    console.log('‚úÖ Valid gallery data found, setting up for patch');
                    needsPatch = true;

                    // Ensure container is visible
                    imgContainer.style.visibility = 'visible';

                    // Make sure resultImage is ready for patching
                    resultImage.style.opacity = '0';
                } else {
                    console.log('‚ùå Post marked as gallery but missing data, treating as normal post');
                    // Handle as if it's not a gallery
                    imgContainer.style.visibility = 'hidden';
                }
            }
            // Append sections
            resultCard.appendChild(voteSection);
            resultCard.appendChild(contentSection);
            resultCard.appendChild(commentsSection);
            resultCard.appendChild(imgContainer);

            // Add resultCard to the main results container
            resultsContainer.appendChild(resultCard);

            // Gallery post check
            if (post.is_gallery && post.gallery_data && post.media_metadata) {
                tryGalleryPatch(post, post.permalink, resultCard);
            }

            // Append image+shimmer for preview or gallery
         
                imageWrapper.appendChild(imagePlaceholder);
                imageWrapper.appendChild(resultImage);

                resultImage.addEventListener('load', () => {
                if (resultImage.naturalWidth === 0 || resultImage.naturalHeight === 0) {
                    console.warn('‚ö†Ô∏è Image loaded but invisible:', resultImage.src);
                } else {
                    const shimmer = resultCard.querySelector('.image-placeholder');
                    if (shimmer) shimmer.style.display = 'none';

                    imagePlaceholder.style.display = 'none';
                    resultImage.classList.add('show');
                }
            });

                const imageLink = document.createElement('a');
                imageLink.href = `https://www.reddit.com${post.permalink}`;
                imageLink.target = '_blank';
                imageLink.rel = 'noopener noreferrer';

                imageLink.appendChild(imageWrapper);
                imgContainer.appendChild(imageLink);
      
            // Add play icon for video or gif links
            if (
                post.is_video ||
                (post.domain && post.domain.includes('youtu')) ||
                (post.url && post.url.includes('v.redd.it')) ||
                (post.domain && post.domain.includes('streamable')) ||
                (post.url && post.url.endsWith('.gifv'))
            ) {
                const playIcon = document.createElement('div');
                playIcon.className = 'play-icon';
                playIcon.innerHTML = '‚ñ∂';
                imgContainer.appendChild(playIcon);
            }

            // Trigger gallery patch if needed
            if (needsPatch) {
                console.log('üß™ TRIGGER PATCH for:', post.permalink);
                console.log('üìé Permalink on card:', resultCard.dataset.permalink);

                setTimeout(() => {
                    tryGalleryPatch(post, post.permalink, resultCard); // ‚Üê pass the actual element
                }, 0);
            }
        
        });

        console.log("Current After:", currentAfter)
        resultsContainer.style.opacity = 1; // üî• Fade new results back in
        updatePagination();
    }


    // Filter NSFW after results load

    const safeSearchSelect = document.getElementById('safesearch-select');
    if (safeSearchSelect?.value === 'on') {
        document.body.classList.add('safe-search-enabled');
    } else {
        document.body.classList.remove('safe-search-enabled');
    }

        // Function to filter posts by content type
            function filterByContentType(posts, contentType) {
                // If no content type filter or set to 'all', return all posts
                if (!contentType || contentType === 'all') {
                    return posts;
                }

                // Apply content type filtering
                return posts.filter(post => {
                    // For picture posts
                    if (contentType === 'pictureposts') {
                
                        return (
                            // Image URLs
                            (post.url && /\.(jpg|jpeg|png|gif|webp)$/i.test(post.url)) ||

                            // Reddit's image hosting domain
                            (post.domain === 'i.redd.it') ||

                            // Gallery posts
                            (post.domain === 'reddit.com') ||

                            // Has image preview data but isn't a video
                            (post.preview && post.preview.images && post.preview.images.length > 0 && !post.is_video)
                        );
                    }
                    // For text posts
                    else if (contentType === 'textposts') {
                        return (
                            // Self posts (text posts) have domains starting with "self."
                            (post.domain && post.domain.startsWith('self.')) ||

                            // Is explicitly marked as a self post
                            (post.is_self === true)
                        );
                    }
                    return true; // Default case (all content)
                });
            }

        // Add cache management utility function
        function clearExpiredCaches() {
            const now = Date.now();
            const cachePrefix = 'kf_search_';

            // Loop through all localStorage items
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);

                // Only process our cache keys
                if (key && key.startsWith(cachePrefix)) {
                    try {
                        const cachedData = JSON.parse(localStorage.getItem(key));

                        // Remove if expired
                        if (now - cachedData.timestamp >= CACHE_DURATION_MS) {
                            localStorage.removeItem(key);
                            console.log('üßπ Removed expired cache:', key);
                        }
                    } catch (e) {
                        // If we can't parse it, remove it
                        localStorage.removeItem(key);
                    }
                }
            }
        }

        function showLoading() {
        
            isLoading = true;
            resultsContainer.innerHTML = '';
            resultsContainer.innerHTML = `
        <div class='results-error' id='spinner-box'></div>
    `;
            const spinnerWrapper = createCanvasSpinner();
            document.getElementById('spinner-box').appendChild(spinnerWrapper);

            paginationContainer.innerHTML = '';
            resultsContainer.style.opacity = 1;
        }

        // Function to fetch and cache comments for a post
        async function fetchComments(permalink, commentsContainer) {
                const postId = permalink;

                const now = Date.now();

                 // Validate permalink first
                if (!permalink || typeof permalink !== 'string' || !permalink.startsWith('/r/')) {
                console.error('‚ùå Invalid permalink provided to fetchComments:', permalink);
                return;
            }

                // Clean out old entries first
                for (const key in commentCache) {
                    if (commentCache[key]?.timestamp && now - commentCache[key].timestamp > CACHE_DURATION_MS) {
                        delete commentCache[key];
                    }
                }

                // Try to serve from cache
                if (commentCache[postId] && now - commentCache[postId].timestamp < CACHE_DURATION_MS) {
                renderComments({
                        data: {
                        children: commentCache[postId].comments,
                        totalCount: commentCache[postId].totalCount 
                    }
                }, commentsContainer, permalink);

                    // Always try to patch gallery image with .json fallback                   
                    fetch(`https://karmafinder.onrender.com/reddit?url=https://www.reddit.com${permalink}.json`)
                        .then(res => res.json())
                        .then(data => {
                            const fullPost = data?.[0]?.data?.children?.[0]?.data;
                            // ONLY call tryGalleryPatch if this is actually a gallery post with gallery data
                            if (fullPost && fullPost.is_gallery && fullPost.gallery_data && fullPost.media_metadata) {
                                console.log("üì∏ Found valid gallery post, patching image");
                                const resultCard = document.querySelector(`[data-permalink="${permalink}"]`);
                                if (resultCard) {
                                    tryGalleryPatch(fullPost, permalink, resultCard);
                                } else {
                                    console.warn('‚ö†Ô∏è Could not find resultCard for gallery patch');
                                }
                            }

                        })
                        .catch(err => {
                            console.error("‚ùå Error fetching post data for gallery patch:", err);
                        });          

                return;
            }

                const fixedPermalink = permalink.endsWith('.json') ? permalink : `${permalink}.json`;
                const commentsUrl = `http://localhost:3000/reddit?url=https://www.reddit.com${fixedPermalink}`;

                try {
                const response = await fetch(commentsUrl);
                if (!response.ok) {
                    console.log('Failed to fetch comments.');
                    return;
                }

                const data = await response.json();

               // Grab gallery posts while you're at it
                    const fullPost = data?.[0]?.data?.children?.[0]?.data;
                    // Only patch if it's actually a gallery post with the required data
                    if (fullPost && fullPost.is_gallery && fullPost.gallery_data && fullPost.media_metadata) {
                        console.log("üì∏ Found valid gallery post, patching image");
                        const resultCard = document.querySelector(`[data-permalink="${permalink}"]`);
                        if (resultCard) {
                            tryGalleryPatch(fullPost, permalink, resultCard);
                        } else {
                            console.warn('‚ö†Ô∏è Could not find resultCard for gallery patch');
                        }                  

                    }

                const commentsData = data[1].data.children;
                const reduced = commentsData
                    .filter(c => c.kind === 't1')
                    .slice(0, 5)
                    .map(c => ({
                        author: c.data.author,
                        body: c.data.body,
                        score: c.data.score,
                        created_utc: c.data.created_utc
                    }));

                commentCache[postId] = {
                    comments: reduced,
                    totalCount: commentsData.length,
                    timestamp: now
                };

                const serialized = JSON.stringify(commentCache);
                if (serialized.length < 4900000) {
                    localStorage.setItem('commentCache', serialized);
                } else {
                    console.warn('‚ö†Ô∏è commentCache too large, not saved');
                }

                renderComments({
                        data: {
                        children: commentCache[postId].comments,
                        totalCount: commentCache[postId].totalCount 
                    }
                }, commentsContainer, permalink);
            } catch (error) {
                console.error('‚ùå Fetch error for', permalink, error);

                }
            }

        function showError(message) {
                resultsContainer.innerHTML = `
        <div class='results-error'>
            <p>${message}</p>
        </div>
    `;
                paginationContainer.innerHTML = '';
                resultsContainer.style.opacity = 1;
            }

      

       function renderComments(data, commentsContainer, permalink) {
            console.log("üß™ renderComments CALLED WITH:", data);

               // Don't try to access gallery data if this is just comment data
           // Only try gallery patches when we have the actual post data
           if (data?.kind === 'Listing' && data?.data?.children?.[0]?.kind === 't3') {
               // 't3' is the prefix for posts (not comments)
               const fullPost = data?.data?.children?.[0]?.data;
               if (fullPost?.is_gallery && fullPost?.gallery_data && fullPost?.media_metadata) {
                   console.log("üì∏ Triggering gallery patch with full metadata:", fullPost);
                   const resultCard = document.querySelector(`[data-permalink="${permalink}"]`);
                   tryGalleryPatch(fullPost, permalink, resultCard);

               }
           }

           // Process the comments
           const commentsData = data?.data?.children || [];
           const totalCommentsCount = data?.data?.totalCount || commentsData.length;

           if (commentsData.length === 0) {
               commentsContainer.innerHTML = '<div class="no-comments">No comments found</div>';
               return;
           }          

                // Sort comments by score (highest first)
                commentsData.sort((a, b) => (b.score || 0) - (a.score || 0));
                commentsContainer.innerHTML = '';

                const topComments = commentsData.slice(0, 5);
                topComments.forEach(comment => {
                    const c = comment;

                    const commentEl = document.createElement('div');
                    commentEl.className = 'comment';

                    const authorEl = document.createElement('div');
                    authorEl.className = 'comment-author';
                    const authorIconEl = document.createElement('div');
                    authorIconEl.className = 'comment-author-icon';
                    authorIconEl.textContent = c.author.charAt(0).toUpperCase();
                    authorEl.appendChild(authorIconEl);
                    authorEl.appendChild(document.createTextNode(c.author));

                    const textEl = document.createElement('div');
                    textEl.className = 'comment-text';
                    
                    textEl.appendChild(renderCommentBody(c.body));

                    const metaEl = document.createElement('div');
                    metaEl.className = 'comment-meta';
                    const scoreEl = document.createElement('span');
                    scoreEl.className = 'comment-score';
                    scoreEl.textContent = formatNumber(c.score) + ' points';
                    const timeEl = document.createElement('span');
                    timeEl.className = 'comment-time';
                    timeEl.textContent = formatTimestamp(c.created_utc);
                    metaEl.appendChild(scoreEl);
                    metaEl.appendChild(timeEl);

                    commentEl.appendChild(authorEl);
                    commentEl.appendChild(textEl);
                    commentEl.appendChild(metaEl);
                    commentsContainer.appendChild(commentEl);
                });

               // Add "See more comments" link if there are more than 5 comments
                     if (totalCommentsCount > 5) {
                        const seeMoreEl = document.createElement('div');
                        seeMoreEl.className = 'see-more-comments';
                        seeMoreEl.textContent = `See all ${totalCommentsCount} comments`;

                        seeMoreEl.addEventListener('click', () => {
                            window.open(`https://www.reddit.com${permalink}`, '_blank');
                        });

                        commentsContainer.appendChild(seeMoreEl);
                        
                    }
                }


        function updatePagination() {
                console.log("Pagination tokens:", {
                    currentAfter,
                    currentBefore,
                    historyEntry: navigationHistory[currentPageIndex]
                });
        
            paginationContainer.innerHTML = '';

            let prevButton;

            if (currentPageIndex > 0) {
                const prevButton = document.createElement('button');
                prevButton.className = 'pagination-button';
                prevButton.textContent = '‚Üê Previous';
                prevButton.disabled = currentPageIndex === 0;
                prevButton.addEventListener('click', () => {
                    if (currentPageIndex === 0) {
                        console.warn("‚ö†Ô∏è Already on the first page. Can't go back.");
                    return;
                }

                currentPageIndex--; 
                const targetPage = navigationHistory[currentPageIndex];
                const prevToken = targetPage.before; 

                performSearch(null, prevToken, true, targetPage.query); 
                savePaginationState();
            });
            paginationContainer.appendChild(prevButton);
        }            

            if (currentAfter) {
                const nextButton = document.createElement('button');
                nextButton.className = 'pagination-button';
                nextButton.textContent = 'Next ‚Üí';
                nextButton.disabled = false;
                nextButton.addEventListener('click', () => {
        
                    const tokenToUse = currentAfter;

                    currentPageIndex++;
                    console.log("Next clicked - using currentAfter:", currentAfter);

                    // Use the saved token explicitly
                    performSearch(tokenToUse, null, false);
                    savePaginationState();
                });

                paginationContainer.appendChild(nextButton);
            }
       
        }

      function savePaginationState() {
            sessionStorage.setItem('kf_current_page_index', currentPageIndex);
            sessionStorage.setItem('kf_current_after', currentAfter || '');
            sessionStorage.setItem('kf_current_filters', JSON.stringify(currentFilters));
        }

        function formatTimestamp(timestamp) {
            const date = new Date(timestamp * 1000);
            const now = new Date();
            const diffSeconds = Math.floor((now - date) / 1000);

            if (diffSeconds < 60) {
                return `${diffSeconds} second${diffSeconds !== 1 ? 's' : ''} ago`;
            }

            const diffMinutes = Math.floor(diffSeconds / 60);
            if (diffMinutes < 60) {
                return `${diffMinutes} minute${diffMinutes !== 1 ? 's' : ''} ago`;
            }

            const diffHours = Math.floor(diffMinutes / 60);
            if (diffHours < 24) {
                return `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
            }

            const diffDays = Math.floor(diffHours / 24);
            if (diffDays < 30) {
                return `${diffDays} day${diffDays !== 1 ? 's' : ''} ago`;
            }

            const diffMonths = Math.floor(diffDays / 30);
            if (diffMonths < 12) {
                return `${diffMonths} month${diffMonths !== 1 ? 's' : ''} ago`;
            }

            const diffYears = Math.floor(diffMonths / 12);
            return `${diffYears} year${diffYears !== 1 ? 's' : ''} ago`;
        }

        function formatNumber(num) {
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'm';
            }
            if (num >= 1000) {
                return (num / 1000).toFixed(1) + 'k';
            }
            return num.toString();
        }

        // Security function to prevent XSS
        function sanitizeHTML(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        document.addEventListener('DOMContentLoaded', () => {
            const input = document.querySelector('#subreddit-input');
            const dropdown = document.querySelector('.subreddit-suggestions');

            if (input && dropdown) {
                // CLICKING OUTSIDE ‚Üí closes dropdown
                document.addEventListener('mousedown', (e) => {
                    if (!input.contains(e.target) && !dropdown.contains(e.target)) {
                        dropdown.classList.remove('active');
                    }

                });

                // CLICKING ON A SUGGESTION ‚Üí apply + close dropdown
                dropdown.addEventListener('click', (e) => {
                    const clickedItem = e.target.closest('.subreddit-suggestion');
                    if (clickedItem) {
                        input.value = clickedItem.dataset.name || clickedItem.innerText;
                        dropdown.classList.remove('active');
                    }
                });
            }
        });

    function renderCommentBody(rawBody) {
        const wrapper = document.createElement('div');
        wrapper.className = 'comment-body';

        // Decode HTML entities
        const txt = document.createElement("textarea");
        txt.innerHTML = rawBody.trim();
        const decoded = txt.value;

        // Regex for Reddit-hosted images
        const imageRegex = /(https:\/\/preview\.redd\.it\/[^\s]+?\.(jpeg|jpg|png|gif|webp)(\?[^\s]*)?)/i;
        const match = decoded.match(imageRegex);

        // Regex for markdown GIF syntax e.g. ![gif](giphy|<id>|downsized)
        const gifRegex = /!\[gif\]\((giphy)\|([^\|]+)\|[^\)]+\)/i;
        const gifMatch = decoded.match(gifRegex);

        if (match) {
            const img = document.createElement('img');
            img.src = match[1];
            img.alt = 'Image from comment';
            img.loading = 'lazy';
            img.style.maxWidth = '100%';
            img.style.borderRadius = '8px';
            wrapper.appendChild(img);
        } else if (gifMatch) {
            const provider = gifMatch[1];
            const gifId = gifMatch[2];

            if (provider.toLowerCase() === 'giphy') {
                const gifUrl = `https://media.giphy.com/media/${gifId}/giphy.gif`;
                const img = document.createElement('img');
                img.src = gifUrl;
                img.alt = 'GIF from comment';
                img.loading = 'lazy';
                img.style.maxWidth = '100%';
                img.style.borderRadius = '8px';
                wrapper.appendChild(img);
            }
        } else {
            const lines = decoded.split('\n');
            lines.forEach(line => {
                const lineEl = document.createElement('div');
                if (line.trim().startsWith('>')) {
                    lineEl.className = 'quote';
                    lineEl.textContent = line.replace(/^>\s?/, '');
                } else {
                    lineEl.textContent = sanitizeHTML(line);
                }
                wrapper.appendChild(lineEl);
            });
        }

        return wrapper;
    }


    </script>

<script src="themetoggle.js" defer></script>

</body>

</html>