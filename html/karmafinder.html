<!DOCTYPE html>
<html lang="en">

<head>
<link rel="stylesheet" href="https://cdn.plyr.io/3.7.8/plyr.css" />
<link rel="stylesheet" href="styles.css" />
<link rel="stylesheet" href="bookmarks.css">
<link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon-32x32.png">
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
<script src="https://cdn.plyr.io/3.7.8/plyr.polyfilled.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta property="og:title" content="KarmaFinder - Reddit Search Engine">
    <meta name="description" content="Search Reddit like Google. Find exactly what you're looking for across any subreddit.">
    <meta name="keywords" content="reddit search, reddit finder, search reddit posts, reddit search engine, reddit viewer">
    <meta property="og:description" content="Reddit Search Engine. Find exactly what you're looking for on Reddit">
    <title>KarmaFinder</title>
    
</head>

<body>

<script>
    
    try {
        if (localStorage.getItem('theme') === 'dark') {
            document.body.classList.add('dark-mode');
        }
    } catch (e) { }

    window.stripeCustomerId = localStorage.getItem('userId');

    window.addEventListener('beforeunload', function (e) {
            console.trace('üö® PAGE UNLOAD TRIGGERED - STACK TRACE:');
        });

</script>

    <a href="https://ko-fi.com/hawaiichair23" target="_blank" class="donate-btn floating-button">
        <img src="https://storage.ko-fi.com/cdn/cup-border.png" alt="Ko-fi"
            style="height: 20px; width: 20px; margin-right: 3px; vertical-align: middle;">
        Support the Site
    </a>
<div class="theme-toggle-container">
    <button class="theme-arrow" onclick="toggleThemeMenu()" tabindex="2">üé®</button>
    <div class="theme-dropdown" id="themeDropdown">
        <div class="theme-option" onclick="selectTheme('default')"
            onkeydown="handleThemeKeydown(event, 'default')" aria-label="Select Default theme">
            <div class="theme-preview" style="background: linear-gradient(45deg, #ff4500, #ffffff)"></div>
            <span>Default</span>
        </div>
        <div class="theme-option" onclick="selectTheme('bluebird')"
            onkeydown="handleThemeKeydown(event, 'bluebird')" aria-label="Select Bluebird theme">
            <div class="theme-preview" style="background: linear-gradient(45deg, #94cbff, #217eff)"></div>
            <span>Bluebird</span>
        </div>
        <div class="theme-option" onclick="selectTheme('forest')"
            onkeydown="handleThemeKeydown(event, 'forest')" aria-label="Select Forest theme">
            <div class="theme-preview" style="background: linear-gradient(45deg, #007c51, #004b32)"></div>
            <span>Forest</span>
        </div>
    </div>
</div>
<div class="get-premium-container" id="getPremiumContainer">
    <div class="get-premium-text">Get Premium ‚≠ê</div>
</div>
    </div>
    <div class="plan-display-container" tabindex="3">
        <div id="plan-display">Pro</div>
    </div>
    <div class="container">
        <header
            style="display: flex; justify-content: center; align-items: center; position: relative; padding: 0.3rem 0;">
            <div style="text-align: center;">
            <a href="karmafinder.html" class="link-container">
                <div class="logo">KarmaFinder</div>
                </a>
                <div class="tagline">Find exactly what you're looking for on Reddit üîé</div>
                <img src="../assets/hermes.png" alt="Hermes Detective Cat" class="hermes-cat">
                <div id="hermes-speech" class="speech-bubble hidden">
                    <div class="speech-tail speech-tail-outline"></div>
                    <div class="speech-tail speech-tail-inner"></div>
                    <div class="speech-text"></div>
                </div>


            </div>
        </header>
        <button id="themeToggle" class="theme-toggle" aria-label="Toggle Dark Mode" tabindex="1">
            <img id="themeIcon" alt="Toggle theme" />
        </button>
        <a href="?page=bookmarks" class="bookmark-link">
            <span class="bookmark-tiny"></span>
            Bookmarks
        </a>
            <button id="loginLogoutBtn" class="login-link">
                <span class="login-icon login-icon-image"></span>
                <span id="loginBtnText">Log In</span>
            </button>
        <div class="search-container">
        
          <div class="search-top-row">

                    <div class="toggle-group">
                        <div class="toggle-wrapper">
                            <label class="switch">
                                <input type="checkbox" id="toggle1" />
                                <span class="slider" tabindex="0"></span>
                            </label>
                            <span class="toggle-label" tabindex="0">‚ú® Enhanced Search</span>
                        </div>
                    
                        <div class="toggle-wrapper">
                            <label class="switch">
                                <input type="checkbox" id="toggle2" />
                                <span class="slider" tabindex="0"></span>
                            </label>
                            <span class="toggle-label" tabindex="0">Reddit Search</span>
                        </div>
                    </div>

            <div class="search-input-container">
                <svg class="search-icon" width="22" height="22" viewBox="0 0 24 24" fill="none">
                    <circle cx="10" cy="10" r="7" stroke="currentColor" stroke-width="2" fill="none" />
                    <path d="m15.8 15.8 4.2 4.2" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
                </svg>
                    <input type="text" id="search-input" class="search-input" placeholder="Search Reddit">
                    <div id="suggestions"></div>
                        <button id="search-button" class="search-button"></button>
                    </div>
                <img src="../assets/iconny thingy.png" alt="filter icon" id="filter-icon" />
                <button id="comfy-toggle" aria-label="Toggle Comfy Mode" tabindex="0">
                    <img src="../assets/comfy-default.png" alt="Toggle comfy layout" />
                </button>
                <button id="compact-toggle" aria-label="Toggle Compact Mode" tabindex="0">
                    <img src="../assets/compact-default.png" alt="Toggle compact layout" />
                </button>
            </div>

            <div class="advanced-options">
                <div class="option-group">
                    <label for="sort-select">Sort By</label>
                    <select id="sort-select">
                        <option value="hot">Hot</option>
                        <option value="top">Top</option>
                        <option value="new">New</option>
                        <option value="relevance">Relevance</option>
                    </select>
                </div>

                <div class="option-group">
                    <label for="time-select">Time Period</label>
                    <select id="time-select">
                        <option value="all">All Time</option>
                        <option value="year">Past Year</option>
                        <option value="month">Past Month</option>
                        <option value="week">Past Week</option>
                        <option value="day">Past 24 Hours</option>
                        <option value="hour">Past Hour</option>
                    </select>

                </div>
                <div class="option-group">
                    <label for="safesearch-select">SafeSearch</label>
                    <select id="safesearch-select">
                        <option value="on">On</option>
                        <option value="off">Off</option>
                    </select>
                </div>

                <div class="option-group subreddit-dropdown">
                    <label for="subreddit-input">Subreddit (optional)</label>
                    <input type="text" id="subreddit-input" placeholder="e.g., AskReddit">
                    <div id="subreddit-suggestions-container">
                        <div id="subreddit-suggestions" class="subreddit-suggestions"></div>
                    </div>
                    <div class="filter-chip-container" id="subreddit-chip-container">
                        <span class="chip-text"></span>
                        <span class="remove-chip">√ó</span>
                    </div>
                </div>

                <div class="option-group">
                    <label for="content-select">Content Type</label>
                    <select id="content-select">
                        <option value="all">All Content</option>
                        <option value="video">Video Posts Only</option>
                        <option value="image">Picture Posts Only</option>
                        <option value="text">Text Posts Only</option>
                    </select>
                </div>
            </div>
        </div>
        
        <div id="results" class="results-container">
        </div>

        <div id="pagination" class="pagination">
        </div>
        <footer>
            <p>KarmaFinder is an independent search utility and is not affiliated with Reddit Inc.</p>
            <br>
            <a href="https://github.com/hawaiichair23/KarmaFinder" class="github-button" id="button" target="_blank" 
   rel="noopener noreferrer">
            <svg width="24" height="24" viewBox="0 0 16 16" fill="white" alt="Github">
                <path
                    d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z" />
            </svg>
                    Github</a>
                    <br>
                    <br>
            <p class="footie" tabindex="0">Made by hawaiichair23</p>
        </footer>
    </div>

    <script>
        
        // SEVEN MINUTES. SEVEN MINUTES IS ALL I CAN SPARE TO PLAY WITH YOU.
        const CACHE_DURATION_MS = 7 * 60 * 1000;
        
        // Configuration 
        const API_ENDPOINT = 'http://localhost:3000/reddit';

        const RESULTS_PER_PAGE = 10;

        const IMAGE_PROXY_BASE = location.hostname === 'localhost'
                ? 'http://localhost:3000'
                : 'https://karmafinder-production.up.railway.app';

        let searchTimeout = null;

        function preloadBookmarks(stripeCustomerId, callback) {

            if (!stripeCustomerId) {
                console.log('No customer ID available, clearing bookmarks');
                sessionStorage.removeItem('bookmarks');
                document.querySelectorAll('.bookmark-icon').forEach(icon => {
                    icon.classList.remove('saved');
                });
                return;
            }
                fetch(`http://localhost:3000/api/bookmarks/${stripeCustomerId}?limit=1000`)
                    .then(res => res.json())
                    .then(data => {
                        const bookmarks = {};
                        data.bookmarks.forEach(post => {
                            bookmarks[post.reddit_post_id] = true;
                        });

                        sessionStorage.setItem('bookmarks', JSON.stringify(bookmarks));

                        // ‚úÖ Apply bookmarks to any currently rendered icons
                        document.querySelectorAll('.bookmark-icon').forEach(icon => {
                            const postId = icon.dataset.postId;
                            if (bookmarks[postId]) {
                                icon.classList.add('saved');
                            } else {
                                icon.classList.remove('saved');
                            }
                        });

                        if (callback) callback();
                    })
                    .catch(err => {
                        console.error('‚ùå Failed to preload bookmarks:', err);
                        if (callback) callback();
                    });
            }

    // DOM Elements
    const searchInput = document.getElementById('search-input');
    const suggestionsDiv = document.getElementById('suggestions');
    const searchButton = document.getElementById('search-button');
    const sortSelect = document.getElementById('sort-select');
    const timeSelect = document.getElementById('time-select');
    const subredditInput = document.getElementById('subreddit-input');
    const contentSelect = document.getElementById('content-select');
    const resultsContainer = document.getElementById('results');
    const paginationContainer = document.getElementById('pagination');
    const subredditSuggestions = document.getElementById('subreddit-suggestions');
    const subredditChipContainer = document.getElementById('subreddit-chip-container');
    const dropdown = document.getElementById('subreddit-suggestions');

    // State
    const savedCommentCache = localStorage.getItem('commentCache');
    const commentCache = savedCommentCache ? JSON.parse(savedCommentCache) : {};

    window.cachedMediaByUrl = {};

    let navigationHistory = [];
    let activeQueryToken = 0;
    let cachedPostsById = {};
    let pendingCatReaction = null;
    let bannedSubreddits = [];
    let isScrambled = false;
    let searchCount = parseInt(localStorage.getItem('searchCount')) || 0;
    let currentPageIndex = 0;
    let lastQuery = "";
    let isTalking = false;
    let mouthTimeout;
    let hermesLineCount = 0;
    let currentAfter = null;
    let currentBefore = null;
    let isLoading = false;
    let currentFilters = {
        sort: 'hot',
        time: 'all',
        subreddit: '',
    };
    
    // Data for html injection
        if (window.preloadedSearchData && window.preloadedQuery !== undefined) { 
            console.log('üöÄ Using preloaded search data');

            // Set the search input
            searchInput.value = window.preloadedQuery;

            // Set the subreddit if one was preloaded
            if (window.preloadedSubreddit) {

                const subredditInput = document.getElementById('subreddit-input'); 
                if (subredditInput) {
                    subredditInput.value = window.preloadedSubreddit;
                }
                console.log('üéØ Set subreddit to:', window.preloadedSubreddit);
            }

            // Process the data the same way performSearch does
            const data = window.preloadedSearchData;
            currentAfter = data.data.after || null;
            currentBefore = data.data.before || null;
            const trimmedData = data.data.children.map(post => ({
                id: post.data.id,
                title: post.data.title,
                url: post.data.url,
                permalink: post.data.permalink,
                subreddit: post.data.subreddit,
                score: post.data.score,
                is_video: post.data.is_video,
                domain: post.data.domain,
                author: post.data.author,
                created_utc: post.data.created_utc,
                num_comments: post.data.num_comments,
                over_18: post.data.over_18,
                preview: post.data.preview,
                selftext: post.data.selftext,
                body: post.data.body,
                is_gallery: post.data.is_gallery,
                gallery_data: post.data.gallery_data,
                media_metadata: post.data.media_metadata,
                crosspost_parent_list: post.data.crosspost_parent_list || [],
                content_type: post.content_type,
                icon_url: null,
                locked: post.data.locked,
                stickied: post.data.stickied
            }));
            displayResults(trimmedData);
            preloadBookmarks(window.stripeCustomerId);
            updatePagination();

            // Clean up
            delete window.preloadedSearchData;
            delete window.preloadedQuery;
            delete window.preloadedSubreddit;
        }

    // Load Blocklist 
        async function loadBlocklist() {
            try {
                const response = await fetch('./blocklist.json');
                const data = await response.json();
                bannedSubreddits = data.bannedSubreddits;
            } catch (error) {
                console.warn('No blocklist found'); 
            }
        }


    function loadPaginationState(fromPopState = false, direction = 'refresh') {
            const params = new URLSearchParams(window.location.search);
            const pageIndex = parseInt(params.get('page'), 10) || 0;
            const subreddit = params.get('sub') || '';
            const query = params.get('q') || '';
            const sort = params.get('sort') || 'hot';
            const time = params.get('time') || 'all';
            const contentType = params.get('type') || 'all';

            if (fromPopState && direction === 'refresh') {
                const oldPageIndex = currentPageIndex;
                direction = pageIndex > oldPageIndex ? 'forward' : pageIndex < oldPageIndex ? 'backward' : 'same';
            }

            currentPageIndex = pageIndex;
            currentFilters = { subreddit, query, sort, time, contentType };

            const savedAfter = sessionStorage.getItem('kf_current_after') || null;
            const savedHistory = JSON.parse(sessionStorage.getItem('kf_navigation_history') || '[]');
            currentAfter = savedAfter;
            currentBefore = null;
            navigationHistory = savedHistory;

            console.log('üîÑ Restored from sessionStorage - after:', currentAfter, 'history length:', navigationHistory.length);

            sortSelect.value = sort;
            timeSelect.value = time;
            contentSelect.value = contentType;
            searchInput.value = query;
            subredditInput.value = subreddit;
            if (subreddit) {
                selectSubreddit(subreddit);
            } else {
                subredditInput.value = '';
                subredditChipContainer.style.display = 'none';
            }

            console.log('üîÑ URL restored state:', currentFilters, 'Page:', currentPageIndex);

            if (!fromPopState) {
                const cleanParams = new URLSearchParams(window.location.search); // Start with existing params

                // Remove old filter params
                cleanParams.delete('page');
                cleanParams.delete('q');
                cleanParams.delete('sub');
                cleanParams.delete('sort');
                cleanParams.delete('time');
                cleanParams.delete('type');

                // Add current filter params
                if (currentPageIndex > 0) cleanParams.set('page', currentPageIndex);
                if (query) cleanParams.set('q', query);
                if (subreddit) cleanParams.set('sub', subreddit);
                if (sort !== 'hot') cleanParams.set('sort', sort);
                if (time !== 'all') cleanParams.set('time', time);
                if (contentType !== 'all') cleanParams.set('type', contentType);
                const newUrl = cleanParams.toString() ? '?' + cleanParams.toString() : window.location.pathname;
                window.history.replaceState({}, '', newUrl);
            }
            return true;
        }
    
    window.addEventListener('popstate', (event) => {
            console.log('‚Ü©Ô∏è Popstate event fired!', event.state);

            loadPaginationState(true);

            let afterTokenForPopstate = null;
            let beforeTokenForPopstate = null;

            if (currentPageIndex > 0) {
                if (navigationHistory.length > currentPageIndex - 1) {
                    afterTokenForPopstate = navigationHistory[currentPageIndex - 1]?.after || null;
                    beforeTokenForPopstate = navigationHistory[currentPageIndex - 1]?.before || null;
                    console.log(`üí° Popstate for page index ${currentPageIndex}, using after token: ${afterTokenForPopstate}`);
                } else {
                    console.warn(`‚ö†Ô∏è Popstate: Navigation history too short for page index ${currentPageIndex}. Falling back to first page.`);
                    currentPageIndex = 0;
                    afterTokenForPopstate = null;
                    beforeTokenForPopstate = null;
                }
            } else {
                console.log(`üí° Popstate for page index 0, fetching without after/before token.`);
            }

            performSearch(afterTokenForPopstate, beforeTokenForPopstate, true, false);
        });

    let animationsEnabled = true;
    let isSleeping = false;
    let blinkTimer1, blinkTimer2, blinkTimer3;
    let sleepTimer;

    // Single blink (e.g., on mouseover)
    function singleBlink() {
        if (!animationsEnabled || isSleeping) return;

        const img = document.querySelector('.hermes-cat');
        img.src = '../assets/hermes-blink.png';
        setTimeout(() => {
            if (!isSleeping) img.src = '../assets/hermes.png';
        }, 150);
    }

    // Random automatic blinking
    function randomBlink() {
        if (!animationsEnabled || isSleeping) return;

        const img = document.querySelector('.hermes-cat');

        // First blink
        img.src = '../assets/hermes-blink.png';
        setTimeout(() => {
            if (!isSleeping) img.src = '../assets/hermes.png';
        }, 150);

        // Random delay between double blinks (500‚Äì2000ms)
        const delayBetween = Math.random() * 1500 + 500;
        blinkTimer1 = setTimeout(() => {
            if (!isSleeping) {
                img.src = '../assets/hermes-blink.png';
                setTimeout(() => {
                    if (!isSleeping) img.src = '../assets/hermes.png';
                }, 150);
            }
        }, delayBetween);

        // Random delay until next double blink (5‚Äì13 seconds)
        const nextBlink = Math.random() * 8000 + 5000;
        blinkTimer2 = setTimeout(randomBlink, nextBlink);
    }

    // Start automatic blinking when page loads
    randomBlink();

    // Mouseover triggers a single blink
    document.querySelector('.hermes-cat').addEventListener('mouseover', singleBlink);

    // Sleep timer logic: go to sleep after inactivity
    function resetSleepTimer() {
        clearTimeout(sleepTimer);

        if (isSleeping) wakeUp();

        sleepTimer = setTimeout(() => {
            if (!isSleeping) startSleeping();
        }, 60000); // 60 seconds 
    }

    // Start sleep
    function startSleeping() {
        isSleeping = true;
        // Clear all blink timers
        clearTimeout(blinkTimer1);
        clearTimeout(blinkTimer2);
        clearTimeout(blinkTimer3);

        // Start the repeated slow Zzz...
        loopZzz();

        sleepAnimation();
    }

    function loopZzz() {
        if (!isSleeping) return;

        const bubble = document.getElementById('hermes-speech');
        const textElement = bubble.querySelector('.speech-text');
        bubble.classList.remove('hidden');
        typewriterEffect(textElement, "Zzz...", 600);

        // After it finishes, call again
        setTimeout(loopZzz, "Zzz...".length * 600 + 1000);
    }

    // Wake up
    function wakeUp() {
        isSleeping = false;
        const img = document.querySelector('.hermes-cat');
        img.src = '../assets/hermes.png';

        // Hide speech bubble
        const bubble = document.getElementById('hermes-speech');
        bubble.classList.add('hidden');

        // Restart normal blinking
        randomBlink();
    }


    // Sleep animation (head bobbing loop)
    function sleepAnimation() {
            if (!animationsEnabled || !isSleeping) return;

            const img = document.querySelector('.hermes-cat');

            // Step 1: start from normal closed eyes
            img.src = '../assets/hermes-blink.png';

            // Falling down part (accelerating)
            setTimeout(() => {
                img.src = '../assets/hermes-sleep2.png';
            }, 400); // quick

            setTimeout(() => {
                img.src = '../assets/hermes-sleep3.png';
            }, 800); // still quick

            setTimeout(() => {
                img.src = '../assets/hermes-sleep4.png';
            }, 1300); // a bit slower

            // Rising up part (decelerating)
            setTimeout(() => {
                img.src = '../assets/hermes-sleep3.png';
            }, 1900); // slower

            setTimeout(() => {
                img.src = '../assets/hermes-sleep2.png';
            }, 2500); // even slower

            setTimeout(() => {
                img.src = '../assets/hermes-blink.png';
                // Loop again if still sleeping
                if (isSleeping) {
                    setTimeout(sleepAnimation, 800); // pause before repeating
                }
            }, 3200); // final slow return to top
        }

    // Activity resets sleep timer
    ['mousemove', 'keypress', 'click', 'scroll'].forEach(event =>
        document.addEventListener(event, resetSleepTimer)
    );

    // Start sleep timer on page load
    resetSleepTimer();

    let currentTypewriterTimeout;

    function typewriterEffect(element, text, speed = 50) {
        if (!animationsEnabled) {
            // Just show the text instantly
            element.textContent = text;
            return;
        }
        // Only clear existing typewriter 80% of the time
        if (Math.random() < 0.80) {
            clearTimeout(currentTypewriterTimeout);
        }

        element.textContent = '';
        let i = 0;
        function typeChar() {
            if (i < text.length) {
                element.textContent += text.charAt(i);
                i++;
                currentTypewriterTimeout = setTimeout(typeChar, speed);
            }
        }
        typeChar();
    }

    function showSpeechBubble(messages) {
        const bubble = document.getElementById('hermes-speech');
        const textElement = bubble.querySelector('.speech-text');
        const message = Array.isArray(messages) ?
            messages[Math.floor(Math.random() * messages.length)] : messages;

        // Early return for mute toggle
        if (!hermesEnabled) return;

        if (message.length > 27) {
            let cutPoint = 27;
            // Find the last space before the limit
            while (cutPoint > 0 && message[cutPoint] !== ' ') {
                cutPoint--;
            }
            // If no space found, fall back to character limit
            if (cutPoint === 0) cutPoint = 27;

            const firstPart = message.substring(0, cutPoint);
            const remainingPart = message.substring(cutPoint + 1);

            // Show first part
            bubble.classList.remove('hidden');
            startTalking();
            typewriterEffect(textElement, firstPart, 50);

            // After first part finishes, call showSpeechBubble again for remaining part, splitting again
            setTimeout(() => {
                stopTalking();
                hideSpeechBubble();
                showSpeechBubble(remainingPart); // This will re-check the 27 char limit
            }, firstPart.length * 50 + 700);
            return;
        }

        // Normal case
        bubble.classList.remove('hidden');
        startTalking();
        typewriterEffect(textElement, message, 50);
        setTimeout(() => stopTalking(), message.length * 50 + 700);
    }

    function startTalking() {

        isTalking = true;
        mouthMovement();
    }

    function mouthMovement() {
        if (!isTalking || !animationsEnabled) return;

        const img = document.querySelector('.hermes-cat');

        // Open mouth
        img.src = '../assets/hermes-mouthopen.png';

        // Mouth open duration
        const openDuration = Math.random() * 90 + 150;

        setTimeout(() => {
            if (!isTalking) return;

            // Close mouth
            img.src = '../assets/hermes.png';

            // Mouth closed duration
            const closedDuration = Math.random() * 50 + 60;

            // Continue the cycle
            mouthTimeout = setTimeout(mouthMovement, closedDuration);
        }, openDuration);
    }

    function stopTalking() {
        isTalking = false;
        clearTimeout(mouthTimeout);

        // Make sure mouth is closed
        const img = document.querySelector('.hermes-cat');
        img.src = '../assets/hermes.png';
    }

    function hideSpeechBubble() {
            const bubble = document.getElementById('hermes-speech');
            bubble.classList.add('hidden');
        }

        let clickCount = 0;
        let firstClickTime = 0;
        let isBlocked = false; 

        function scrambleYeller() {
                const now = Date.now();
                if (now - firstClickTime > 2000) {
                    clickCount = 0;
                    firstClickTime = now;
                }
                clickCount++;
                if (clickCount >= 5) {
                    isScrambled = true; // Set blocked state

                    showSpeechBubble([
                        "YOU KNOW I GET SCRAMBLED!",
                        "STOP!",
                        "GOOD GRIEF!",
                        "ONE AT A TIME."
                    ]);

                    setTimeout(() => {
                        isScrambled = false; // Unblock after 2.5 seconds
                        clickCount = 0;
                    }, 2500);

                    return true;
                }
                return isScrambled || false;
            }

    async function showRareLines() {
        try {
            const response = await fetch('http://localhost:3000/api/rare-line');
            const data = await response.json();

            if (data.line) {
                clearTimeout(currentTypewriterTimeout);
                showSpeechBubble(data.line);
            } else if (data.sequential) {
                // Show 5-7
                showSpeechBubble(data.sequential[0]);
                setTimeout(() => {
                    showSpeechBubble(data.sequential[1]);
                    setTimeout(() => {
                        showSpeechBubble(data.sequential[2]);
                    }, 3000); // 3 seconds
                }, 31000); // 31
            }
        } catch (error) {
            console.error('Error fetching rare line:', error);
        }
    }   

    let hermesEnabled = true;
    let blinkTimeout;

    document.querySelector('.hermes-cat').addEventListener('contextmenu', function (e) {
            e.preventDefault();

            const menu = document.getElementById('hermesContextMenu');
            menu.style.display = 'block';
            menu.style.left = e.pageX + 'px';
            menu.style.top = e.pageY + 'px';
        });

    // Hide context menu when clicking elsewhere
    document.addEventListener('click', function () {
        document.getElementById('hermesContextMenu').style.display = 'none';
    });

    // Hide context menu when right-clicking elsewhere
    document.addEventListener('contextmenu', function (e) {
        // Only hide if the right-click is NOT on the hermes cat
        if (!e.target.closest('.hermes-cat')) {
            document.getElementById('hermesContextMenu').style.display = 'none';
        }
    });

  // ANIMATIONS TOGGLE WITH LOCALSTORAGE
    document.addEventListener('DOMContentLoaded', function () {
        const muteBtn = document.getElementById('muteHermes');
        const animBtn = document.getElementById('toggleAnimations');

        // Load saved settings or use defaults
        hermesEnabled = localStorage.getItem('hermesEnabled') !== 'false'; // default true
        animationsEnabled = localStorage.getItem('animationsEnabled') !== 'false'; // default true

        // Check for greeting
            if (!sessionStorage.getItem('hasVisited')) {
            playGreeting();
            sessionStorage.setItem('hasVisited', 'true');
        }
            function playGreeting() {
            if (!hermesEnabled) return;
            setTimeout(() => { showSpeechBubble("Welcome back."); }, 350);
        }

        // Apply saved settings on page load
        function applySavedSettings() {
            // Apply hermes/bell setting
            const bellElement = muteBtn.querySelector('.bell, .bell-unmute');
            if (bellElement) {
                bellElement.classList.toggle('bell', !hermesEnabled);
                bellElement.classList.toggle('bell-unmute', hermesEnabled);
            }

            // Apply animations setting
            const checkmark = animBtn.querySelector('.checkmark');
            if (checkmark) {
                checkmark.style.visibility = animationsEnabled ? 'visible' : 'hidden';
            }

            const catImg = document.querySelector('.hermes-cat');
            if (!animationsEnabled) {
                clearTimeout(blinkTimeout);
                clearTimeout(mouthTimeout);
                if (catImg) catImg.src = '../assets/hermes.png';
            } else {
                randomBlink?.();
            }

            if (!hermesEnabled) {
                hideSpeechBubble?.();
                stopTalking?.();
            }
        }

        // Apply settings immediately
        applySavedSettings();

        // Hermes toggle
        muteBtn.addEventListener('click', function () {
            hermesEnabled = !hermesEnabled;
            localStorage.setItem('hermesEnabled', hermesEnabled);

            const bellElement = this.querySelector('.bell, .bell-unmute');
            if (bellElement) {
                bellElement.classList.toggle('bell');
                bellElement.classList.toggle('bell-unmute');
            }
            if (!hermesEnabled) {
                hideSpeechBubble?.();
                stopTalking?.();
            }
        });

        // Animations toggle
        animBtn.addEventListener('click', function () {
            animationsEnabled = !animationsEnabled;
            localStorage.setItem('animationsEnabled', animationsEnabled);

            const checkmark = this.querySelector('.checkmark');
            checkmark.style.visibility = animationsEnabled ? 'visible' : 'hidden';
            const catImg = document.querySelector('.hermes-cat');
            if (!animationsEnabled) {
                clearTimeout(blinkTimeout);
                clearTimeout(mouthTimeout);
                if (catImg) catImg.src = '../assets/hermes.png';
            } else {
                randomBlink?.();
            }
        });
    });

    function handleRandomResponse(responses, nothingChance = 0.5, dotsChance = 0.08) {
        const randomChance = Math.random();
        const dotsThreshold = nothingChance + dotsChance;
        if (randomChance < nothingChance) {
            // Nothing happens
            hideSpeechBubble();
            stopTalking();
            return true;
        } else if (randomChance < dotsThreshold) {
            // Show dots
            showSpeechBubble("...");
            stopTalking();
            return true;
        } else {
            // Show random message from array
            showSpeechBubble(responses);
            return true;
        }
    }

    function getCatReactionForSubreddit(input, isSubreddit = false) {
        if (isSubreddit) {
            const reactions = {
                'amitheasshole': ["My cousin ended up on there once.", "I know you are, but what am I?"],
                'gonewild': ["My cousin ended up on there once."],
                'carsfuckingdragons': ["Touch grass.", "Oh.", "Uhh..."],
                'anime_irl': ["Touch grass.", "Uhh...", "Oh."],
                'grilling': ["You should look up uhh, uh, Bratwurst. On a Weber Ranch."],
                'bettercallsaul': ["He defecated through a sunroof!", "Showtime.", "I KNEW IT WAS 1216! ONE AFTER MAGNA CARTA", "I AM NOT CRAZY! I am not crazy! I know he swapped those numbers!"],
                'okbuddychicanery': ["He defecated through a sunroof!", "Showtime.", "I KNEW IT WAS 1216! ONE AFTER MAGNA CARTA", "I AM NOT CRAZY! I am not crazy! I know he swapped those numbers!", "Kid named Finger:"],
                'breakingbadmemes': ["Kid named Finger:"], 
                'stopsmoking': ["I went back to the old toothpick method myself.", "Apple a day to balance it out, amiright?"], 
                'okbuddyarkham': ["Man...", "Officer Boals. I knew him."],
                'batmanarkham': ["Man...", "Officer Boals. I knew him."],
                'thesopranos': ["How about that prick's face when he saw the gat?"],
                'thesopranos_memes': ["How about that prick's face when he saw the gat?"],
                'lego': ["My kids love those. My wallet..."],
                'memes': ["Some of these are definitely jokes."],
                'dankmemes': ["Some of these are definitely jokes."],
                'mystery': ["Lot more homework than you'd expect."],
                'legaladvice': ["Lot more homework than you'd expect."],
                'malelivingspace': ["Oh, yeah. This is my place."],
                'mancave': ["Oh, yeah. This is my place."],
                'showerthoughts': ["I do my thinking in the rain."],
                'bmw': ["Good taste."],
                'tifu': ["So, the song. CBAT..? My cousin told me to give it a listen. Something about interpretive dance."],
                'askreddit': ["Have you ever heard of the Swamps of Dagobah?"],
                'starwars': ["Have you ever heard of the Swamps of Dagobah?", "So anyway, I started blasting."],
                'alwayssunnymemes': ["So anyway, I started blasting."],
                'IASIP': ["So anyway, I started blasting."],
                'cars': ["You seen the new GTXi Turbo Plus?", "Exactly.", "You should look up the VIN before buying.", "They need to ditch the damn touchscreens."],
                'tesla': ["Tch."],
                'scams': ["Always do a reverse image search. My client fell for that one.", "Advance fee fraud. My client fell for that one."],
                'floridaman': ["I used to live in Tampa."],
                'florida': ["I used to live in Tampa."],
                'disneyworld': ["So overpriced these days.", "I used to live in Tampa.", "You're wondering how I feel about mice."],
                'disney': ["You're wondering how I feel about mice."],
                'helldivers': ["My cousin is into that one."],
                'helldivers2': ["My cousin is into that one."],
                'cod': ["My cousin is into that one."],
                'letterboxd': ["I feel like I'm supposed to like Blade Runner. You know, the run time just doesn't do it for me."],
                'cybertruck': ["Tch.", "*wheeze*"],
                'personalfinance': ["Know when to hold 'em... I bet you don't know that song.", "My cousin has a VTI. You should look into that."],
                'wallstreetbets': ["Know when to hold 'em... I bet you don't know that song.", "My cousin told me about GameStop? I thought they were outta business, honestly."],
                'fire': ["My cousin has a VTI. You should look into that.", "I'm basically retired. Hahaha and then I wake up."],
                'privacy': ["Travel burner phone.", "VPN."],
                'prequelmemes': ["Ehhhh..."],
                'coffee': ["For me, I don't like none of that fancy stuff.", "Now they say you have to aerate the beans like they breathe oxygen.", "Cold brews at these new places are always rancid."],
                'terminator': ["I'll be back..."],
                'saltierthancrait': ["Ehhhh...", "Okay.", "Tch.", "Sure.", "I mean..."],
                'foodporn': ["Have you heard of this Ube stuff. They keep coming out with new foods.", "Always marinade.", "This place makes me think going vegetarian could be survivable."],
                'food': ["Always marinade.", "This place makes me think going vegetarian could be survivable.", "Apparently spaghetti isn't really Italian.", "Have you heard of this Ube stuff. They keep coming out with new foods."],
                'maliciouscompliance': ["That's how you end up on my good list.", "All legal-like."],
                'pettyrevenge': ["That's how you end up on my good list.", "All legal-like."],
                'antiwork': ["That's how you end up on my good list.", "Join. A. Union.", "Document everything.", "Remember, they wouldn't hesitate."],
                'nygiants': ["Every damn year.", "My therapist is booked solid.", "Don't even start."],
            };

            // Check for specific subreddit first
            if (reactions[input.toLowerCase()]) {
                return reactions[input.toLowerCase()];
            }
        }
        const nsfwPattern = /\b(tits|titties|rape|raped|tiddies|massivecock|nudes|onlyfans|hentai|boobs|cum|cock|cocks|cunt|gape|gooning|gooner|goon|pussy|porn)\b/i;
        if (nsfwPattern.test(input)) {
            return ["Really?", "Okay.", "Bud...", "The usual suspects."];
        }
        return null;
    }





    // Event Listeners
    searchButton.addEventListener('click', async () => {
        // Pressing button too fast
        if (scrambleYeller()) return;
        pendingCatReaction = null;
        // Reset search button
        setTimeout(() => {
            searchButton.style.backgroundImage = "url('../assets/search-default.png')";
        }, 500);

        const subreddit = subredditInput.value.trim();
        searchButton.style.backgroundImage = "url('../assets/search-pressed.png')";
        currentPageIndex = 0;

        // Check blocklist 
        if (subreddit && bannedSubreddits.includes(subreddit.toLowerCase())) {
            // Reset if you're coming from bookmarks page
            resetBookmarksState();

            showError(`
                <div style="text-align: center;">
                    <img src="https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExOWtmaXgzdmdxdzU0dHJ0dXB5MXV2bWdpb2FqYXZndWc1eGNuZTAwMSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/Vuw9m5wXviFIQ/giphy.gif" 
                 alt="Rick Astley dancing" 
                 style="width: 300px; border-radius: 8px;">
                </div>
            `);
            // Reset search button
            setTimeout(() => {
                searchButton.style.backgroundImage = "url('../assets/search-default.png')";
            }, 500);
            return; 
        }

            // Clear the subreddit chip immediately when search is clicked
            currentFilters.subreddit = '';
            subredditChipContainer.style.display = 'none';

            if (currentFilters.sort === 'relevance' && (!searchInput.value || searchInput.value.trim() === '')) {
                // Reset if you're coming from bookmarks page
                resetBookmarksState();

                showError("No search terms detected. üîé");
                // Reset search button
                setTimeout(() => {
                    searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                }, 500);

                handleRandomResponse([
                    "I couldn't find that, kid.",
                    "Sorry, squirt.",
                    "I'm gonna need more than that.",
                    "That's not on my records.",
                    "Shucks.",
                    "Nada.",
                    "I got nothin'.",
                    "That's a dead end.",
                    "Not in my files.",
                    "Zilch.",
                    "Don't know where I'd find 'blankity blank blank.'",
                    "No can do."
                ]);
                return;
            }

            if (subreddit && subreddit !== 'undefined' && subreddit !== 'null') {
                // Reset if you're coming from bookmarks page
                resetBookmarksState();

                setTimeout(() => {
                    searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                }, 500);
                // Check for single character inputs
                if (subreddit.length === 1) {
                    // Reset if you're coming from bookmarks page
                    resetBookmarksState();

                    showError("Couldn't find a valid subreddit. üîé");
                    if (subreddit.toUpperCase() === 'F') {
                        handleRandomResponse(["You paying respects?", "Funny.",`That's it? Just "${subreddit}"?`, "I'm gonna need more than that.", "Brother..."]);
                    } else {
                        handleRandomResponse([
                            `That's it? Just "${subreddit}"?`,
                            "I'm gonna need more than that."
                        ]);
                    }
                    return;
                }

                const catReaction = getCatReactionForSubreddit(subreddit, true);
                if (catReaction) {
                    pendingCatReaction = catReaction;
                }

                // üåê Check if the subreddit exists using about.json
                try {
                    const res = await fetch(`http://localhost:3000/reddit?url=https://www.reddit.com/r/${subreddit}/about.json`);
                    if (!res.ok) {
                        // Reset if you're coming from bookmarks page
                        resetBookmarksState();
                                        
                        showError("Couldn't find a valid subreddit. üîé");
                        // Reset search button
                        setTimeout(() => {
                            searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                        }, 500);

                         handleRandomResponse([
                            "I couldn't find that, kid.",
                            "Is that a word?",
                            "Sorry, squirt.",
                            "That's not on my records.",
                            "Shucks.",
                            "Nada.",
                            "I got nothin'.",
                            "Not familiar with that.",
                            "That's a dead end.",
                            "Not in my files.",
                            "Never heard of that place.",
                            "Zilch.",
                            "No can do."
                        ]);
                        return;
                    }
                    
                    const json = await res.json();

                    if (!json || !json.data || json.data.subreddit_type === 'private') {
                        // Reset if you're coming from bookmarks page
                        resetBookmarksState();

                        showError("This subreddit is private.");
                        // Reset search button
                        setTimeout(() => {
                            searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                        }, 500);

                        handleRandomResponse([
                            "Sorry, squirt.",
                            "That's classified.",
                            "That's private.",
                            "No can do."
                        ]);
                        return;
                    }
                    
                } catch (err) {
                    // Reset if you're coming from bookmarks page
                    resetBookmarksState();

                    showError("Couldn't find a valid subreddit. üîé");
                    setTimeout(() => {
                        searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                    }, 500);

                    handleRandomResponse([
                        "I couldn't find that, kid.",
                        "Sorry, squirt.",
                        "That's not on my records.",
                        "Shucks.",
                        "Nada.",
                        "I got nothin'.",
                        "Not familiar with that.",
                        "That's a dead end.",
                        "Not in my files.",
                        "Never heard of that place.",
                        "Zilch.",
                        "No can do."
                    ]);
                    return;
                }
            }
            
        // Store the search suggestion
        const searchTerm = searchInput.value.trim();
        if (searchTerm) {
            try {
                fetch('http://localhost:3000/api/suggestions/store', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        query: searchTerm,
                        subreddit: (subreddit && subreddit !== 'undefined' && subreddit !== 'null') ? subreddit : null
                    })
                })
                    .catch(err => {
                        console.error("Failed to store suggestion in background:", err);
                    });
            } catch (err) {
                console.error("Error setting up suggestion storage:", err);
            }
        }

        performSearch();

        searchCount++;
        localStorage.setItem('searchCount', searchCount);
        // Premium reminders at specific search counts
        if (!isLoggedIn) {
            if (searchCount === 7) {
                setTimeout(() => {
                    showSpeechBubble("My client told me to inform you that the Bookmarks feature comes with Premium.");
                }, 500);
            } else if (searchCount === 37) {
                setTimeout(() => {
                    showSpeechBubble("My client told me to inform you that the Enhanced Search feature comes with Premium. 'Search Reddit Like Google', he says.");
                }, 500);
            } else if (searchCount === 77) {
                setTimeout(() => {
                    showSpeechBubble("My client told me to inform you that the Color Themes feature comes with Premium.");
                }, 500);
            }
        }

        setTimeout(() => {
            searchButton.style.backgroundImage = "url('../assets/search-default.png')";
        }, 500);

        if (pendingCatReaction) {
            const randomChance = Math.random();
            if (randomChance < 0.85) { // 85% chance for nothing
                hideSpeechBubble();
                stopTalking();
            } else if (randomChance < 0.925) { // 7.5% chance for "..."
                showSpeechBubble("...");
                stopTalking();
            } else { // 7.5% chance for the actual message
                showSpeechBubble(pendingCatReaction);
            }
        }
    });

    [subredditInput, searchInput].forEach(input => {
            input.addEventListener('keydown', async (e) => {
                if (e.key === 'Tab') {
                    let dropdown, suggestions, currentHighlighted;

                    // Check suggestions dropdown first
                    dropdown = document.querySelector('#suggestions');
                    if (dropdown && dropdown.style.display !== 'none') {
                        suggestions = dropdown.querySelectorAll('div');
                        currentHighlighted = dropdown.querySelector('.highlighted');
                    } else {
                        // Check subreddit dropdown
                        dropdown = document.querySelector('.subreddit-suggestions');
                        if (dropdown && dropdown.classList.contains('active')) {
                            suggestions = dropdown.querySelectorAll('.subreddit-suggestion');
                            currentHighlighted = dropdown.querySelector('.highlighted');
                        }
                    }

                    if (suggestions && suggestions.length > 0) {
                        if (currentHighlighted) {
                            const currentIndex = Array.from(suggestions).indexOf(currentHighlighted);
                            currentHighlighted.classList.remove('highlighted');

                            if (currentIndex < suggestions.length - 1) {
                                suggestions[currentIndex + 1].classList.add('highlighted');
                                e.preventDefault();
                            } else {
                                // After last suggestion, hide dropdown and allow tab to continue
                                    if (dropdown.id === 'suggestions') {
                                    dropdown.innerHTML = '';
                                    dropdown.style.display = 'none';
                                } else if (dropdown.classList.contains('subreddit-suggestions')) {
                                    dropdown.classList.remove('active');
                                }
                            }
                        } else {
                            // No current highlight ‚Äî highlight first suggestion
                            suggestions[0].classList.add('highlighted');
                            e.preventDefault();
                        }
                        
                    }
                }

                  // Up and Down Arrows Input  
                  if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                    let dropdown, suggestions, currentHighlighted;

                    // Check which dropdown is active (same logic as Tab)
                    dropdown = document.querySelector('#suggestions');
                    if (dropdown && dropdown.style.display !== 'none') {
                        suggestions = dropdown.querySelectorAll('div');
                        currentHighlighted = dropdown.querySelector('.highlighted');
                    } else {
                        dropdown = document.querySelector('.subreddit-suggestions');
                        if (dropdown && dropdown.classList.contains('active')) {
                            suggestions = dropdown.querySelectorAll('.subreddit-suggestion');
                            currentHighlighted = dropdown.querySelector('.highlighted');
                        }
                    }

                    if (suggestions && suggestions.length > 0) {
                        e.preventDefault();

                        // Remove current highlight
                        if (currentHighlighted) {
                            currentHighlighted.classList.remove('highlighted');
                        }

                        let nextIndex;
                        if (e.key === 'ArrowDown') {
                            // Move down
                            if (currentHighlighted) {
                                const currentIndex = Array.from(suggestions).indexOf(currentHighlighted);
                                nextIndex = (currentIndex + 1) % suggestions.length;
                            } else {
                                nextIndex = 0; // Start at first item
                            }
                        } else {
                            // Move up
                            if (currentHighlighted) {
                                const currentIndex = Array.from(suggestions).indexOf(currentHighlighted);
                                nextIndex = currentIndex <= 0 ? suggestions.length - 1 : currentIndex - 1;
                            } else {
                                nextIndex = suggestions.length - 1; // Start at last item
                            }
                        }

                        suggestions[nextIndex].classList.add('highlighted');
                    }
                }

                if (e.key === 'Enter') {
                    // Check both dropdowns
                    let highlighted = document.querySelector('#suggestions .highlighted') ||
                        document.querySelector('.subreddit-suggestions .highlighted');

                    if (highlighted) {
                        e.preventDefault();
                        highlighted.click();
                        highlighted.classList.remove('highlighted');
                        return;
                    }
                    // Pressing button too fast
                    if (scrambleYeller()) return;
                    pendingCatReaction = null;
                    // Reset search button
                    setTimeout(() => {
                        searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                    }, 500);

                    const subreddit = subredditInput.value.trim();
                    const searchTerm = searchInput.value.trim();

                    searchButton.style.backgroundImage = "url('../assets/search-pressed.png')";
                    currentPageIndex = 0;

                    // **BLOCKLIST CHECK**
                    if (subreddit && bannedSubreddits.includes(subreddit.toLowerCase())) {
                        // Reset if you're coming from bookmarks page
                        resetBookmarksState();

                        showError(`
                            <div style="text-align: center;">
                                <img src="https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExOWtmaXgzdmdxdzU0dHJ0dXB5MXV2bWdpb2FqYXZndWc1eGNuZTAwMSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/Vuw9m5wXviFIQ/giphy.gif" 
                            alt="Rick Astley dancing" 
                            style="width: 300px; border-radius: 8px;">
                            </div>
                        `);
                        // Reset search button
                        setTimeout(() => {
                            searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                        }, 500);
                        return;
                    }

                    // **RELEVANCE SEARCH TERM CHECK**
                    if (currentFilters.sort === 'relevance' && !searchTerm) {
                        // Reset if you're coming from bookmarks page
                        resetBookmarksState();

                        showError("No search terms detected. üîé");
                        setTimeout(() => {
                            searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                        }, 500);
                        handleRandomResponse([
                            "I couldn't find that, kid.",
                            "Sorry, squirt.",
                            "That's not on my records.",
                            "Shucks.",
                            "Nada.",
                            "I got nothin'.",
                            "That's a dead end.",
                            "Not in my files.",
                            "Zilch.",
                            "Don't know where I'd find 'blankity blank blank.'",
                            "No can do."
                        ]);
                        return;
                    }

                    // **SUBREDDIT VALIDATION**
                    if (subreddit && subreddit !== 'undefined' && subreddit !== 'null') {
                        // Check for single character inputs
                        if (subreddit.length === 1) {
                            // Reset if you're coming from bookmarks page
                            resetBookmarksState();

                            showError("Couldn't find a valid subreddit. üîé");
                            setTimeout(() => {
                                searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                            }, 500);
                            if (subreddit.toUpperCase() === 'F') {
                                handleRandomResponse(["You paying respects?", "Funny."]);
                            } else {
                                handleRandomResponse([
                                    `That's it? Just "${subreddit}"?`,
                                    "I'm gonna need more than that.",
                                    "Brother..."
                                ]);
                            }
                            return;
                        }

                        const catReaction = getCatReactionForSubreddit(subreddit, true);
                        console.log("Checking subreddit:", subreddit, "Got reaction:", catReaction);
                        if (catReaction) {
                            pendingCatReaction = catReaction;
                        }

                        try {
                            const res = await fetch(`http://localhost:3000/reddit?url=https://www.reddit.com/r/${subreddit}/about.json`);
                            if (!res.ok) {
                                // Reset if you're coming from bookmarks page
                                resetBookmarksState();

                                showError("Couldn't find a valid subreddit. üîé");
                                setTimeout(() => {
                                    searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                                }, 500);
                                handleRandomResponse([
                                    "I couldn't find that, kid.",
                                    "Is that a word?",
                                    "Sorry, squirt.",
                                    "That's not on my records.",
                                    "Shucks.",
                                    "Nada.",
                                    "I got nothin'.",
                                    "Not familiar with that.",
                                    "That's a dead end.",
                                    "Not in my files.",
                                    "Never heard of that place.",
                                    "Zilch.",
                                    "No can do."
                                ]);
                                return;
                            }

                            const json = await res.json();

                            if (!json || !json.data || json.data.subreddit_type === 'private') {
                                // Reset if you're coming from bookmarks page
                                resetBookmarksState();

                                showError("This subreddit is private.");
                                setTimeout(() => {
                                    searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                                }, 500);
                                handleRandomResponse([
                                    "Sorry, squirt.",
                                    "That's classified.",
                                    "That's private.",
                                    "No can do."
                                ]);
                                return;
                            }

                        } catch (err) {
                            // Reset if you're coming from bookmarks page
                            resetBookmarksState();

                            showError("Couldn't find a valid subreddit. üîé");
                            setTimeout(() => {
                                searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                            }, 500);
                            handleRandomResponse([
                                "I couldn't find that, kid.",
                                "Sorry, squirt.",
                                "That's not on my records.",
                                "Shucks.",
                                "Nada.",
                                "I got nothin'.",
                                "Not familiar with that.",
                                "That's a dead end.",
                                "Not in my files.",
                                "Never heard of that place.",
                                "Zilch.",
                                "No can do."
                            ]);
                            return;
                        }
                    }

                    // **STORE SEARCH SUGGESTION**
                    if (searchTerm) {
                        try {
                            await fetch('http://localhost:3000/api/suggestions/store', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    query: searchTerm,
                                    subreddit: (subreddit && subreddit !== 'undefined' && subreddit !== 'null') ? subreddit : null
                                })
                            });
                        } catch (err) {
                            console.error("Failed to store suggestion:", err);
                        }
                    }

                    // **PERFORM SEARCH**
                    performSearch();

                    searchCount++;
                    localStorage.setItem('searchCount', searchCount);
                    // Premium reminders at specific search counts
                    if (!isLoggedIn) {
                        if (searchCount === 7) {
                            setTimeout(() => {
                                showSpeechBubble("My client told me to inform you that the Bookmarks feature comes with Premium.");
                            }, 500);
                        } else if (searchCount === 37) {
                            setTimeout(() => {
                                showSpeechBubble("My client told me to inform you that the Enhanced Search feature comes with Premium. 'Search Reddit Like Google', he says.");
                            }, 500);
                        } else if (searchCount === 77) {
                            setTimeout(() => {
                                showSpeechBubble("My client told me to inform you that the Color Themes feature comes with Premium.");
                            }, 500);
                        }
                    }

                    setTimeout(() => {
                        searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                    }, 500);

                    // **CAT REACTION LOGIC**
                    if (pendingCatReaction) {
                        const randomChance = Math.random();
                        if (randomChance < 0.85) { // 85% chance for nothing
                            hideSpeechBubble();
                            stopTalking();
                        } else if (randomChance < 0.95) { // 10% chance for "..."
                            showSpeechBubble("...");
                            stopTalking();
                        } else { // 5% chance for the actual message
                            showSpeechBubble(pendingCatReaction);
                        }
                    }
                }

                // Reset highlight when typing
                if (e.key.length === 1 || e.key === 'Backspace') {
                    highlightedIndex = -1;
                    const dropdown = document.querySelector('.suggestions-dropdown');
                    if (dropdown) {
                        const suggestions = dropdown.querySelectorAll('.suggestion-item');
                        suggestions.forEach(item => item.classList.remove('highlighted'));
                    }
                }
            });

        // Click listener for subreddit input
        if (input === subredditInput) {
            input.addEventListener('click', (e) => {
                if (e.target.value.trim()) {
                    handleSubredditSuggestions(e.target.value.trim());
                    // Also make sure the dropdown shows
                    const dropdown = document.querySelector('.subreddit-suggestions');
                    if (dropdown) {
                        dropdown.classList.add('active');
                    }
                }
            });
        }

        // Remove chip if user typed a sub
        if (input === subredditInput) {
            input.addEventListener('input', (e) => {
                if (e.target.value.trim()) {
                    currentFilters.subreddit = '';
                    subredditChipContainer.style.display = 'none';
                }
            });
        }
    });

    document.querySelector('#subreddit-input').addEventListener('focus', (e) => {
        if (!e.target.value.trim()) {
            const popularSubs = [
                { name: 'AskReddit', icon: null },
                { name: 'pics', icon: null },
                { name: 'mildlyinteresting', icon: null },
                { name: 'explainlikeimfive', icon: null },
                { name: 'politics', icon: null }
            ];

            // Load recent subs
            const recent = JSON.parse(localStorage.getItem('recentSubs')) || [];
            const recentSubs = recent.map(name => ({ name, icon: null, isRecent: true }));

            // Combine with section headers
            const combinedSubs = [
                ...popularSubs,
                ...(recentSubs.length > 0 ? [{ name: 'Recently Searched', isHeader: true }] : []),
                ...recentSubs
            ];

            populateSubredditSuggestions(combinedSubs);
            document.querySelector('.subreddit-suggestions').classList.add('active');
        }
    });
    
    // Save short subreddit search history
    function saveRecentSubreddit(subreddit) {
        let recent = JSON.parse(localStorage.getItem('recentSubs')) || [];
        // Remove if already exists
        recent = recent.filter(s => s !== subreddit);
        // Add to start
        recent.unshift(subreddit);
        // Keep only last 2
        recent = recent.slice(0, 2);
        localStorage.setItem('recentSubs', JSON.stringify(recent));
    }

    const toggleEnhanced = document.getElementById('toggle1');
    const toggleReddit = document.getElementById('toggle2');
    const sortContainer = document.getElementById('sort-select').parentElement;

    document.getElementById('toggle1').addEventListener('change', function () {
        console.log('Enhanced Search:', this.checked);

        // Check if user is trying to enable enhanced search while logged out
        if (!isLoggedIn) {
            // Prevent the toggle from changing
            event.preventDefault();
            this.checked = false;
            // Open features page in new tab
            window.open('features.html', '_blank');
            return;
        }
            
        if (this.checked) {
            document.getElementById('toggle2').checked = false;
        } else {
            document.getElementById('toggle2').checked = true;
        }

        // Save states
        localStorage.setItem('enhancedSearch', this.checked);
        localStorage.setItem('redditSearch', document.getElementById('toggle2').checked);

        updateSortDropdown();
    });

    document.getElementById('toggle2').addEventListener('change', function () {
        console.log('Reddit Search:', this.checked);

        if (!isLoggedIn) {
            // Prevent the toggle from changing
            event.preventDefault();
            this.checked = true;
            // Open features page in new tab
            window.open('features.html', '_blank');
            return;
        }
            
        if (this.checked) {
            document.getElementById('toggle1').checked = false;
        } else {
            document.getElementById('toggle1').checked = true;
        }

        // Save states
        localStorage.setItem('redditSearch', this.checked);
        localStorage.setItem('enhancedSearch', document.getElementById('toggle1').checked);

        updateSortDropdown();
    });

    function updateSortDropdown() {
        if (toggleEnhanced.checked) {
            showUltimateSort();
        } else {
            restoreNormalSort();
        }
    }

    function showUltimateSort() {
        let oldSelect = document.getElementById('sort-select');
        let newSelect = document.createElement('select');
        newSelect.id = 'sort-select';
        newSelect.disabled = true;
        newSelect.innerHTML = '<option value="ultimate">ULTIMATE ‚ú®</option>';
        sortContainer.replaceChild(newSelect, oldSelect);
        currentFilters.sort = 'ultimate';
    }

    function restoreNormalSort() {
        let oldSelect = document.getElementById('sort-select');
        let newSelect = document.createElement('select');
        newSelect.id = 'sort-select';
        newSelect.innerHTML = `
        <option value="hot">Hot</option>
        <option value="top">Top</option>
        <option value="new">New</option>
        <option value="relevance">Relevance</option>
    `;
        sortContainer.replaceChild(newSelect, oldSelect);

        newSelect.addEventListener('change', () => {
            currentFilters.sort = newSelect.value;

            if (newSelect.value !== 'relevance') {
                currentIndex = 0;
                performSearch();
            }
        });
        currentFilters.sort = 'hot';
    }

    // ‚úÖ Initialize correct state on page load
    if (toggleEnhanced.checked) {
        showUltimateSort();
    } else {
        restoreNormalSort();
    }

    sortSelect.addEventListener('change', () => {
        currentFilters.sort = sortSelect.value;

        // Only perform search if NOT relevance
        if (sortSelect.value !== 'relevance') {

            // Reset pagination state
            currentIndex = 0;
            performSearch();
        
        }
    });

    timeSelect.addEventListener('change', () => {
        currentFilters.time = timeSelect.value;

            // Reset pagination state
            currentIndex = 0;
        performSearch();
    });

    document.getElementById('safesearch-select').addEventListener('change', function () {
        const enabled = this.value === 'on';
        document.body.classList.toggle('safe-search-enabled', enabled);
        console.log(`SafeSearch is now ${enabled ? 'ON' : 'OFF'}`);
    });

    contentSelect.addEventListener('change', () => {
        currentFilters.contentType = contentSelect.value;
        // Reset pagination state
        currentIndex = 0;
        performSearch();
    });

        const comfyToggle = document.getElementById('comfy-toggle');
        const compactToggle = document.getElementById('compact-toggle');

        // Use sessionStorage - resets when tab closes, persists on refresh
        let isComfyActive = sessionStorage.getItem('isComfyActive') === 'true' || false;
        let isCompactActive = sessionStorage.getItem('isCompactActive') === 'true' || false;
        let hasClickedOnce = sessionStorage.getItem('hasClickedOnce') === 'true' || false;

        // Apply saved states on page load
        function applyButtonStates() {
            if (isComfyActive) {
                comfyToggle.querySelector('img').src = '../assets/comfy-pressed.png';
                document.body.classList.add('comfy-mode');
            } else {
                comfyToggle.querySelector('img').src = '../assets/comfy-default.png';
                document.body.classList.remove('comfy-mode');
            }

            if (isCompactActive) {
                compactToggle.querySelector('img').src = '../assets/compact-pressed.png';
            } else {
                compactToggle.querySelector('img').src = '../assets/compact-default.png';
            }

            if (hasClickedOnce) {
                document.body.classList.add('hasClickedOnce');
            }
        }

        applyButtonStates();

        // Save states to sessionStorage
        function saveStates() {
            sessionStorage.setItem('isComfyActive', isComfyActive);
            sessionStorage.setItem('isCompactActive', isCompactActive);
            sessionStorage.setItem('hasClickedOnce', hasClickedOnce);
        }

        comfyToggle.addEventListener('click', () => {
            if (isComfyActive) {
                if (hasClickedOnce && !isCompactActive) return;
                isComfyActive = false;
                comfyToggle.querySelector('img').src = '../assets/comfy-default.png';
            } else {
                isComfyActive = true;
                comfyToggle.querySelector('img').src = '../assets/comfy-pressed.png';
                isCompactActive = false;
                compactToggle.querySelector('img').src = '../assets/compact-default.png';
            }
            hasClickedOnce = true;
            document.body.classList.add('hasClickedOnce');

            if (isComfyActive) {
                document.body.classList.add('comfy-mode');
            } else {
                document.body.classList.remove('comfy-mode');
            }

            refreshInfiniteScrollLayout();

            saveStates();
        });

        compactToggle.addEventListener('click', () => {
            hasClickedOnce = true;
            document.body.classList.add('hasClickedOnce');
            compactToggle.querySelector('img').src = '../assets/compact-pressed.png';
            document.body.classList.remove('comfy-mode');
            isComfyActive = false;
            isCompactActive = true;
            comfyToggle.querySelector('img').src = '../assets/comfy-default.png';

            refreshInfiniteScrollLayout();

            saveStates();
        });

        function refreshInfiniteScrollLayout() {
            // Trigger window resize event to refresh any scroll calculations
            window.dispatchEvent(new Event('resize'));

            // Wait for CSS layout to finish, then recalculate scroll indicator
            setTimeout(() => {
                positionScrollIndicator();
            }, 250); // Small delay to let CSS changes take effect
        }

        const toggle1 = document.getElementById('toggle1');
        const toggle2 = document.getElementById('toggle2');

        // Load saved states from sessionStorage (toggle1 defaults to checked)
        let toggle1State = sessionStorage.getItem('toggle1State') !== null ?
            sessionStorage.getItem('toggle1State') === 'true' : false; // default
        let toggle2State = sessionStorage.getItem('toggle2State') !== null ?
            sessionStorage.getItem('toggle2State') === 'true' : true; // default 

        // Apply saved states on page load
        function applyToggleStates() {
            toggle1.checked = toggle1State;
            toggle2.checked = toggle2State;
        }

        applyToggleStates();
        updateSortDropdown();

        // Save states to sessionStorage
        function saveToggleStates() {
            sessionStorage.setItem('toggle1State', toggle1State);
            sessionStorage.setItem('toggle2State', toggle2State);
        }

        // Toggle 1 click handler
        toggle1.addEventListener('change', () => {
            if (toggle1.checked) {
                // Toggle1 turned ON, turn toggle2 OFF
                toggle1State = true;
                toggle2State = false;
                toggle2.checked = false;
            } else {
                // Toggle1 turned OFF, turn toggle2 ON
                toggle1State = false;
                toggle2State = true;
                toggle2.checked = true;
            }
            saveToggleStates();
        });

        // Toggle 2 click handler
        toggle2.addEventListener('change', () => {
            if (toggle2.checked) {
                // Toggle2 turned ON, turn toggle1 OFF
                toggle2State = true;
                toggle1State = false;
                toggle1.checked = false;
            } else {
                // Toggle2 turned OFF, turn toggle1 ON
                toggle2State = false;
                toggle1State = true;
                toggle1.checked = true;
            }
            saveToggleStates();
        });
        
    document.addEventListener('click', function (event) {
            const suggestionsDiv = document.getElementById('suggestions');
            const input = document.getElementById('search-input');

            // If the click target is NOT the input or a suggestion
            if (!suggestionsDiv.contains(event.target) && event.target !== input) {
                suggestionsDiv.innerHTML = '';
                suggestionsDiv.style.display = 'none';
            }
        });

    document.querySelector('#search-input').addEventListener('focus', function () {
        if (this.value === '') {

            fetch('http://localhost:3000/api/top-searches')
                .then(res => res.json())
                .then(data => {
                    const suggestionsDiv = document.querySelector('#suggestions');
                    displaySuggestions(data, suggestionsDiv);
                });
        }
    });

    document.querySelector('.search-input-container').addEventListener('click', function (e) {
            // Only focus if they didn't click the input itself, search button, or filter icon
            if (!e.target.matches('.search-input') &&
                !e.target.matches('.search-button') &&
                !e.target.matches('#filter-icon') &&
                !e.target.closest('.search-button')) {
                document.querySelector('#search-input').focus();
            }
        });

    // Grow comment images
    document.addEventListener('click', function (e) {
            if (e.target.matches('.comment-body img')) {
                let currentWidth = e.target.offsetWidth;
                e.target.style.transition = 'width 0.07s ease';

                if (e.target.style.width) {
                    e.target.style.width = '';
                } else {
                    e.target.style.width = (currentWidth * 1.7) + 'px';
                }
            }
        });

    // Remove subreddit filter when clicking X
    subredditChipContainer.querySelector('.remove-chip').addEventListener('click', () => {
        currentFilters.subreddit = '';
        subredditChipContainer.style.display = 'none';
    });

    // Handle suggestion selection
    subredditSuggestions.addEventListener('click', (e) => {
        // Don't select if delete button was clicked
        if (e.target.classList.contains('delete-recent-btn')) {
            return;
        }

        const suggestion = e.target.closest('.subreddit-suggestion');
        if (suggestion) {
            const subName = suggestion.getAttribute('data-name');
            selectSubreddit(subName);
        }
    });     

    // Handle typing in subreddit input
    subredditInput.addEventListener('input', () => {
        const query = subredditInput.value.toLowerCase().trim();
        lastQuery = query;

        // Show dropdown immediately with a loading spinner
        if (query.length > 0) {
            if (!subredditSuggestions.querySelector('.custom-spinner-wrapper')) {
                subredditSuggestions.innerHTML = '';
                subredditSuggestions.appendChild(createCanvasSpinner());
            }

            subredditSuggestions.classList.add('active');
        } else {
            subredditSuggestions.classList.remove('active');
        }

        // Debounce Reddit API call
        if (searchTimeout) clearTimeout(searchTimeout);

        searchTimeout = setTimeout(() => {
            handleSubredditSuggestions(query);
        }, 200); // delay debounce here
    });

    document.addEventListener('click', function (e) {
        if (e.target.closest('.plan-display-container')) {
            const userEmail = localStorage.getItem('userEmail');
            if (userEmail) {
                // Show spinner immediately
                const planDisplayElement = document.getElementById('plan-display');
                const originalContent = planDisplayElement.innerHTML;
                const spinnerWrapper = createCanvasSpinner();
                spinnerWrapper.style.transform = 'scale(0.6)';
                planDisplayElement.innerHTML = '';
                planDisplayElement.appendChild(spinnerWrapper);

                fetch('http://localhost:3000/api/create-checkout', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email: userEmail })
                })
                    .then(response => response.json())
                    .then(data => {
                        if (data.url) {
                            window.location.href = data.url;
                        } else {
                            // Restore original content if no URL
                            planDisplayElement.innerHTML = originalContent;
                            planDisplayElement.classList.remove('loading');
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('Could not open billing portal');
                        // Restore original content on error
                        planDisplayElement.innerHTML = originalContent;
                        planDisplayElement.classList.remove('loading');
                    });
            }
        }
    });

    // Cubic-bezier easing 
    function cubicBezier(p0, p1, p2, p3) {
        return function (t) {
            const cx = 3 * (p1 - p0);
            const bx = 3 * (p2 - p1) - cx;
            const ax = 1 - cx - bx;

            const cy = 3 * (p1 - p0);
            const by = 3 * (p2 - p1) - cy;
            const ay = 1 - cy - by;

            let x = t, t2 = t;
            for (let i = 0; i < 5; i++) {
                const f = ax * t2 * t2 * t2 + bx * t2 * t2 + cx * t2 - x;
                const df = 3 * ax * t2 * t2 + 2 * bx * t2 + cx;
                t2 = t2 - f / df;
                t2 = Math.max(0, Math.min(t2, 1));
            }

            return ay * t2 * t2 * t2 + by * t2 * t2 + cy * t2;
        };
    }

    function getThemeColor() {
        const body = document.body;
        if (body.classList.contains('forest-theme')) {
            return 'rgb(65, 127, 111)'; // Green
        } else if (body.classList.contains('bluebird-theme')) {
            return "rgb(135, 197, 255)"; // Blue
        } else if (body.classList.contains('dark-theme')) {
            return '#ffffff'; // White
        }
        return '#C1C0C1'; // Gray
    }

    // Begin animation
    function startSpinnerAnimation(ctx, color = "#C1C0C1") {
        const easeCustom = cubicBezier(0.1, 0.83, 0.37, 1);
        const cycleDuration = 700;
        let startTime = null;

        function animate(timestamp) {
            if (!startTime) startTime = timestamp;

            const elapsed = timestamp - startTime;
            const t = (elapsed % cycleDuration) / cycleDuration;
            const ramp = Math.pow(t, 0.8);
            const eased = easeCustom(ramp);

            const angle = (eased * 6.28 + 7.8) % 6.28;
            const shrinkEase = easeCustom(t);
            const sinePhase = Math.sin(shrinkEase * Math.PI);
            const shrinkPhase = easeCustom(sinePhase);
            const shrink = 0.5 + 0.5 * shrinkPhase;
            const arcLength = Math.PI * 0.7 * shrink;

            ctx.clearRect(0, 0, 50, 50);
            ctx.beginPath();
            const arcStart = angle - arcLength;
            ctx.arc(25, 25, 18, arcStart, angle);
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.stroke();

            requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);
    }

    // SPINNY
    function createCanvasSpinner() {
        const wrapper = document.createElement('div');
        wrapper.className = 'custom-spinner-wrapper';

        const canvas = document.createElement('canvas');
        canvas.width = 50;
        canvas.height = 50;
        canvas.id = 'main-spinner-placeholder';
        wrapper.appendChild(canvas);

        const ctx = canvas.getContext('2d');
        const color = getThemeColor();
        startSpinnerAnimation(ctx, color); 

        return wrapper;
    }

    function createWhiteCanvasSpinner() {
            const wrapper = document.createElement('div');
            wrapper.className = 'custom-spinner-wrapper';
            const canvas = document.createElement('canvas');
            canvas.width = 50;
            canvas.height = 50;
            canvas.id = 'main-spinner-placeholder';
            wrapper.appendChild(canvas);
            const ctx = canvas.getContext('2d');

            // Modified animation function with white color
            const easeCustom = cubicBezier(0.1, 0.83, 0.37, 1);
            const cycleDuration = 700;
            let startTime = null;
            function animate(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;
                const t = (elapsed % cycleDuration) / cycleDuration;
                const ramp = Math.pow(t, 0.8);
                const eased = easeCustom(ramp);
                const angle = (eased * 6.28 + 7.8) % 6.28;
                const shrinkEase = easeCustom(t);
                const sinePhase = Math.sin(shrinkEase * Math.PI);
                const shrinkPhase = easeCustom(sinePhase);
                const shrink = 0.5 + 0.5 * shrinkPhase;
                const arcLength = Math.PI * 0.7 * shrink;
                ctx.clearRect(0, 0, 50, 50);
                ctx.beginPath();
                const arcStart = angle - arcLength;
                ctx.arc(25, 25, 18, arcStart, angle);
                ctx.strokeStyle = "#ffffff"; // White color
                ctx.lineWidth = 4;
                ctx.stroke();
                requestAnimationFrame(animate);
            }
            requestAnimationFrame(animate);
            return wrapper;
        }

    document.getElementById('content-select').addEventListener('change', function () {
            currentFilters.contentType = this.value;
            updateURL();
        });

    async function handleSubredditSuggestions(query) {
        // Don't search for empty queries
        if (!query || query.trim() === '') {
            subredditSuggestions.innerHTML = '';
            return;
        }
            // Strip r/ prefix if present
            const cleanQuery = query.replace(/^r\//, '');
            
            const queryToken = ++activeQueryToken;
            console.log(`üîé Fetching subreddit suggestions for: "${cleanQuery}"`);
            let matches = [];
            try {
                const res = await fetch(`http://localhost:3000/reddit?url=https://www.reddit.com/subreddits/search.json?q=${encodeURIComponent(query)}`);
                const data = await res.json();
                if (data?.data?.children) {
                    const filtered = [];
                    for (const child of data.data.children) {
                        if (
                            child?.data?.display_name &&
                            child.data.display_name.toLowerCase().startsWith(cleanQuery.toLowerCase())
                        ) {
                            filtered.push(child.data.display_name);
                            if (filtered.length === 6) break; // ‚úÖ TRUE early exit
                        }
                    }

                    // Show dropdown immediately without icons
                    matches = filtered.map(name => ({ name, icon: null }));
                }

                    if (queryToken !== activeQueryToken) {
                        return;
                    }

                    populateSubredditSuggestions(matches);

            } catch (err) {
                console.error("‚ùå Subreddit suggestion fetch failed:", err);
            }
        }

    function populateSubredditSuggestions(subreddits) {

            // Sort subreddits by relevance to the search query
            const query = subredditInput.value.toLowerCase().trim();
            if (query.length > 0) {
                // Filter out header items before sorting
                const actualSubs = subreddits.filter(sub => !sub.isHeader);
                actualSubs.sort((a, b) => {
                    const aName = a.name.toLowerCase();
                    const bName = b.name.toLowerCase();

                    // Exact matches first
                    if (aName === query && bName !== query) return -1;
                    if (bName === query && aName !== query) return 1;

                    // Then starts with matches
                    if (aName.startsWith(query) && !bName.startsWith(query)) return -1;
                    if (bName.startsWith(query) && !aName.startsWith(query)) return 1;

                    // Then contains matches (already handled by filtering)
                    // Finally alphabetical
                    return aName.localeCompare(bName);
                });
                subreddits = actualSubs; // Use sorted subs without headers when searching

                // Add recent subreddits that match the query
                const recent = JSON.parse(localStorage.getItem('recentSubs')) || [];
                const matchingRecent = recent.filter(name =>
                    name.toLowerCase().startsWith(query)
                );

                if (matchingRecent.length > 0) {
                    subreddits = [
                        ...subreddits,
                        { name: 'Recently Searched', isHeader: true },
                        ...matchingRecent.map(name => ({ name, icon: null, isRecent: true }))
                    ];
                }
            }

            // If there are results from filtering, add them
            if (subreddits.length > 0) {

                // Wait for all icon fetches to complete
                Promise.all(subreddits.map(sub => Promise.resolve(sub))).then(() => {
                    subredditSuggestions.innerHTML = '';
                    subreddits.forEach(sub => {

                        // Handle header items
                        if (sub.isHeader) {
                            const header = document.createElement('div');
                            header.className = 'subreddit-section-header';
                            header.textContent = sub.name;
                            subredditSuggestions.appendChild(header);
                            return;
                        }

                        // Skip if no name
                        if (!sub.name) {
                            console.warn('Skipping subreddit with undefined name:', sub);
                            return;
                        }

                        const suggestion = document.createElement('div');
                        suggestion.className = 'subreddit-suggestion';
                        suggestion.setAttribute('data-name', sub.name);
                        const iconEl = document.createElement('div');
                        iconEl.className = 'subreddit-icon';

                        if (sub.icon && sub.icon.startsWith('http')) {
                            const img = document.createElement('img');
                            img.alt = sub.name;
                            img.src = sub.icon;
                            img.onerror = () => {
                                console.warn(`üîª Broken image for: ${sub.name}, using fallback`);
                                img.remove();
                                const fallback = document.createElement('span');
                                fallback.textContent = sub.name.charAt(0).toUpperCase();
                                iconEl.appendChild(fallback);
                            };
                            iconEl.appendChild(img);
                            // Force a repaint
                            iconEl.offsetHeight;
                        } else {
                            // Fallback if icon is missing or invalid
                            iconEl.textContent = sub.name.charAt(0).toUpperCase();
                        }

                        suggestion.appendChild(iconEl);
                        suggestion.appendChild(document.createTextNode(sub.name));
                        // Add delete button for recent items
                        if (sub.isRecent) {
                            const deleteBtn = document.createElement('span');
                            deleteBtn.className = 'delete-recent-btn';
                            deleteBtn.textContent = '√ó';
                            deleteBtn.onclick = (e) => {
                                e.stopPropagation();
                                e.preventDefault();
                                // Remove from localStorage
                                let recent = JSON.parse(localStorage.getItem('recentSubs')) || [];
                                recent = recent.filter(name => name !== sub.name);
                                localStorage.setItem('recentSubs', JSON.stringify(recent));
                                // Refresh dropdown
                                handleSubredditSuggestions(subredditInput.value);
                            };
                            suggestion.appendChild(deleteBtn);
                        }

                        subredditSuggestions.appendChild(suggestion);

                        if (sub.name) {
                            console.log('Fetching icon for:', sub.name, typeof sub.name);
                            // Fetch icon async and replace when it loads
                            getSubredditIcon(sub.name).then(iconUrl => {
                                if (iconUrl && iconUrl.startsWith('http')) {
                                    const img = document.createElement('img');
                                    img.alt = sub.name;
                                    img.src = iconUrl;
                                    img.onload = () => {
                                        iconEl.textContent = ''; // Clear the letter
                                        iconEl.appendChild(img);
                                        iconEl.classList.add('icon-loaded');
                                    };
                                    img.onerror = () => {
                                        console.warn(`üîª Broken image for: ${sub.name}, keeping fallback`);
                                        // Keep the letter fallback
                                    };
                                }
                            }).catch(err => {
                                console.error("‚ùå Error fetching icon:", err);
                                // Keep the letter fallback if fetch fails
                            });
                        }
                    });
                    subredditSuggestions.setAttribute('data-has-results', 'true');
                })
                    .catch(err => {
                        console.error("‚ùå Error rendering suggestions:", err);
                        subredditSuggestions.innerHTML = '<div class="subreddit-suggestion-err">Error loading suggestions</div>';
                    });
            }
        }


    function getCurrentFiltersFromUI() {
        const query = searchInput.value.trim();
        const subredditTyped = document.getElementById('subreddit-input').value.trim();
        const chipVisible = subredditChipContainer.style.display === 'flex';
        const subreddit = chipVisible
            ? subredditChipContainer.querySelector('.chip-text').textContent.replace('r/', '')
            : subredditTyped;
        return {
            query,
            time: document.getElementById('time-select').value,
            sort: document.getElementById('sort-select').value,
            contentType: document.getElementById('content-select').value,  
            subreddit
        };
    }

    function setupSearchSuggestions(inputId, suggestionsId, dictionary) {
            let timeout;

            const input = document.getElementById(inputId);
            const suggestionsDiv = document.getElementById(suggestionsId);

            input.addEventListener('input', function (e) {
                const query = e.target.value;
                clearTimeout(timeout);

            input.addEventListener('click', function (e) {
                const query = e.target.value.trim();
                if (query) {
                    getSmartSuggestions(query, suggestionsDiv, dictionary);
                }
            });

                timeout = setTimeout(() => {
                    getSmartSuggestions(query, suggestionsDiv, dictionary);
                }, 200);
            });
        }

    async function getSmartSuggestions(query, suggestionsDiv, dictionary) {
            let trimmedQuery = query.trim();

            // If empty, show top searches instead
            if (!trimmedQuery) {
                const response = await fetch('http://localhost:3000/api/top-searches');
                const data = await response.json();
                displaySuggestions(data, suggestionsDiv);
                return;
            }

            // Always spell check
            const correctedQuery = correctLastWord(trimmedQuery, dictionary);
            if (correctedQuery !== trimmedQuery) {
                console.log(`üî§ Spell corrected: "${trimmedQuery}" ‚Üí "${correctedQuery}"`);
                trimmedQuery = correctedQuery;
            }

            // Recalculate words after potential correction
            const words = trimmedQuery.split(' ');
            const lastWord = words[words.length - 1];
            const fuse = new Fuse(dictionary, { threshold: 0.4 });

            // Get stored suggestions from database first
            let storedSuggestions = [];
            try {
                const subreddit = subredditInput.value?.trim() || '';
                const url = `http://localhost:3000/api/suggestions?q=${encodeURIComponent(query)}`;
                const response = await fetch(url);
                const data = await response.json();
                storedSuggestions = data.map(item => ({
                    query: item.query,
                    subreddit: item.subreddit, 
                    isStored: true
                }));
            } catch (error) {
                console.error("‚ùå Stored suggestions error:", error);
            }

            // Calculate remaining slots for pattern suggestions
            const remainingSlots = Math.max(0, 6 - storedSuggestions.length);
            let patternSuggestions = [];

            if (remainingSlots > 0) {
                const hasTrailingSpace = query.endsWith(' ');
                const isElonMode = (words.length === 1 && dictionary.includes(trimmedQuery.toLowerCase())) ||
                    (hasTrailingSpace && words.length === 1);
                if (isElonMode) {
                    // Search for next term after first word mode ('elon musk')
                    console.log("ü§° ELON MODE");
                    try {
                        const apiUrl = `https://api.datamuse.com/words?rel_trg=${encodeURIComponent(trimmedQuery)}&max=${remainingSlots}`;
                        const response = await fetch(apiUrl);
                        const data = await response.json();
                        const apiWords = data.map(item => `${trimmedQuery} ${item.word}`);

                        // If no API results, show the original query as fallback
                        if (apiWords.length === 0) {
                            patternSuggestions = [trimmedQuery];
                        } else {
                            patternSuggestions = [trimmedQuery, ...apiWords].slice(0, remainingSlots);
                        }
                    } catch (error) {
                        console.error("‚ùå Datamuse error:", error);
                        patternSuggestions = [trimmedQuery];
                    }
                } else {
                    // Complete the word mid-phrase mode ('grilled chick -> grilled chicken')
                    console.log("üêî CHICKEN MODE");
                    const results = fuse.search(lastWord).slice(0, remainingSlots - 1);
                    const fullSuggestions = results.map(result => {
                        const newWords = [...words];
                        newWords[newWords.length - 1] = result.item;
                        return newWords.join(' ');
                    });

                    // If no fuzzy results, show the original query as fallback
                    if (fullSuggestions.length === 0) {
                        patternSuggestions = [trimmedQuery];
                    } else {
                        patternSuggestions = [trimmedQuery, ...fullSuggestions].slice(0, remainingSlots);
                    }
                }
            }

            // Only filter out the original query if there are other suggestions
            if (patternSuggestions.length > 1) {
                patternSuggestions = patternSuggestions.filter(suggestion =>
                    suggestion.toLowerCase() !== trimmedQuery.toLowerCase()
                );
            }

            // Remove duplicates, keep stored suggestions first
            const seen = new Set();
            const deduplicated = [];

            storedSuggestions.forEach(suggestion => {
                const key = suggestion.query.toLowerCase().trim();
                if (!seen.has(key)) {
                    seen.add(key);
                    deduplicated.push(suggestion);
                }
            });

            patternSuggestions.forEach(suggestion => {
                const key = suggestion.toLowerCase().trim();
                if (!seen.has(key)) {
                    seen.add(key);
                    deduplicated.push(suggestion);
                }
            });

            displaySuggestions(deduplicated, suggestionsDiv);
        }

    function isIncompleteWord(word, dictionary) {
            return !dictionary.includes(word.toLowerCase());
        }

    function correctLastWord(query, dictionary) {
            const words = query.trim().split(' ');
            const lastWord = words[words.length - 1];

            // ‚úÖ If the word is already in the dictionary, leave it alone
            if (dictionary.includes(lastWord.toLowerCase())) {
                return query;
            }

            const fuse = new Fuse(dictionary, {
                threshold: 0.4,
                includeScore: true,
            });

            let results = fuse.search(lastWord);

            if (results.length === 0) {
                return query; // no suggestions
            }

            // ‚úÖ Penalize suggestions that are too long or short
            results = results.map(result => {
                const lenDiff = Math.abs(result.item.length - lastWord.length);
                const penalty = lenDiff * 0.01; // mild penalty
                return {
                    ...result,
                    adjustedScore: result.score + penalty,
                };
            });

            results.sort((a, b) => a.adjustedScore - b.adjustedScore);

            const best = results[0];
            const second = results[1];


            // ‚úÖ Only correct if the match is pretty confident
            if (best.adjustedScore < 0.3) {
                words[words.length - 1] = best.item;
                return words.join(' ');
            }

            return query;
        }


    function displaySuggestions(suggestions, suggestionsDiv) {
        const nsfwPattern = /\b(tits|titties|rape|raped|breeder|tiddies|nudes|onlyfans|hentai|gonewild|boobs|cum|cock|cocksucker|cocks|cunt|gape|gooning|gooner|goon|pussy|porn)\b/i;

        // Filter out NSFW suggestions
        const filteredSuggestions = suggestions.filter(suggestion => {
            const query = typeof suggestion === 'string' ? suggestion : suggestion.query;
            return !nsfwPattern.test(query);
        });

            const suggestionsHtml = filteredSuggestions.map(suggestion => {
                const word = typeof suggestion === 'string' ? suggestion : suggestion.query;
                const suggestionSubreddit = typeof suggestion === 'object' ? suggestion.subreddit : null;

                const iconContent = suggestionSubreddit ?
                    `<span class="suggestion-icon subreddit-icon">${suggestionSubreddit.charAt(0).toUpperCase()}</span>` :
                    '<img src="../assets/search-favicon.png" class="suggestion-favicon" alt="Search">';

                const subredditName = suggestionSubreddit ? `<span class="suggestion-subreddit">‚Ä¢ r/${suggestionSubreddit.toLowerCase()}</span>` : '';

                return `<div onclick="selectSuggestion('${word}', 'search-input', 'suggestions', '${suggestionSubreddit || ''}')" data-subreddit="${suggestionSubreddit || ''}" class="suggestion-item">
            ${iconContent}
            ${word}
            ${subredditName}
        </div>`;
            }).join('');

            suggestionsDiv.innerHTML = suggestionsHtml;
            suggestionsDiv.style.display = 'block';

            // Add real icons for suggestions that have subreddit data
            const suggestionElements = suggestionsDiv.querySelectorAll('[data-subreddit]');
            suggestionElements.forEach(element => {
                const subredditName = element.getAttribute('data-subreddit');
                if (subredditName) {
                    addIconToSuggestion(element, subredditName);
                }
            });
        }

    async function addIconToSuggestion(suggestionElement, subreddit) {
            if (!subreddit) return;

            suggestionElement.querySelector('.suggestion-favicon')?.remove();
                
            const iconContainer = suggestionElement.querySelector('.suggestion-icon');

            // Start with letter fallback
            iconContainer.textContent = subreddit.charAt(0).toUpperCase();

            const storageKey = `subreddit_icon_${subreddit}`;
            const cachedIcon = sessionStorage.getItem(storageKey);

            // Check sessionStorage first
            if (cachedIcon && cachedIcon !== 'null' && cachedIcon !== '/api/placeholder/20/20') {
                const img = document.createElement('img');
                img.src = cachedIcon;
                img.alt = `Icon for r/${subreddit}`;
                img.className = 'subreddit-icon-img';
                iconContainer.textContent = '';
                iconContainer.appendChild(img);
                setTimeout(() => img.classList.add('fade-in'), 10);
                iconContainer.classList.add('icon-loaded');
            } else if (!cachedIcon || cachedIcon === 'null') {
                // Fetch from API
                getSubredditIcon(subreddit).then(iconUrl => {
                    if (iconUrl && iconUrl !== '/api/placeholder/20/20') {
                        const img = document.createElement('img');
                        img.src = iconUrl;
                        img.alt = `Icon for r/${subreddit}`;
                        img.className = 'subreddit-icon-img';
                        iconContainer.textContent = '';
                        iconContainer.appendChild(img);
                        setTimeout(() => img.classList.add('fade-in'), 10);
                        iconContainer.classList.add('icon-loaded');
                        sessionStorage.setItem(storageKey, iconUrl);
                    }
                });
        }
    }

    function selectSuggestion(word, inputId, suggestionsId, subreddit = null) {
            document.getElementById(inputId).value = word;
            document.getElementById(suggestionsId).innerHTML = '';

            // If this suggestion has a subreddit, auto-select it
            if (subreddit) {
                selectSubreddit(subreddit);
            }

            sortSelect.value = 'relevance';
            currentFilters.sort = 'relevance';

            // Store/increment the suggestion
            if (word) {
                try {
                    fetch('http://localhost:3000/api/suggestions/store', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            query: word,
                            subreddit: (subreddit && subreddit !== 'undefined' && subreddit !== 'null') ? subreddit : null
                        })
                    });
                } catch (err) {
                    console.error("Failed to store suggestion:", err);
                }
            }

            // Reset page index and history for new search
            currentPageIndex = 0;

            // Perform the search
            performSearch();
        }

    function selectSubreddit(subName) {
        if (!subName || subName.toLowerCase() === 'all') {
            subredditChipContainer.style.display = 'none';
            
            return; // ‚õî don't show chip for default
        }

        subredditChipContainer.style.display = 'flex';
        subredditChipContainer.querySelector('.chip-text').textContent = 'r/' + subName;
        subredditInput.value = '';
        subredditSuggestions.classList.remove('active');
    }

    function buildCacheKey(baseToken, filters) {
        const encode = str => encodeURIComponent(str || '');

        const query = encode(filters.query);
        const subreddit = encode((filters.subreddit || 'all').toLowerCase());
        const sort = encode(filters.sort || 'hot');
        const time = encode(filters.time || 'all');

        return `${baseToken}__${subreddit}__${sort}__${query}__${time}`;
    }

    function performEnhancedSearch(){
        console.log("Enhanced Search On");
    }

    function needsProgressiveFiltering(filters) {
        console.log('üîç Checking filters for progressive filtering:', filters);

        // Progressive filtering needed for:
        // 1. "new" or "hot" sort with time filtering (not "all" time)
        // 2. "new" sort with content filtering (not "all" content)
        if ((filters.sort === 'new' || filters.sort === 'hot') && filters.time !== 'all') {
            console.log('üîÑ Progressive filtering needed: new/hot sort + time filtering');
            return true;
        }

        if ((filters.sort === 'new' || filters.sort === 'hot') && filters.contentType !== 'all') {
            console.log('üîÑ Progressive filtering needed: new sort + content filtering');
            return true;
        }

        console.log('‚úÖ No progressive filtering needed');
        return false;
    }

    async function performProgressiveSearch(after = null, before = null, navigateBack = false, isInitialLoad = false) {
    
        if (currentFilters.sort === 'ultimate') {
            performEnhancedSearch();
            return;
        }
        console.log('üîÑ performProgressiveSearch() called with:', { after, before, navigateBack, isInitialLoad });

        const query = currentFilters.query?.trim() || '';
        const subreddit = currentFilters.subreddit || '';
        const sort = currentFilters.sort;
        const time = currentFilters.time;
        const contentType = currentFilters.contentType;
        const limit = 10;
        const MAX_FETCHES = 5;

        let fetchCount = 0;
        let allFilteredPosts = [];
        let currentAfterToken = (currentPageIndex === 0) ? null : (after || currentAfter);

        async function fetchBatch() {
            // Build Reddit URL (same logic as performSearch)
            let finalUrl = '';
            const isQuerying = query.length > 0;
            const encodedQuery = encodeURIComponent(query);

            if (isQuerying) {
                finalUrl = `https://www.reddit.com${subreddit ? `/r/${subreddit}` : ''}/search.json?q=${encodedQuery}&sort=${sort}&restrict_sr=1&limit=${limit}&t=${time}`;
            } else if (subreddit) {
                finalUrl = `https://www.reddit.com/r/${subreddit}/${sort}.json?limit=${limit}&t=${time}`;
            } else {
                finalUrl = `https://www.reddit.com/r/all/${sort}.json?limit=${limit}&t=${time}`;
            }

            if (currentAfterToken) finalUrl += `&after=${currentAfterToken}`;

            console.log('üåê Fetching batch from:', finalUrl);

            const response = await fetch(`http://localhost:3000/reddit?url=${encodeURIComponent(finalUrl)}`);
            const data = await response.json();
            console.log('üîç Raw response data:', data);
            return data;
        }

        // Progressive fetch loop
        while (allFilteredPosts.length < 10 && fetchCount < MAX_FETCHES) {
            fetchCount++;
            console.log(`üîÑ Fetch attempt ${fetchCount}/${MAX_FETCHES}`);
            try {
                const batchData = await fetchBatch();

                if (!batchData.data.children || batchData.data.children.length === 0) {
                    console.log('üõë No more posts available');
                    break;
                }

                // Trim the data (same as performSearch)
                const trimmedData = batchData.data.children.map(post => ({
                    id: post.data.id,
                    title: post.data.title,
                    url: post.data.url,
                    permalink: post.data.permalink,
                    subreddit: post.data.subreddit,
                    score: post.data.score,
                    is_video: post.data.is_video,
                    domain: post.data.domain,
                    author: post.data.author,
                    created_utc: post.data.created_utc,
                    num_comments: post.data.num_comments,
                    over_18: post.data.over_18,
                    preview: post.data.preview,
                    selftext: post.data.selftext,
                    body: post.data.body,
                    is_gallery: post.data.is_gallery,
                    gallery_data: post.data.gallery_data,
                    media_metadata: post.data.media_metadata,
                    crosspost_parent_list: post.data.crosspost_parent_list || [],
                    icon_url: null,
                    locked: post.data.locked,
                    stickied: post.data.stickied,
                    content_type: post.content_type
                }));

                // Apply filters 
                let filteredBatch = filterPostsByTime(trimmedData, time);
                filteredBatch = filterPostsByContent(filteredBatch, contentType);
                
                // Early termination: if we got raw posts but some did not pass time filter, stop
                if (trimmedData.length > 0 && filteredBatch.length === 0 && time !== 'all') {
                    console.log('üõë Early termination: got posts but none within time range, stopping');
                    break;
                }

                console.log(`üì¶ Batch: ${trimmedData.length} raw posts ‚Üí ${filteredBatch.length} filtered posts`);

                // Early exit if first fetch yielded 0 filtered results
                if (fetchCount === 1 && filteredBatch.length === 0) {
                    console.log('üõë First fetch returned 0 filtered results, stopping early');
                    break;
                }

                // Add to our collection
                allFilteredPosts.push(...filteredBatch);

                console.log(`üéØ Total filtered posts so far: ${allFilteredPosts.length}`);

                currentAfterToken = batchData.data.after;
                if (!currentAfterToken) {
                    console.log('üõë Reached end of Reddit feed');
                    break;
                }

            } catch (error) {
                console.error('‚ùå Error in progressive fetch:', error);
                break;
            }
        }

        console.log('üéØ Progressive search complete, found:', allFilteredPosts.length, 'posts');

        // Take only the first 10 results
        const finalResults = allFilteredPosts.slice(0, 10);
        const paginationToken = finalResults.length === 10 ? `t3_${finalResults[9].id}` : null;

        // Update the global currentAfter variable
        currentAfter = paginationToken;

        // Save to navigation history
        navigationHistory[currentPageIndex] = {
            query: currentFilters.query,
            subreddit: currentFilters.subreddit,
            after: paginationToken,  // Token from 10th post
            before: null,
            nextBefore: null,
            results: finalResults
        };

        // Display the results
        displayResults(finalResults);
        preloadBookmarks(window.stripeCustomerId);
        updatePagination();
        updateURL();
        window.scrollTo(0, 0);

        console.log('‚úÖ Progressive search displayed:', finalResults.length, 'posts', "PAGINATION TOKEN:", paginationToken);
    }












    function performSearch(after = null, before = null, navigateBack = false, isInitialLoad = false) {

        if (currentFilters.sort === 'ultimate') {
            performEnhancedSearch();
            return;
        }
            hideSpeechBubble();
            showRareLines();
            
            if (window.location.search.includes('page=bookmarks')) {
                const newUrl = window.location.pathname;
                window.history.replaceState({}, '', newUrl);
                const tabsSection = document.querySelector('.tabs-section');
                if (tabsSection) tabsSection.remove();
            
                // Reset title and meta tags back to normal
                document.title = "KarmaFinder";
                document.querySelector('meta[name="description"]').content = "Find exactly what you're looking for on Reddit";
                document.querySelector('meta[property="og:title"]').content = "KarmaFinder";
            }

            console.log('üü¢ performSearch() called with:', { after, before, navigateBack, isInitialLoad });
            console.log('üîç Current Index:', currentPageIndex);

            // Navigation back logic
            if (navigateBack) {
            const targetPage = navigationHistory[currentPageIndex];

            // For going back, we need the after token from the NEXT page
            const nextPageIndex = currentPageIndex + 1;
            const nextPage = navigationHistory[currentPageIndex];

            currentAfter = nextPage?.after || null;
            currentBefore = targetPage?.before || null;

            // Then check for cached results
            if (targetPage?.results?.length &&
                targetPage.query === currentFilters.query &&
                targetPage.subreddit === currentFilters.subreddit) {

                console.log("‚¨ÖÔ∏è Using cached results for back navigation");
                displayResults(targetPage.results);
                preloadBookmarks(window.stripeCustomerId);
                updatePagination();
                window.scrollTo(0, 0);
                return;
                }
            }

            // On initial load, filters should already be set externally
            if (!isInitialLoad) {
            currentFilters = getCurrentFiltersFromUI();
            }

            // Move the else logic here and change it to handle non-navigate-back cases
            if (!navigateBack) {
                currentAfter = after || currentAfter;
                currentBefore = before || currentBefore;
            }

            const query = currentFilters.query?.trim() || '';
            const subreddit = currentFilters.subreddit || '';
            const sort = currentFilters.sort;
            const time = currentFilters.time;
            const contentType = currentFilters.contentType;
            const limit = 10;

            if (subreddit && subreddit !== 'all') {
                saveRecentSubreddit(subreddit);
            }

            const tokenForThisPage = buildCacheKey(currentPageIndex === 0 ? 'page_1' : currentAfter, currentFilters);
            console.log('üè∑Ô∏è Token for this page:', tokenForThisPage);
            console.log('üè∑Ô∏è Building token with currentAfter:', currentAfter);
            console.log('üè∑Ô∏è currentPageIndex:', currentPageIndex);
       
            // Construct Reddit API URL
            let finalUrl = '';
            const isQuerying = query.length > 0;
            const encodedQuery = encodeURIComponent(query);

            if (isQuerying) {
                finalUrl = `https://www.reddit.com${subreddit ? `/r/${subreddit}` : ''}/search.json?q=${encodedQuery}&sort=${sort}&restrict_sr=1&limit=${limit}&t=${time}`;
            } else if (subreddit) {
                finalUrl = `https://www.reddit.com/r/${subreddit}/${sort}.json?limit=${limit}&t=${time}`;
            } else {
                finalUrl = `https://www.reddit.com/r/all/${sort}.json?limit=${limit}&t=${time}`;
            }

            if (after) finalUrl += `&after=${after}`;
            if (before) finalUrl += `&before=${before}`;

            console.log('üîç Filters applied:', currentFilters);
            console.log('üîó Final Reddit URL:', finalUrl);

            // Prepare backend query params
            const params = new URLSearchParams();
            if (subreddit && subreddit !== 'all') params.append('subreddit', subreddit);
            if (query) params.append('query', query);
            if (time !== 'all') params.append('time', time);
            if (sort) params.append('sort', sort);
            if (after) params.append('after', after);
            params.append('limit', limit.toString());

            showLoading();

            // Check if progressive filtering is needed
            if (needsProgressiveFiltering(currentFilters)) {
                console.log('üîÑ Progressive filtering needed, calling performProgressiveSearch()');
                performProgressiveSearch(after, before, navigateBack, isInitialLoad);
                return;
            }

            // Fetch from database
            fetch(`http://localhost:3000/api/db-posts?${params.toString()}`)
                .then(res => res.json())
                .then(dbResult => {
                    if (!dbResult || !dbResult.data || !Array.isArray(dbResult.data.children) || dbResult.data.children.length === 0) {
                        console.log('No database results, skipping to Reddit API...');
                        // Continue to Reddit API fetch
                    } else {
                        console.log(`üóÉÔ∏è Using database results (found ${dbResult.data.children.length} posts)`);

                        currentAfter = dbResult.data.after || null;
                        currentBefore = dbResult.data.before || null;

                        const trimmedData = dbResult.data.children.map(post => ({
                            id: post.data.id,
                            title: post.data.title,
                            url: post.data.url,
                            permalink: post.data.permalink,
                            subreddit: post.data.subreddit,
                            score: post.data.score,
                            is_video: post.data.is_video,
                            domain: post.data.domain,
                            author: post.data.author,
                            created_utc: post.data.created_utc,
                            num_comments: post.data.num_comments,
                            over_18: post.data.over_18,
                            preview: post.data.preview,
                            selftext: post.data.selftext,
                            body: post.data.body,
                            is_gallery: post.data.is_gallery,
                            gallery_data: post.data.gallery_data,
                            media_metadata: post.data.media_metadata,
                            crosspost_parent_list: post.data.crosspost_parent_list || [],
                            content_type: post.data.content_type || '',
                            icon_url: null,
                            locked: post.data.locked,
                            stickied: post.data.stickied
                        }));

                        // console.log('üíæ SAVED navigationHistory[' + currentPageIndex + ']:', navigationHistory[currentPageIndex]);
                        
                        const filtered = filterPostsByTime(trimmedData, currentFilters.time);
                        console.log("üì¶ Raw post in frontend before filtering:", trimmedData);

                        // Save to history
                        navigationHistory[currentPageIndex] = {
                            query: currentFilters.query,
                            subreddit: currentFilters.subreddit,
                            after: dbResult.data.after,
                            before: dbResult.data.before,  
                            nextBefore: trimmedData.length > 0 ? `t3_${trimmedData[0].id}` : null,
                            results: filtered
                        };

                        displayResults(filtered);
                        preloadBookmarks(window.stripeCustomerId);
                        window.scrollTo(0, 0);
                        updatePagination();
                        updateURL();

                        return; // ‚úÖ Stop here ‚Äî don‚Äôt go to Reddit
                    }

                    // ‚¨áÔ∏è FALLBACK TO REDDIT API
                    console.log('üåê Not enough database results, fetching from Reddit API');
                    return fetch(`http://localhost:3000/reddit?url=${encodeURIComponent(finalUrl)}`)
                        .then(res => {
                            if (!res.ok) throw new Error('Reddit API failed');
                            return res.json();
                        })
                        .then(data => {

                            currentAfter = data.data.after || null;
                            currentBefore = data.data.before || null;

                            const trimmedData = data.data.children.map(post => {
          
                                return {
                                    id: post.data.id,
                                    title: post.data.title,
                                    url: post.data.url,
                                    permalink: post.data.permalink,
                                    subreddit: post.data.subreddit,
                                    score: post.data.score,
                                    is_video: post.data.is_video,
                                    domain: post.data.domain,
                                    author: post.data.author,
                                    created_utc: post.data.created_utc,
                                    num_comments: post.data.num_comments,
                                    over_18: post.data.over_18,
                                    preview: post.data.preview,
                                    selftext: post.data.selftext,
                                    body: post.data.body,
                                    is_gallery: post.data.is_gallery,
                                    gallery_data: post.data.gallery_data,
                                    media_metadata: post.data.media_metadata,
                                    crosspost_parent_list: post.data.crosspost_parent_list || [],
                                    icon_url: null,
                                    locked: post.data.locked,
                                    stickied: post.data.stickied,
                                    content_type: post.content_type
                                };
                            });

                            const filtered = filterPostsByTime(trimmedData, currentFilters.time);

                            // Update tokens
                            navigationHistory[currentPageIndex] = {
                                query: currentFilters.query,
                                subreddit: currentFilters.subreddit,
                                after: data.data.after,   
                                before: data.data.before,
                                nextBefore: trimmedData.length > 0 ? `t3_${trimmedData[0].id}` : null
                            };

                            // Use currentAfter which is the token that was used to fetch this page
                            if (data.data.children.length > 0) {
                                savePostsToDatabase(trimmedData.map(p => ({ data: p })), tokenForThisPage);
                                // console.log('üíæ Saved posts to database with page group:', tokenForThisPage);
                            }

                            displayResults(filtered);
                            preloadBookmarks(window.stripeCustomerId);
                            setTimeout(() => {
                                if (!filtered.length) {
                                    showError("Couldn't find those terms. üîé");

                                    handleRandomResponse([
                                        "I couldn't find that, kid.",
                                        "Sorry, squirt.",
                                        "That's not on my records.",
                                        "Shucks.",
                                        "Nada.",
                                        "I got nothin'.",
                                        "Not familiar with that.",
                                        "That's a dead end.",
                                        "Not in my files.",
                                        "Never heard of that place.",
                                        "Zilch.",
                                        "No can do."
                                    ]);
                                }
                            }, 0);

                            window.scrollTo(0, 0);
                            updatePagination();
                            updateURL();                               
                        });
                })
                .catch(err => {
                    console.error('‚ùå Final catch triggered:', err);
                    showError("Something went wrong. Please try again.");
                });           
        }

  function tryGalleryPatch(fullPost, permalink, resultCard, attempt = 1) {
        const galleryData = fullPost.gallery_data?.items;
        const mediaMetadata = fullPost.media_metadata;

        // Don't proceed if essential pieces are missing
        if (!galleryData || !mediaMetadata || !resultCard) {
            if (!resultCard && attempt < 5) {
                setTimeout(() => tryGalleryPatch(fullPost, permalink, resultCard, attempt + 1), 100);
            }
            return;
        }

        const imgContainer = resultCard.querySelector('.img-container');
        const imgWrapper = resultCard.querySelector('.image-wrapper');
        if (!imgContainer || !imgWrapper) {
            return;
        }

        // Send gallery data to modal
        imgWrapper.galleryData = galleryData;
        imgWrapper.mediaMetadata = mediaMetadata;
        imgWrapper.currentIndex = 0;
        console.log('Stored gallery data on wrapper:', galleryData?.length, 'images');

        // Initialize gallery state
        let currentIndex = 0;
        const totalImages = galleryData.length;
        const preloadedImages = {}; 

        // Add gallery navigation elements
        if (!imgWrapper.querySelector('.gallery-nav')) {
            // Make image-wrapper relative for absolute positioning
            imgWrapper.style.position = 'relative';

            // Create navigation container
            const navContainer = document.createElement('div');
            navContainer.className = 'gallery-nav';

            // Left arrow
            const leftArrow = document.createElement('button');
            leftArrow.className = 'gallery-arrow gallery-arrow-left';
            leftArrow.innerHTML = `
    <svg viewBox="0 0 24 24" fill="none">
        <path d="M15 18l-6-6 6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
`;
            leftArrow.style.cssText = `
    position: absolute;
    left: 2px;
    top: 50%;
    transform: translateY(-50%);
    background: rgba(0, 0, 0, 0.5);
    color: white;
    border: none;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    cursor: pointer;
    z-index: 10;
    display: flex;
    align-items: center;
    justify-content: center;
`;

            // Right arrow
            const rightArrow = document.createElement('button');
            rightArrow.className = 'gallery-arrow gallery-arrow-right';
            rightArrow.innerHTML = `
    <svg viewBox="0 0 24 24" fill="none">
        <path d="M9 18l6-6-6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
`;
            rightArrow.style.cssText = `
    position: absolute;
    right: 2px;
    top: 50%;
    transform: translateY(-50%);
    background: rgba(0, 0, 0, 0.5);
    color: white;
    border: none;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    cursor: pointer;
    z-index: 10;
    display: flex;
    align-items: center;
    justify-content: center;
`;

            // Counter
            const counter = document.createElement('div');
            counter.className = 'gallery-counter';
            counter.style.cssText = `
            position: absolute;
            top: 3px;
            right: 3px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 3px 7px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: bold;
            z-index: 10;
        `;

            // Update counter function
            const updateCounter = () => {
                counter.textContent = `${currentIndex + 1}/${totalImages}`;
            };

            const preloadAllImages = () => {
                console.log(`üîÑ Starting preload for next 3 images from index ${currentIndex}`);

                // Only preload next 3 images (forward direction)
                for (let i = 1; i <= 3; i++) {
                    const index = (currentIndex + i) % totalImages;

                    if (!preloadedImages[index]) {
                        const item = galleryData[index];
                        const mediaId = item.media_id;
                        const media = mediaMetadata[mediaId];
                        const original = media?.s?.u?.replace(/&amp;/g, '&');
                        const resolutionFallback = media?.p?.[media.p.length - 1]?.u?.replace(/&amp;/g, '&');
                        const imageUrl = original || resolutionFallback;

                        if (imageUrl) {
                            const img = new Image();
                            const proxyUrl = `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(imageUrl)}&t=${Date.now()}`;

                            img.onload = () => {
                                console.log(`‚úÖ Preloaded image ${index + 1}/${totalImages} - Ready!`);
                            };

                            img.onerror = () => {
                                console.error(`‚ùå Failed to preload image ${index + 1}/${totalImages}`);
                            };

                            img.src = proxyUrl;
                            preloadedImages[index] = img;
                            console.log(`üì• Started preloading image ${index + 1}/${totalImages}`);
                        }
                    } else {
                        console.log(`‚ôªÔ∏è Image ${index + 1}/${totalImages} already preloaded`);
                    }
                }
            };

            const updatePreloadStatus = () => {
                const readyCount = Object.values(preloadedImages).filter(img => img.complete).length;
                console.log(`üìä Preload progress: ${readyCount}/${totalImages} images ready`);
            };
            
            // Navigation function
            const navigateGallery = (direction) => {
                const resultImg = resultCard.querySelector('img.result-image');
                if (!resultImg) return;

                // Update index first
                if (direction === 'prev') {
                    currentIndex = currentIndex > 0 ? currentIndex - 1 : totalImages - 1;
                } else {
                    currentIndex = currentIndex < totalImages - 1 ? currentIndex + 1 : 0;
                }

                // Get new image URL
                const mediaId = galleryData[currentIndex].media_id;
                const media = mediaMetadata[mediaId];
                const original = media?.s?.u?.replace(/&amp;/g, '&');
                const resolutionFallback = media?.p?.[media.p.length - 1]?.u?.replace(/&amp;/g, '&');
                const imageUrl = original || resolutionFallback;

                if (imageUrl) {
                    // Create new image element
                    const newImg = document.createElement('img');
                    newImg.className = 'result-image';
                    newImg.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: ${direction === 'prev' ? 'translateX(-100%)' : 'translateX(100%)'};
        transition: transform 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    `;

                    // Add to wrapper
                    const imgWrapper = resultCard.querySelector('.image-wrapper');
                    imgWrapper.appendChild(newImg);

                    // Check if we have a preloaded image
                    if (preloadedImages[currentIndex] && preloadedImages[currentIndex].complete) {
                        console.log(`‚ö° INSTANT: Using preloaded image ${currentIndex + 1}/${totalImages}`);

                        // Use the EXACT same URL from preloaded image
                        newImg.src = preloadedImages[currentIndex].src;

                        // Since it's preloaded, start animation immediately
                        newImg.style.opacity = '1';

                        // Start animation without waiting
                        setTimeout(() => {
                            // Slide out old image
                            resultImg.style.transform = direction === 'prev' ? 'translateX(100%)' : 'translateX(-100%)';
                            resultImg.style.transition = 'transform 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94)';

                            // Slide in new image
                            newImg.style.transform = 'translateX(0)';

                            // Remove old image after animation
                            setTimeout(() => {
                                if (resultImg && resultImg.parentNode) {
                                    resultImg.remove();
                                }
                                newImg.style.position = '';
                                newImg.style.top = '';
                                newImg.style.left = '';
                            }, 300);
                        }, 10);

                    } else {
                        console.log(`üêå SLOW: Loading image ${currentIndex + 1}/${totalImages} from network`);

                        // Fallback to network loading
                        const proxyUrl = `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(imageUrl)}&t=${Date.now()}`;

                        newImg.onload = () => {
                            newImg.style.opacity = '1';
                            // Slide out old image
                            resultImg.style.transform = direction === 'prev' ? 'translateX(100%)' : 'translateX(-100%)';
                            resultImg.style.transition = 'transform 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94)';

                            // Slide in new image
                            setTimeout(() => {
                                newImg.style.transform = 'translateX(0)';
                            }, 10);

                            // Remove old image after animation
                            setTimeout(() => {
                                if (resultImg && resultImg.parentNode) {
                                    resultImg.remove();
                                }
                                newImg.style.position = '';
                                newImg.style.top = '';
                                newImg.style.left = '';
                            }, 300);
                        };

                        newImg.src = proxyUrl;
                    }
                }

                updateCounter();
                preloadAllImages(currentIndex);
            };

            // Throttling variables
            let lastNavigationTime = 0;
            const THROTTLE_DELAY = 70; // 50ms delay

            // Replace your existing click handlers:
            leftArrow.addEventListener('click', (e) => {
                e.stopPropagation();
                const now = Date.now();
                if (now - lastNavigationTime >= THROTTLE_DELAY) {
                    lastNavigationTime = now;
                    navigateGallery('prev');
                }
            });

            rightArrow.addEventListener('click', (e) => {
                e.stopPropagation();
                const now = Date.now();
                if (now - lastNavigationTime >= THROTTLE_DELAY) {
                    lastNavigationTime = now;
                    navigateGallery('next');
                }
            });

            // Hide arrows if only one image
            if (totalImages <= 1) {
                leftArrow.style.display = 'none';
                rightArrow.style.display = 'none';
            }

            // Add elements to wrapper
            navContainer.appendChild(leftArrow);
            navContainer.appendChild(rightArrow);
            navContainer.appendChild(counter);
            imgWrapper.appendChild(navContainer);

            // Initialize counter
            updateCounter();
            preloadAllImages(currentIndex);
        }

        const mediaId = galleryData[0]?.media_id;
        const media = mediaMetadata[mediaId];

        // Force container visible if valid
        if (imgContainer.style.visibility === 'hidden') {
            imgContainer.style.visibility = 'visible';
        }

        // Ensure shimmer exists
        let shimmer = resultCard.querySelector('.image-placeholder');
        if (!shimmer) {
            shimmer = document.createElement('div');
            shimmer.className = 'image-placeholder shimmer';
            imgWrapper.prepend(shimmer);
        } else {
            shimmer.style.display = 'block';
        }

        // Gather best available image sources
        const original = media?.s?.u?.replace(/&amp;/g, '&');
        const resolutionFallback = media?.p?.[media.p.length - 1]?.u?.replace(/&amp;/g, '&');
        const fallbacks = [original, resolutionFallback].filter(Boolean);

        // Your existing patchImage logic...
        const patchImage = (img) => {
            const trySrc = (index = 0) => {
                if (index >= fallbacks.length) {
                    img.style.display = 'none';
                    showNewsIcon(imgWrapper, shimmer);
                    return;
                }
                const fallbackURL = `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(fallbacks[index])}&t=${Date.now()}`;
                img.onerror = () => {
                    trySrc(index + 1);
                };
                img.onload = () => {
                    console.log('‚úÖ Image loaded from fallback:', fallbackURL);
                    img.classList.add('show');
                    img.style.opacity = '1';
                    shimmer.style.display = 'none';
                };
                img.src = fallbackURL;
            };
            trySrc();
        };

        const resultImg = resultCard.querySelector('img.result-image');
        if (resultImg) {
            patchImage(resultImg);
        } else if (attempt < 3) {
            setTimeout(() => tryGalleryPatch(fullPost, permalink, resultCard, attempt + 1), 100);
        }
    }

   function showNewsIcon(imgWrapper, shimmer) {
        // Hide shimmer if it exists
        if (shimmer) {
            shimmer.style.display = 'none';
        }

        // Also try to find shimmer directly if not passed
        if (!shimmer) {
            const foundShimmer = imgWrapper.querySelector('.image-placeholder');
            if (foundShimmer) {
                foundShimmer.style.display = 'none';
            }
        }

        // Find and remove the existing result-image
        const existingImg = imgWrapper.querySelector('.result-image');
        if (existingImg) {
            existingImg.remove();
        }

        // Create and show news icon
        const newsIcon = document.createElement('div');
        newsIcon.className = 'news-icon-fallback';
        newsIcon.setAttribute('aria-label', 'Article thumbnail');
        newsIcon.style.opacity = '0';
        newsIcon.style.transition = 'opacity 0.3s ease-in-out';
        imgWrapper.appendChild(newsIcon);

        // Fade in news icon
        setTimeout(() => {
            newsIcon.style.opacity = '1';
        }, 10);
   }

    function filterPostsByContent(posts, contentType) {
            if (contentType === 'all') {
                return posts;
            }

            return posts.filter(post => {
                const postContentType = classifyContentType(post);
                return postContentType === contentType;
        });
    }

    function filterPostsByTime(posts, timeFilter) {
            if (timeFilter === 'all') {
                return posts;
            }

            const now = Math.floor(Date.now() / 1000);
            let timeCutoff = 0;

                switch (timeFilter) {
            case "hour": timeCutoff = now - 7200; break;   
            case "day": timeCutoff = now - 172800; break;   
            case "week": timeCutoff = now - 1209600; break;  
            case "month": timeCutoff = now - 5184000; break; 
            case "year": timeCutoff = now - 63072000; break; 
            default: timeCutoff = 0;
            }

        return posts.filter(post => post.created_utc >= timeCutoff);
    }


    async function displayResults(data, isAppend = false) {
            // For append mode in bookmarks
            if (!isAppend) {
                resultsContainer.style.opacity = 0;
                resultsContainer.innerHTML = '';
            }

            const selectedFilter = document.getElementById('content-select').value;
            // console.log('Number of posts:', data.length);
            // console.log('First post:', data[0]);

            const isFromCache = Array.isArray(data);
            const posts = isFromCache
                ? data
                : data.data?.children.map(item => item.data) || [];

            if (!isFromCache) {
                currentAfter = data.data?.after || null;
                currentBefore = data.data?.before || null;
            //    console.log("üîÑ Updated pagination tokens from API:", { currentAfter, currentBefore });
            }

        // Display results
        for (const post of posts) {
            const postId = post.id || (post.permalink?.split("/")[4] ?? "unknown_id");
            const bookmarkId = post.id || post.reddit_post_id;
            const redditPostId = post.reddit_post_id || (post.name?.startsWith('t3_') ? post.name.slice(3) : undefined);

            let postContentType;

            // console.log('BOOKMARK ID:', bookmarkId)

            // Display domain in url
            console.log(post)
            
            // Extract selftext preview image if available
            const selftextPreview = extractPreviewFromSelftext(post.selftext);
            if (selftextPreview && post.url && (post.url.includes('/comments/') || post.url.includes('reddit.com'))) {
                post.url = selftextPreview;
                console.log('üì∏ Using selftext preview image:', selftextPreview);
            }

            const domain = getDomainFromUrl(post.url);

            const title = decodeEntities(post.title?.toLowerCase() || '');
            const isProbablyNSFW = post.over_18 || /\b(tits|titties|rape|raped|tiddies|hentai|nudes|onlyfans|boobs|cum|cock|cocks|cunt|gape|gooning|gooner|goon|pussy)\b/i.test(title);

            const resultCard = document.createElement('div');
            resultCard.className = 'result-card';
            resultCard.dataset.permalink = post.permalink;
            resultCard.dataset.bookmarkId = bookmarkId;
            
            if (isProbablyNSFW) {
                resultCard.classList.add('nsfw');
            }

            // Create comments section outer shell
            const commentsSection = document.createElement('div');
            commentsSection.className = 'comments-section';
        
            // Create inner scrollable area
            const commentsScroll = document.createElement('div');
            commentsScroll.className = 'comments-scroll';

            // Put a loading message in the scroll area
            commentsScroll.innerHTML = '<div class="no-comments">Loading comments...</div>';

            // Append scrollable div inside the outer container
            commentsSection.appendChild(commentsScroll);

            // Fetch comments INTO the inner scrollable div
            fetchComments(post.permalink, commentsScroll);

            // Vote section
            const voteSection = document.createElement('div');
            voteSection.className = 'vote-section';
            
            if (post.stickied) {
                // Pushpin for sticky posts
                const pushpinIcon = document.createElement('div');
                pushpinIcon.className = 'pushpin-icon';
                voteSection.appendChild(pushpinIcon);
            }

            const permalinkUrl = `https://www.reddit.com${post.permalink}`;

            const upvoteBtn = document.createElement('a');
            upvoteBtn.href = permalinkUrl;
            upvoteBtn.target = '_blank';
            upvoteBtn.className = 'vote-button-red';
            upvoteBtn.innerHTML = `
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="18 15 12 9 6 15"></polyline>
        </svg>`;

            const voteCount = document.createElement('div');
            voteCount.className = 'vote-count';
            voteCount.textContent = formatNumber(post.score);

            const downvoteBtn = document.createElement('a');
            downvoteBtn.href = permalinkUrl;
            downvoteBtn.target = '_blank';
            downvoteBtn.className = 'vote-button';
            downvoteBtn.innerHTML = `
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="6 9 12 15 18 9"></polyline>
        </svg>`;
            
            voteSection.appendChild(upvoteBtn);
            voteSection.appendChild(voteCount);
            voteSection.appendChild(downvoteBtn);

            // Content section
            const contentSection = document.createElement('div');
            contentSection.className = 'content-section';

            // Result header with subreddit, author, time
            const resultHeader = document.createElement('div');
            resultHeader.className = 'result-header';

            const subredditLink = document.createElement('a');
            subredditLink.className = 'result-subreddit';
            subredditLink.href = `https://www.reddit.com/r/${post.subreddit}`;
            subredditLink.target = '_blank';

            subredditLink.addEventListener('click', (e) => {
                e.preventDefault();
                const subredditName = post.subreddit;

                // Check banned subreddits list
                if (bannedSubreddits.includes(subredditName.toLowerCase())) {
                    showError(`
                    <div style="text-align: center;">
                        <img src="https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExOWtmaXgzdmdxdzU0dHJ0dXB5MXV2bWdpb2FqYXZndWc1eGNuZTAwMSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/Vuw9m5wXviFIQ/giphy.gif"
                    alt="Rick Astley dancing"
                    style="width: 300px; border-radius: 8px;">
                    </div>
                `);
                    return;
                }

                // Clear any existing search term (for hot posts behavior)
                searchInput.value = '';

                // Set the subreddit in the input
                subredditInput.value = subredditName;
                // Set filter to hot
                sortSelect.value = 'hot';
                currentFilters.sort = 'hot';

                // Update the chip to show this subreddit
                if (subredditChipContainer) {
                    subredditChipContainer.querySelector('.chip-text').textContent = `r/${subredditName}`;
                    subredditChipContainer.style.display = 'flex';
                }

                // Reset page index and history for new search
                currentPageIndex = 0;

                // Perform the search
                performSearch();
            });
            
            const bookmarkContainer = document.createElement('div');
            bookmarkContainer.className = 'bookmark-container';

            const bookmarkIcon = document.createElement('div');
            bookmarkIcon.className = 'bookmark-icon';
            bookmarkIcon.title = 'Save post';
            bookmarkIcon.dataset.postId = bookmarkId;
            bookmarkIcon.setAttribute('tabindex', '0');

            // Handle tab + enter on bookmark icons
            document.addEventListener('keydown', function (e) {
                if ((e.key === 'Enter' || e.key === ' ') && e.target.classList.contains('bookmark-icon')) {
                    e.preventDefault();
                    e.target.click();
                }
            });
            
            const stripeCustomerId = window.stripeCustomerId;

            const savedBookmarks = JSON.parse(sessionStorage.getItem('bookmarks') || '{}');
            if (savedBookmarks[bookmarkId]) {
                bookmarkIcon.classList.add('saved');
            }

            bookmarkContainer.appendChild(bookmarkIcon);
            resultCard.appendChild(bookmarkContainer);

            // Subreddit icon
            const subredditIcon = document.createElement('div');
            subredditIcon.className = 'subreddit-icon';

            // Always show letter immediately
            subredditIcon.textContent = post.subreddit.charAt(0).toUpperCase();

            const storageKey = `subreddit_icon_${post.subreddit}`;
            const cachedIcon = sessionStorage.getItem(storageKey);

            // Check sessionStorage first, then backend, then fetch
            if (cachedIcon && cachedIcon !== 'null' && cachedIcon !== '/api/placeholder/20/20') {
                // Use cached icon from sessionStorage
                const img = document.createElement('img');
                img.src = cachedIcon;
                img.alt = `Icon for r/${post.subreddit}`;
                img.className = 'subreddit-icon-img';
                subredditIcon.textContent = '';
                subredditIcon.appendChild(img);
                setTimeout(() => img.classList.add('fade-in'), 10);
                subredditIcon.classList.add('icon-loaded');
                post.icon_url = cachedIcon;
            } else if (post.icon_url && post.icon_url !== null) {
                // Use the icon URL from the backend response
                console.log(`üåê Using backend icon for r/${post.subreddit}:`, post.icon_url);
                const img = document.createElement('img');
                img.src = post.icon_url;
                img.alt = `Icon for r/${post.subreddit}`;
                img.className = 'subreddit-icon-img';
                subredditIcon.textContent = '';
                subredditIcon.appendChild(img);
                setTimeout(() => img.classList.add('fade-in'), 10);
                subredditIcon.classList.add('icon-loaded');
                // Cache it in sessionStorage for next time
                sessionStorage.setItem(storageKey, post.icon_url);
            } else if (!cachedIcon || cachedIcon === 'null') {
                // Only fetch if backend didn't provide an icon AND no sessionStorage cache
                getSubredditIcon(post.subreddit).then(iconUrl => {
                    if (iconUrl && iconUrl !== '/api/placeholder/20/20') {
                        console.log(`üåè Fetched icon for r/${post.subreddit}:`, iconUrl);
                        const img = document.createElement('img');
                        img.src = iconUrl;
                        img.alt = `Icon for r/${post.subreddit}`;
                        img.className = 'subreddit-icon-img';
                        subredditIcon.textContent = '';
                        subredditIcon.appendChild(img);
                        setTimeout(() => img.classList.add('fade-in'), 10);
                        subredditIcon.classList.add('icon-loaded');
                        post.icon_url = iconUrl;
                        sessionStorage.setItem(storageKey, iconUrl);
                    }
                });
            }

            subredditLink.appendChild(subredditIcon);
            subredditLink.appendChild(document.createTextNode('r/' + post.subreddit));

            const authorSpan = document.createElement('span');
            authorSpan.className = 'result-author';
            authorSpan.textContent = 'Posted by u/' + post.author;

            // Wrap the span in a link
            const authorLink = document.createElement('a');
            authorLink.className = 'result-author';
            authorLink.href = `https://www.reddit.com/user/${post.author}`;
            authorLink.target = '_blank';
            authorLink.setAttribute('aria-label', `Posted by user ${post.author}`);
            authorLink.appendChild(authorSpan);

            const timeSpan = document.createElement('span');
            timeSpan.className = 'result-time';
            timeSpan.textContent = formatTimestamp(post.created_utc);
            timeSpan.tabIndex = 0;
            timeSpan.setAttribute('aria-label', `Posted ${formatTimestamp(post.created_utc)}`);

            const metaRow = document.createElement('div');
            metaRow.className = 'result-meta';

            metaRow.appendChild(subredditLink);
            metaRow.appendChild(authorLink);
            metaRow.appendChild(timeSpan);

            resultHeader.appendChild(metaRow);

            // Result title
            const resultTitle = document.createElement('div');
            resultTitle.className = 'result-title';

            const titleLink = document.createElement('a');
            titleLink.href = `https://www.reddit.com${post.permalink}`;
            titleLink.target = '_blank';
            titleLink.textContent = decodeEntities(post.title || 'Comment in thread');

            // Detect long title length for CSS
            if (post.title.length > 100) {
                resultTitle.classList.add('long-title');
            }

            resultTitle.appendChild(titleLink);

            // Result content (text or snippet)
            const resultContent = document.createElement('div');
            resultContent.className = 'result-content';

            let snippet = '';
            let isFromCrosspost = false;

            if (post.selftext && post.selftext.trim() !== '') {
                const decodedText = decodeEntities(post.selftext);
                snippet = decodedText.length > 300
                    ? decodedText.substring(0, 300) + '...'
                    : decodedText;
            } else if (post.body && post.body.trim() !== '') {
                const decodedBody = decodeEntities(post.body);
                snippet = decodedBody.length > 300
                    ? decodedBody.substring(0, 300) + '...'
                    : decodedBody;
            } else if (
                post.crosspost_parent_list?.[0]?.selftext &&
                post.crosspost_parent_list[0].selftext !== ''
            ) {
                // Set flag for crossposted content
                isFromCrosspost = true;
                const decodedCrosspostText = decodeEntities(post.crosspost_parent_list[0].selftext);
                snippet = decodedCrosspostText.length > 300
                    ? decodedCrosspostText.substring(0, 300) + '...'
                    : decodedCrosspostText;
            }

            // Clear the content area
            resultContent.innerHTML = '';

            if (isFromCrosspost) {
                const quoteEl = document.createElement('div');
                quoteEl.className = 'el-quote';
                quoteEl.innerHTML = parseMarkdown(snippet);
                resultContent.appendChild(quoteEl);
            } else {
                resultContent.innerHTML = parseMarkdown(snippet);
            }

            // After creating your snippet, clean up incomplete links
            if (snippet.match(/\[[^\]]+\]\([^)]*$/)) {
                // Remove the incomplete link syntax at the end
                snippet = snippet.replace(/\[[^\]]+\]\([^)]*$/, '...');
            }

            // Result actions (comments, save, share)
            const resultActions = document.createElement('div');
            resultActions.className = 'result-actions';

            const commentsAction = document.createElement('div');
            commentsAction.className = 'result-action';
            commentsAction.tabIndex = 0;
            commentsAction.setAttribute('aria-label', 'Comments'); 
            commentsAction.innerHTML = `
        <svg class="action-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
        </svg>
        ${post.num_comments || 0} Comments`;

            commentsAction.style.cursor = 'pointer';

            commentsAction.addEventListener('click', () => {
                const url = 'https://www.reddit.com' + post.permalink;
                window.open(url, '_blank');
            });
            commentsAction.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    const url = 'https://www.reddit.com' + post.permalink;
                    window.open(url, '_blank');
                }
            });

            const saveAction = document.createElement('div');
            saveAction.className = 'result-action';
            saveAction.tabIndex = 0;
            saveAction.setAttribute('aria-label', 'Reddit Save'); 
            saveAction.innerHTML = `
        <svg class="action-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>
        </svg>
        Save`;
            saveAction.addEventListener('click', () => {
                const url = 'https://www.reddit.com' + post.permalink;
                window.open(url, '_blank');
            });
            saveAction.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    const url = 'https://www.reddit.com' + post.permalink;
                    window.open(url, '_blank');
                }
            });

            const shareAction = document.createElement('div');
            shareAction.className = 'result-action';
            shareAction.tabIndex = 0;
            shareAction.setAttribute('aria-label', 'Share'); 
            shareAction.innerHTML = `
        <svg class="action-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="18" cy="5" r="3"></circle>
            <circle cx="6" cy="12" r="3"></circle>
            <circle cx="18" cy="19" r="3"></circle>
            <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
            <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
        </svg>
        Share`;
            shareAction.addEventListener('click', () => {
                const url = 'https://www.reddit.com' + post.permalink;
                window.open(url, '_blank');
            });
            shareAction.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    const url = 'https://www.reddit.com' + post.permalink;
                    window.open(url, '_blank');
                }
            });

            resultActions.appendChild(commentsAction);
            resultActions.appendChild(saveAction);
            resultActions.appendChild(shareAction);

            // Add all sections to content area
            contentSection.appendChild(resultHeader);
            contentSection.appendChild(resultTitle);

            if (snippet) {
                contentSection.appendChild(resultContent);
            }

            contentSection.appendChild(resultActions);
            
            // Domain and thumbnail checks
            const knownNewsDomains = new Set([
                "nytimes.com", "apnews.com", "reuters.com", "cnn.com", "bbc.com",
                "cnbc.com", "abcnews.go.com", "aljazeera.com", "nbcnews.com", "independent.co.uk",
                "kstp.com", "nbcnews.to", "nzherald.co.nz", "cnet.com", "latimes.com", "cbsnews.com",
                "spin.com", "xxlmag.com", "newschannel9.com", "kutv.com", "deadline.com",
                "wbez.org", "rawstory.com", "abc15.com", "npr.org", "foxnews.com",
                "washingtonpost.com", "theguardian.com", "wired.com", "bloomberg.com", "politico.com"
            ]);

            const badThumbs = new Set(['self', 'default', 'nsfw', 'spoiler', 'image', '']);
            const normalizedThumb = (post.thumbnail || '').toLowerCase();
            const isGarbageThumb = badThumbs.has(normalizedThumb);

            // Determine whether to analyze the media type for if it's moving
            let mediaUrlForAnalysis = null;

            const url = post.url?.toLowerCase() || '';
            const allowedExts = ['.mp4', '.webm', '.mov', '.mkv', '.avi', '.flv', '.wmv', '.gif'];

            const hasValidExtension = allowedExts.some(ext => url.endsWith(ext));

            if (hasValidExtension) {
                mediaUrlForAnalysis = post.url;
            } else if (post.preview?.images?.[0]?.variants?.gif?.source?.url?.toLowerCase().endsWith('.gif')) {
                mediaUrlForAnalysis = post.preview.images[0].variants.gif.source.url;
            }
            
            // End of analyzing media type

            const knownMediaDomains = [
                "i.redd.it", "v.redd.it", "streamable.com", "imgur.com", "preview.redd.it", "reddit.com", "wikipedia.com",
                "gfycat.com", "redgifs.com", "tenor.com", "youtube.com", "youtu.be"
            ];

            const isKnownMediaDomain = knownMediaDomains.includes(domain);
            const isSelfPost = post.is_self || (post.domain || '').startsWith('self.');
            const isLinkPost = !isSelfPost;
            const isBareLink = post.selftext === "";
            const isRedditMedia =
                post.url?.includes('v.redd.it') ||
                post.url?.includes('i.redd.it') ||
                post.url?.includes('gfycat.com') ||
                post.url?.includes('imgur.com') ||
                post.url?.includes('redgifs.com') ||
                post.url?.endsWith('.gif') ||
                post.url?.endsWith('.mp4') ||
                post.url?.endsWith('.webm');

            const shouldSaveToBackend = (
                isLinkPost &&
                isBareLink &&
                isGarbageThumb &&
                !isRedditMedia && // ‚úÖ filters out gif/video stuff
                (!isKnownMediaDomain || domain === 'youtube.com')
            );

            let thumbnailURL = getThumbnailUrl(post);

            // YOUTUBE THUMBNAIL LOGIC 
            if ((domain === 'youtube.com' || domain === 'youtu.be')) {
                console.log('üîç YouTube URL:', post.url);
                const youtubeThumb = getYouTubeThumbnail(post.url);
                console.log('üì∫ getYouTubeThumbnail returned:', youtubeThumb);
                if (youtubeThumb) {
                    thumbnailURL = youtubeThumb;
                    console.log('üì∫ Using YouTube thumbnail:', youtubeThumb);
                }
            }

            // Special handling for Reddit videos without preview
            if (!thumbnailURL && post.url && post.url.includes('v.redd.it')) {
                const videoId = post.url.split('/').pop();
                const dashUrl = `https://v.redd.it/${videoId}/DASH_480.mp4`;
                console.log('üé• Using Reddit video thumbnail:', dashUrl);
                thumbnailURL = dashUrl; // Set the variable instead of returning
            }

            const hasPreviewImage = post.preview?.images?.[0]?.source?.url;
            const isVideo = post.is_video ||
                (post.domain && post.domain.includes('youtu')) ||
                (post.url && post.url.includes('v.redd.it')) ||
                (post.domain && post.domain.includes('streamable')) ||
                (post.url && post.url.endsWith('.gifv'));
            const isGalleryWithData = post.is_gallery && post.gallery_data && post.media_metadata;

            const isGarbage = !thumbnailURL || ['self', 'default', 'nsfw', 'spoiler', 'image'].includes(thumbnailURL.toLowerCase());
            const hasVisualMedia = (!isGarbage || isGalleryWithData || isVideo || shouldSaveToBackend ||
                hasPreviewImage || !post.is_self || !domain.startsWith('self.'));

            const imgContainer = document.createElement('div');
            imgContainer.className = 'img-container';

            // Append sections
            resultCard.appendChild(voteSection);
            resultCard.appendChild(contentSection);
            resultCard.appendChild(commentsSection);

            //console.log('üîç Post debug:', {
            //    id: post.id,
            //    title: post.title,
            //    is_self: post.is_self,
            //   domain: post.domain,
            //    hasVisualMedia: hasVisualMedia
            //});
            
            // Check database cache before patches
            if (!window.imageHandler) {
                window.imageHandler = new ImageHandler();
            }

            // Only handle images if there's actually visual media
            if (hasVisualMedia) {
                window.imageHandler.handleImageLoad(post, resultCard);
            }
            
            const mediaContainer = createMediaElement(post, thumbnailURL, domain, resultCard);
            resultCard.appendChild(mediaContainer);
            addPlayIconIfNeeded(post, resultCard);

            // Classify content
                if (selectedFilter !== 'all') {
                    postContentType = classifyContentType(post);
                    console.log('Selected filter:', selectedFilter);
                    console.log('Post classified as:', postContentType); 
                if (postContentType !== selectedFilter) {
                    continue;
                }       
            }

            PATCHES(post, resultCard);

            // Add resultCard to the main results container
            resultsContainer.appendChild(resultCard);
            
            // Bookmark click handler
            bookmarkIcon.addEventListener('click', async (e) => {
                e.stopPropagation();
                const bookmarkId = bookmarkIcon.dataset.postId;
                const isSaved = bookmarkIcon.classList.contains('saved');

                try {
                    // Get current bookmarks from sessionStorage
                    const savedBookmarks = JSON.parse(sessionStorage.getItem('bookmarks') || '{}');

                    if (isSaved) {
                        // Remove from database
                        await fetch(`http://localhost:3000/api/bookmarks/${stripeCustomerId}/${bookmarkId}`, {
                            method: 'DELETE',
                        });

                        // Update UI
                        bookmarkIcon.classList.remove('saved');

                        // Update sessionStorage
                        delete savedBookmarks[bookmarkId];
                        sessionStorage.setItem('bookmarks', JSON.stringify(savedBookmarks));

                        console.log('Bookmark with ID of', bookmarkId, 'removed.');
                    } else {
                        // Add to database
                        await fetch('http://localhost:3000/api/bookmarks', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                postId: bookmarkId,
                                stripeCustomerId,
                                title: post.title || '',
                                url: post.url || '',
                                permalink: post.permalink || '',
                                subreddit: post.subreddit || '',
                                score: post.score || 0,
                                is_video: Boolean(post.is_video),
                                domain: post.domain || '',
                                author: post.author || '',
                                created_utc: post.created_utc || 0,
                                num_comments: post.num_comments || 0,
                                over_18: Boolean(post.over_18),
                                selftext: post.selftext || '',
                                body: post.body || '',
                                is_gallery: Boolean(post.is_gallery),
                                gallery_data: post.gallery_data || null,
                                media_metadata: post.media_metadata || null,
                                crosspost_parent_list: post.crosspost_parent_list || [],
                                content_type: post.content_type || '',
                                icon_url: post.icon_url || null,
                                locked: Boolean(post.locked),
                                stickied: Boolean(post.stickied),
                                preview: post.preview || null 
                            }),
                        });

                        // Update UI
                        bookmarkIcon.classList.add('saved');

                        // Update sessionStorage
                        savedBookmarks[bookmarkId] = true;
                        sessionStorage.setItem('bookmarks', JSON.stringify(savedBookmarks));

                        console.log('Bookmark with ID of', bookmarkId, 'saved.');

                        // Reorder to put new bookmark at top of user's section ID 
                        const sectionsResponse = await fetch(`http://localhost:3000/api/sections/${stripeCustomerId}`);
                        const sectionsData = await sectionsResponse.json();
                        const firstSectionId = sectionsData.sections[0]?.id;

                        if (firstSectionId) {
                            const sectionResponse = await fetch(`http://localhost:3000/api/bookmarks/${stripeCustomerId}/section/${firstSectionId}?offset=0&limit=100`);
                            const sectionData = await sectionResponse.json();
                            const existingIds = sectionData.bookmarks.map(b => b.reddit_post_id).filter(id => id !== bookmarkId);
                            const orderedIds = [bookmarkId, ...existingIds];

                            await fetch(`http://localhost:3000/api/bookmarks/${stripeCustomerId}/reorder`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    orderedIds,
                                    sectionId: firstSectionId
                                })
                            });
                        }
                    }
                } catch (err) {
                    console.error('Failed to toggle bookmark:', err);
                }
            });

            // Filter NSFW
            const safeSearchSelect = document.getElementById('safesearch-select');
            if (safeSearchSelect?.value === 'on') {
                document.body.classList.add('safe-search-enabled');
            } else {
                document.body.classList.remove('safe-search-enabled');
            }
        }

        // Initialize Plyr for all video players
        const players = document.querySelectorAll('.js-player');
        players.forEach(player => {
            if (!player.plyr) {
                const plyrInstance = new Plyr(player, {
                    controls: ['play-large', 'play', 'progress', 'current-time', 'mute', 'volume', 'captions', 'settings', 'pip', 'airplay', 'fullscreen'],
                    volume: 1, // Full volume
                    muted: false, // Not muted
                    clickToPlay: true,
                    hideControls: false,
                    seekTime: 10,
                    displayDuration: true,
                    invertTime: false,
                    toggleInvert: true
                });

                // Force unmute after initialization
                plyrInstance.muted = false;
                plyrInstance.volume = 1;

                console.log('üîä Plyr initialized with sound enabled for:', player);
            }
        });

        // Visibility code 
        applyStaggeredAnimation('.result-card', 'visible', 40);
        resultsContainer.style.opacity = 1;
        updatePagination();

        // After the loop, add these logs:
        const allCards = document.querySelectorAll('.result-card');
        const visibleCards = Array.from(allCards).filter(card =>
            window.getComputedStyle(card).display !== 'none'
        );

        if (visibleCards.length === 0) {
            showError("No results found. Try different search terms or filters.");
            paginationContainer.innerHTML = '';
            return;
        }

    }
        
        
        
        
        
        
        
        
        
    
        
        
        
    function PATCHES(post, resultCard) {   
       // Patch media on timeout
        tryMediaPatch(post, resultCard);
        setTimeout(() => {
            addPlayIconIfNeeded(post, resultCard);
        }, 100);

        // Gallery post check, trigger gallery patch if needed
        if (post.is_gallery && post.gallery_data && post.media_metadata) {
            setTimeout(() => {
                tryGalleryPatch(post, post.permalink, resultCard);
            }, 0);
        }
    } 

       // Media handling
        function createMediaElement(post, thumbnailURL, domain, resultCard) {
            const imgContainer = document.createElement('div');
            const imageWrapper = document.createElement('div');

            imgContainer.className = 'img-container';
            imageWrapper.className = 'image-wrapper';
            imageWrapper.tabIndex = 0;

            imageWrapper.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    const existingModal = document.querySelector('.modal-overlay');
                    if (existingModal) {
                        existingModal.remove();
                    } else {
                        imageWrapper.click();
                    }
                }
            });

            imageWrapper.setAttribute('aria-label', `Image for post: ${post.title}`);

            // Determine media type and sources
            const mediaInfo = analyzeMediaType(post, thumbnailURL, domain);

            if (!mediaInfo.hasVisualMedia && domain && domain !== 'reddit.com' && domain.includes('.')) {
                const imagePlaceholder = document.createElement('div');
                const img = document.createElement('img');
                img.className = 'result-image';
                imagePlaceholder.className = 'image-placeholder shimmer';

                imageWrapper.appendChild(imagePlaceholder);
                imageWrapper.appendChild(img);
                imgContainer.appendChild(imageWrapper);
                window.imageHandler.handleBackendScrapedImage(post, resultCard);
                return imgContainer;
            }

            // Check if we have sources, if not return empty container
            if (!mediaInfo.sources || mediaInfo.sources.length === 0) {
                imgContainer.appendChild(imageWrapper);
                return imgContainer;
            }

            // Only create shimmer if we have sources
            const imagePlaceholder = document.createElement('div');
            imagePlaceholder.className = 'image-placeholder shimmer';

            const videoInfo = identifyVideoTypes(post);
            mediaInfo.videoInfo = videoInfo;
            mediaInfo.post = post;
            const mediaElement = createMediaElementByType(mediaInfo);
            mediaElement.style.opacity = '0';
            mediaElement.style.transition = 'opacity 0.3s ease-in-out';

            setupMediaErrorHandling(mediaElement, mediaInfo);
            setupMediaLoadHandling(mediaElement, imagePlaceholder);
            setupImageModal(imageWrapper);

            imageWrapper.appendChild(imagePlaceholder);
            imageWrapper.appendChild(mediaElement);
            imageWrapper.style.cursor = 'pointer';
            imgContainer.appendChild(imageWrapper);
            return imgContainer;
        }

        function analyzeMediaType(post, thumbnailURL, domain) {
            // Get all possible image sources in priority order
            const previewImage = post.preview?.images?.[0]?.source?.url?.replace(/&amp;/g, '&');
            const gifVariant = post.preview?.images?.[0]?.variants?.gif?.source?.url;
            const cleanThumbnail = thumbnailURL?.replace(/&amp;/g, '&');

            // Media type detection
            const isVideo = post.is_video || post.url?.includes('v.redd.it');
            const isGif = post.url?.endsWith('.gif') || gifVariant;
            const isMp4 = post.url?.endsWith('.mp4');
            const isYouTube = domain === 'youtube.com' || domain === 'youtu.be';
            
            const isGallery = post.is_gallery && post.gallery_data && post.media_metadata;

            // Determine if we should show visual media
            const isGarbageThumbnail = !thumbnailURL ||
                ['self', 'default', 'nsfw', 'spoiler', 'image'].includes(thumbnailURL.toLowerCase());

            const hasVisualMedia = (!isGarbageThumbnail ||
                isGallery ||
                isVideo ||
                previewImage) &&
                !(post.domain || '').startsWith('self.');

            // Build source priority list
            const sources = [];

            if (gifVariant) {
                sources.push({ url: gifVariant, type: 'gif', priority: 1 });
            }
            if (post.url?.endsWith('.gif')) {
                sources.push({ url: post.url, type: 'gif', priority: 2 });
            }
            if (isMp4) {
                sources.push({ url: post.url, type: 'video', priority: 3 });
            }
            if (isVideo && cleanThumbnail?.includes('DASH_')) {
                sources.push({ url: cleanThumbnail, type: 'video', priority: 4 });
            }
            if (previewImage) {
                sources.push({
                    url: `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(previewImage)}`,
                    type: 'image',
                    priority: 3
                });
            }
            if (cleanThumbnail && !cleanThumbnail.includes('DASH_')) {
                sources.push({
                    url: `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(cleanThumbnail)}`,
                    type: 'image',
                    priority: 2
                });
            }
            // Add fallback for non-self posts (galleries need this)
            if (post.url && !post.is_self && !(post.domain || '').startsWith('self.')) {
                sources.push({ url: post.url, type: 'fallback', priority: 7 });
            }

            // Sort by priority
            sources.sort((a, b) => a.priority - b.priority);

            return {
                hasVisualMedia,
                sources,
                isVideo,
                isGif,
                isMp4,
                isYouTube,
                primarySource: sources[0] || null
            };
        }
    function identifyVideoTypes(post) {
        console.log('=== VIDEO TYPE ANALYSIS ===');
        console.log('Post ID:', post.id);
        console.log('URL:', post.url);
        console.log('Domain:', post.domain);

        const videoInfo = {
            hasVideo: false,
            videoType: null,
            videoSource: null
        };

        // Check for reddit_video_preview (RedGifs posts with Reddit video data)
        if (post.preview?.reddit_video_preview?.fallback_url) {
            console.log('üé¨ Reddit video preview found (likely RedGifs)!');
            videoInfo.hasVideo = true;
            videoInfo.videoType = 'reddit_native';
            videoInfo.videoSource = post.preview.reddit_video_preview.fallback_url;

            // Extract video ID from the fallback URL
            const videoUrl = post.preview.reddit_video_preview.fallback_url.split("?")[0];
            const videoId = videoUrl.split('/')[3]; // Extract "5xaqqyrjlocf1"
            videoInfo.videoId = videoId;
            videoInfo.audioSource = `https://v.redd.it/${videoId}/DASH_AUDIO_128.mp4`;

            console.log('üìπ Reddit video preview ID extracted:', videoId);
            console.log('üéµ Audio URL:', videoInfo.audioSource);
        }
        // Reddit native video (only if we haven't already found video)
        else if (post.secure_media?.reddit_video?.fallback_url) {
            console.log('üé¨ Reddit video found in secure_media!');
            videoInfo.hasVideo = true;
            videoInfo.videoType = 'reddit_native';
            videoInfo.videoSource = post.secure_media.reddit_video.fallback_url;

            // Extract video ID and construct new audio URL
            const videoUrl = post.secure_media.reddit_video.fallback_url.split("?")[0];
            const videoId = videoUrl.split('/')[3]; // Extract the ID part
            videoInfo.videoId = videoId;
            videoInfo.audioSource = `https://v.redd.it/${videoId}/DASH_AUDIO_128.mp4`;
            console.log('üéµ New audio URL:', videoInfo.audioSource);

        } else if (post.media?.reddit_video?.fallback_url) {
            console.log('üé¨ Reddit video found in media!');
            videoInfo.hasVideo = true;
            videoInfo.videoType = 'reddit_native';
            videoInfo.videoSource = post.media.reddit_video.fallback_url;

            // Extract video ID and construct new audio URL
            const videoUrl = post.media.reddit_video.fallback_url.split("?")[0];
            const videoId = videoUrl.split('/')[3]; // Extract the ID part
            videoInfo.videoId = videoId;
            videoInfo.audioSource = `https://v.redd.it/${videoId}/DASH_AUDIO_128.mp4`;
            console.log('üéµ New audio URL:', videoInfo.audioSource);

        } else if (post.url?.includes('v.redd.it')) {
            console.log('üé¨ v.redd.it URL detected!');
            videoInfo.hasVideo = true;
            videoInfo.videoType = 'reddit_native';

            // Extract the video ID for later backend processing
            const videoId = post.url.split('/').pop();
            videoInfo.videoId = videoId;

            // Use a placeholder source that won't cause errors
            videoInfo.videoSource = null;
            console.log('üìπ Reddit video ID extracted:', videoId);
        }

        // Streamable detection (only if no video found yet)
        if (!videoInfo.hasVideo && post.url?.includes('streamable.com')) {
            console.log('üé• Streamable detected');
            const match = post.url.match(/streamable\.com\/([a-zA-Z0-9]+)/);
            if (match) {
                videoInfo.hasVideo = true;
                videoInfo.videoType = 'streamable';
                videoInfo.embedId = match[1];
                videoInfo.videoSource = `https://streamable.com/e/${match[1]}`;
                console.log('üîó Streamable embed URL:', videoInfo.videoSource);
            }
        }

        // YouTube detection (only if no video found yet)
        if (!videoInfo.hasVideo && (post.url?.includes('youtube.com') || post.url?.includes('youtu.be'))) {
            console.log('üì∫ YouTube detected, full URL:', post.url);
            videoInfo.hasVideo = true;
            videoInfo.videoType = 'youtube';
            videoInfo.videoSource = post.url;

            // Better YouTube ID extraction
            let videoId = null;
            if (post.url.includes('youtube.com/watch')) {
                const urlParams = new URLSearchParams(post.url.split('?')[1]);
                videoId = urlParams.get('v');
            } else if (post.url.includes('youtu.be/')) {
                videoId = post.url.split('youtu.be/')[1].split('?')[0];
            }

            videoInfo.embedId = videoId;
            console.log('üÜî Extracted YouTube ID:', videoId);
        }

        console.log('Final result:', videoInfo);
        console.log('========================');

        return videoInfo;
    }

        function createMediaElementByType(mediaInfo) {
            if (!mediaInfo.primarySource) {
                return document.createElement('img');
            }

            const source = mediaInfo.primarySource;
            let mediaElement;

            if (source.type === 'video' || mediaInfo.isMp4) {
                mediaElement = document.createElement('video');
                mediaElement.muted = true;
                mediaElement.playsInline = true;
                mediaElement.preload = 'metadata';

                if (mediaInfo.isMp4) {
                    mediaElement.autoplay = true;
                    mediaElement.loop = true;
                } else {
                    mediaElement.currentTime = 0.1; // For preview frame
                }
            } else {
                mediaElement = document.createElement('img');
            }

                // Set standard attributes
                mediaElement.className = 'result-image';
                mediaElement.alt = 'Post thumbnail';
                mediaElement.setAttribute('loading', 'eager');
                mediaElement.setAttribute('decoding', 'async');
                mediaElement.setAttribute('fetchpriority', 'low');
                mediaElement.setAttribute('crossorigin', 'anonymous');

            // Store video info for modal detection
            if (mediaInfo.videoInfo && mediaInfo.videoInfo.videoType === 'reddit_native') {
                mediaElement.dataset.isRedditVideo = 'true';
                mediaElement.dataset.videoType = 'reddit_native';

                // Extract and store video ID
                const post = mediaInfo.post;
                let videoId = null;
                if (post?.url?.includes('v.redd.it')) {
                    videoId = post.url.split('/').pop();
                } else if (mediaInfo.videoInfo.videoSource) {
                    const match = mediaInfo.videoInfo.videoSource.match(/v\.redd\.it\/([^\/]+)/);
                    if (match) videoId = match[1];
                }

                if (videoId) {
                    mediaElement.dataset.videoId = videoId;
                }
            }

            // Set initial source
            mediaElement.src = source.url;

            return mediaElement;
        }

        async function getCombinedRedditVideo(videoId) {
            try {

                // Call the backend API
                const response = await fetch(`http://localhost:3000/api/reddit-video/${videoId}`);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('üì¶ Backend response:', data);

                if (data.success && data.videoUrl) {
                    // Backend has the video ready
                    console.log('‚úÖ Video ready immediately:', data.videoUrl);
                    return `http://localhost:3000${data.videoUrl}`;
                } else {
                    console.error('‚ùå Backend error:', data.error);
                    return null;
                }

            } catch (error) {
                console.error('‚ùå Error getting combined video:', error);
                return null;
            }
        }

        function setupMediaErrorHandling(mediaElement, mediaInfo) {
            let currentSourceIndex = 0;

            function tryNextSource() {
                currentSourceIndex++;

                if (currentSourceIndex >= mediaInfo.sources.length) {
                    // All sources failed
                    console.error('üö´ All media sources failed for:', mediaInfo.sources);
                    setTimeout(() => {
                        const resultCard = mediaElement.closest('.result-card');
                        const shimmer = resultCard?.querySelector('.image-placeholder');
                        if (shimmer) shimmer.style.display = 'none';

                        const imageWrapper = mediaElement.closest('.image-wrapper');
                        if (imageWrapper) {
                            showNewsIcon(imageWrapper, shimmer);
                        }
                    }, 1000);
                    return;
                }

                const nextSource = mediaInfo.sources[currentSourceIndex];
                console.warn(`üîÅ Trying source ${currentSourceIndex + 1}/${mediaInfo.sources.length}:`, nextSource.url);

                // Update element type if needed
                if (nextSource.type === 'video' && mediaElement.tagName !== 'VIDEO') {
                    // Need to replace with video element
                    const newElement = document.createElement('video');
                    newElement.className = mediaElement.className;
                    newElement.alt = mediaElement.alt;

                    // Copy attributes
                    ['loading', 'decoding', 'fetchpriority', 'crossorigin'].forEach(attr => {
                        newElement.setAttribute(attr, mediaElement.getAttribute(attr));
                    });

                    newElement.muted = true;
                    newElement.playsInline = true;
                    newElement.preload = 'metadata';

                    mediaElement.parentNode.replaceChild(newElement, mediaElement);
                    mediaElement = newElement;
                    
                }

                mediaElement.src = nextSource.url;
            }

            mediaElement.addEventListener('error', (e) => {
                // Skip retry for DASH URLs that should work as videos
                if (mediaElement.src.includes('DASH_') && mediaElement.tagName === 'VIDEO') {
                    console.log('üé¨ DASH video error, but this is expected behavior');
                    return;
                }

                console.warn('‚ùå Media load failed:', mediaElement.src);
                tryNextSource();
            });
        }

    function setupMediaLoadHandling(mediaElement, imagePlaceholder) {
        const handleSuccess = () => {
            console.log('‚úÖ Media loaded successfully:', mediaElement.src);

            // Start both animations simultaneously
            // Fade out shimmer
            imagePlaceholder.style.opacity = '0';
            imagePlaceholder.style.transition = 'opacity 0.3s ease-in-out';

            // Fade in media
            mediaElement.style.opacity = '1';

            // Remove shimmer after fade completes
            setTimeout(() => {
                imagePlaceholder.style.display = 'none';
                // or imagePlaceholder.remove(); if you want to completely remove it
            }, 300);
        };

        if (mediaElement.tagName === 'VIDEO') {
            mediaElement.addEventListener('loadeddata', handleSuccess);
            mediaElement.addEventListener('canplay', handleSuccess);
        } else {
            mediaElement.addEventListener('load', () => {
                if (mediaElement.naturalWidth > 0 && mediaElement.naturalHeight > 0) {
                    handleSuccess();
                }
            });
        }
    }
    
    function setupImageModal(imageWrapper, galleryData = null, mediaMetadata = null, currentIndex = 0) {
            imageWrapper.addEventListener('click', async function (event) {
                // Prevent any default behaviors that might cause navigation
                event.preventDefault();
                event.stopPropagation();

                // Remove any existing modals first
                const existingModal = document.querySelector('.modal-overlay');
                if (existingModal) {
                    existingModal.remove();
                }

                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'modal-overlay';
                modalOverlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s ease;
        `;

                // Create modal container that will hold both content and arrows
                const modalContainer = document.createElement('div');
                modalContainer.style.cssText = `
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            max-width: 90vw;
            max-height: 90vh;
        `;

                // Check if this is a Reddit video thumbnail
                const imageElement = imageWrapper.querySelector('img');
                const isRedditVideo = imageElement && (imageElement.dataset.isRedditVideo === 'true' || imageElement.dataset.videoType === 'redgifs');
                const originalVideo = imageWrapper.querySelector('.js-player');

                let modalContent;
                let videoProcessingAborted = false;

                if (isRedditVideo) {
                    // Create video with poster immediately - NO BLACK SCREEN
                    modalContent = document.createElement('div');
                    modalContent.style.cssText = `
                width: auto !important;
                height: auto !important;
                max-width: 90vw;
                max-height: 90vh;
                opacity: 0;
                transform: scale(0.8);
                transition: all 0.1s ease;
                border-radius: 25px;
                padding: 0;
                background: transparent;
                overflow: hidden;
                position: relative;
            `;

                    // Create video element with poster IMMEDIATELY
                    const newVideo = document.createElement('video');
                    newVideo.className = 'js-player';
                    newVideo.setAttribute('controls', '');
                    newVideo.setAttribute('playsinline', '');
                    newVideo.setAttribute('poster', imageElement.src);
                    newVideo.muted = false;
                    newVideo.style.cssText = `
                width: 100% !important;
                height: auto !important;
                max-width: 90vw;
                max-height: 90vh;
                border-radius: 25px;
            `;

                    modalContent.appendChild(newVideo);

                    // Initialize Plyr immediately
                    try {
                        const modalPlyrInstance = new Plyr(newVideo, {
                            controls: ['play-large', 'play', 'progress', 'current-time', 'mute', 'volume', 'captions', 'settings', 'pip', 'airplay', 'fullscreen'],
                            volume: 1,
                            muted: false,
                            clickToPlay: true,
                            autoplay: true,
                            disableContextMenu: false,
                            fullscreen: {
                                enabled: true,
                                fallback: true,
                                iosNative: false
                            }
                        });

                        modalPlyrInstance.on('enterfullscreen', () => {
                            const video = newVideo;
                            video.style.marginLeft = 'auto';
                            video.style.marginRight = '0';
                            video.style.transform = 'translateX(-5vw) translateY(5vh) scale(1.2)';
                        });

                        modalPlyrInstance.on('exitfullscreen', () => {
                            const video = newVideo;
                            video.style.marginLeft = '';
                            video.style.marginRight = '';
                            video.style.transform = '';
                            video.style.width = '';
                        });

                        modalPlyrInstance.muted = false;
                        modalPlyrInstance.volume = 1;

                    } catch (error) {
                        console.log('‚ùå Error initializing Plyr:', error);
                    }

                    // Hide the Plyr play button during loading
                    const plyrPlayButton = modalContent.querySelector('.plyr__control--overlaid');
                    if (plyrPlayButton) {
                        plyrPlayButton.style.display = 'none';
                    }

                    // Add spinner overlay (positioned to not block close button)
                    const loadingOverlay = document.createElement('div');
                    loadingOverlay.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10;
                pointer-events: none;
            `;

                    const spinnerWrapper = createWhiteCanvasSpinner();
                    spinnerWrapper.style.cssText = `
                display: flex;
                align-items: center;
                justify-content: center;
                transform: scale(1.5);
            `;

                    loadingOverlay.appendChild(spinnerWrapper);
                    modalContent.appendChild(loadingOverlay);

                    // Get the stored video ID and process in background
                    const videoId = imageElement.dataset.videoId;
                    if (videoId) {
                        // Start video processing in background
                        (async () => {
                            try {
                                console.log('üîÑ Getting combined video for ID:', videoId);
                                const combinedVideoUrl = await getCombinedRedditVideo(videoId);

                                // Check if modal was closed during processing
                                if (videoProcessingAborted || !document.body.contains(modalOverlay)) {
                                    console.log('üì¥ Modal closed, aborting video load');
                                    return;
                                }

                                if (combinedVideoUrl) {
                                    newVideo.src = combinedVideoUrl;
                                    loadingOverlay.remove();
                                    // Show the play button again
                                    if (plyrPlayButton) {
                                        plyrPlayButton.style.display = '';
                                    }
                                } else {
                                    // Keep spinner, retry after delay
                                    setTimeout(async () => {
                                        // Check again if modal still exists
                                        if (videoProcessingAborted || !document.body.contains(modalOverlay)) {
                                            return;
                                        }

                                        const retryUrl = await getCombinedRedditVideo(videoId);
                                        if (retryUrl && !videoProcessingAborted && document.body.contains(modalOverlay)) {
                                            newVideo.src = retryUrl;
                                            loadingOverlay.remove();
                                            if (plyrPlayButton) {
                                                plyrPlayButton.style.display = '';
                                            }
                                        }
                                    }, 2000);
                                }
                            } catch (error) {
                                console.error('‚ùå Error in video processing:', error);
                                if (document.body.contains(modalOverlay)) {
                                    loadingOverlay.remove();
                                }
                            }
                        })();
                    }

                } else if (originalVideo) {
                    // Handle non-Reddit videos (existing logic)
                    modalContent = document.createElement('div');
                    modalContent.style.cssText = `
                width: auto !important;
                height: auto !important;
                max-width: 90vw;
                max-height: 90vh;
                opacity: 0;
                transform: scale(0.8);
                transition: all 0.1s ease;
                border-radius: 25px;
                overflow: hidden;
            `;

                    const newVideo = document.createElement('video');
                    newVideo.className = 'js-player';
                    newVideo.setAttribute('controls', '');
                    newVideo.setAttribute('playsinline', '');
                    newVideo.src = originalVideo.src || originalVideo.querySelector('source')?.src;
                    newVideo.style.cssText = `
                width: 100% !important;
                height: auto !important;
                max-width: 90vw;
                max-height: 90vh;
                border-radius: 25px;
                object-fit: cover;
            `;

                    modalContent.appendChild(newVideo);

                } else {
                    // Handle regular images (existing logic)
                    modalContent = imageWrapper.cloneNode(true);

                    // Remove the small thumbnail arrows from modal 
                    const thumbnailArrows = modalContent.querySelectorAll('.gallery-arrow');
                    thumbnailArrows.forEach(arrow => arrow.remove());

                    // Make the counter bigger for modal view
                    const galleryCounter = modalContent.querySelector('.gallery-counter');
                    if (galleryCounter) {
                        galleryCounter.style.cssText = `
                        position: absolute;
                        top: 10px;
                        right: 10px;
                        background: rgba(0, 0, 0, 0.7);
                        color: white;
                        padding: 7px 12px;
                        border-radius: 15px;
                        font-size: 15px;
                        font-weight: bold;
                        z-index: 10;
                    `;
                    }

                    modalContent.style.cssText = `
                width: auto !important;
                height: auto !important;
                cursor: pointer;
                max-width: 90vw;
                max-height: 90vh;
                display: block !important;
                opacity: 0;
                transform: scale(0.8);
                transition: all 0.1s ease;
                border-radius: 25px;
            `;

                    const imageInside = modalContent.querySelector('img');
                    const shimmerPlaceholder = modalContent.querySelector('.image-placeholder');

                    if (imageInside) {
                        imageInside.style.cssText = `
                    width: 100% !important;
                    height: auto !important;
                    max-width: 90vw;
                    max-height: 90vh;
                    opacity: 1 !important;
                `;
                    }

                    if (shimmerPlaceholder) {
                        shimmerPlaceholder.remove();
                    }
                }

                // Add modal content to container
                modalContainer.appendChild(modalContent);
                
                // Create left navigation arrow (positioned outside the content)
                const leftArrow = document.createElement('div');
                leftArrow.className = 'modal-nav-arrow modal-nav-left';
                leftArrow.innerHTML = `
    <svg xmlns="http://www.w3.org/2000/svg" width="29" height="29" viewBox="0 0 24 24" fill="none" style="transform: translateX(-1px);" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-left-icon lucide-chevron-left"><path d="m15 18-6-6 6-6"/></svg>
`;

                leftArrow.style.cssText = `
            position: absolute;
            left: 320px;
            top: 50%;
            transform: translateY(-50%);
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10001;
            user-select: none;
        `;

                // Create right navigation arrow (positioned outside the content)
                const rightArrow = document.createElement('div');
                rightArrow.className = 'modal-nav-arrow modal-nav-right';
                rightArrow.innerHTML = `
    <svg xmlns="http://www.w3.org/2000/svg" width="29" height="29" viewBox="0 0 24 24" fill="none" style="transform: translateX(1px);" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-right-icon lucide-chevron-right"><path d="m9 18 6-6-6-6"/></svg>
`;
                rightArrow.style.cssText = `
            position: absolute;
            right: 320px;
            top: 50%;
            transform: translateY(-50%);
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10001;
            user-select: none;
        `;

                // Get gallery data from the original image wrapper
                const galleryData = imageWrapper.galleryData;
                const mediaMetadata = imageWrapper.mediaMetadata;
                let currentIndex = imageWrapper.currentIndex || 0;

                // Navigation function for modal
                // Add preloaded images storage for modal
                const modalPreloadedImages = {};

                // Enhanced preloading function for modal
                const preloadModalImages = (currentIndex) => {
                    console.log(`üîÑ Modal: Starting preload for next 3 images from index ${currentIndex}`);

                    // Only preload next 3 images (forward direction)
                    for (let i = 1; i <= 3; i++) {
                        const index = (currentIndex + i) % galleryData.length;

                        if (!modalPreloadedImages[index]) {
                            const item = galleryData[index];
                            const mediaId = item.media_id;
                            const media = mediaMetadata[mediaId];
                            const original = media?.s?.u?.replace(/&amp;/g, '&');
                            const resolutionFallback = media?.p?.[media.p.length - 1]?.u?.replace(/&amp;/g, '&');
                            const imageUrl = original || resolutionFallback;

                            if (imageUrl) {
                                const img = new Image();
                                const proxyUrl = `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(imageUrl)}&t=${Date.now()}`;

                                img.onload = () => {
                                    console.log(`‚úÖ Modal: Preloaded image ${index + 1}/${galleryData.length} - Ready!`);
                                };

                                img.onerror = () => {
                                    console.error(`‚ùå Modal: Failed to preload image ${index + 1}/${galleryData.length}`);
                                };

                                img.src = proxyUrl;
                                modalPreloadedImages[index] = img;
                                console.log(`üì• Modal: Started preloading image ${index + 1}/${galleryData.length}`);
                            }
                        }
                    }
                };

                // Enhanced navigation function with throttling and preloading
                let lastModalNavigationTime = 0;
                const MODAL_THROTTLE_DELAY = 50;

                const navigateModalGallery = (direction) => {
                    // Throttle rapid clicks
                    const now = Date.now();
                    if (now - lastModalNavigationTime < MODAL_THROTTLE_DELAY) {
                        return;
                    }
                    lastModalNavigationTime = now;

                    if (!galleryData || !mediaMetadata) return;

                    const totalImages = galleryData.length;
                    const currentImg = modalContent.querySelector('img');
                    if (!currentImg) return;

                    // Update index
                    if (direction === 'prev') {
                        currentIndex = currentIndex > 0 ? currentIndex - 1 : totalImages - 1;
                    } else {
                        currentIndex = currentIndex < totalImages - 1 ? currentIndex + 1 : 0;
                    }

                    const galleryCounter = modalContent.querySelector('.gallery-counter');
                    if (galleryCounter) {
                        galleryCounter.textContent = `${currentIndex + 1}/${totalImages}`;
                    }

                    // Get new image URL
                    const mediaId = galleryData[currentIndex].media_id;
                    const media = mediaMetadata[mediaId];
                    const original = media?.s?.u?.replace(/&amp;/g, '&');
                    const resolutionFallback = media?.p?.[media.p.length - 1]?.u?.replace(/&amp;/g, '&');
                    const imageUrl = original || resolutionFallback;

                    if (imageUrl) {
                        // Create new image element
                        const newImg = document.createElement('img');
                        newImg.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100% !important;
            height: auto !important;
            max-width: 90vw;
            max-height: 90vh;
            opacity: 1 !important;
            transform: ${direction === 'prev' ? 'translateX(-100%)' : 'translateX(100%)'};
            transition: transform 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            border-radius: 25px;
        `;

                        // Add to modal content
                        modalContent.appendChild(newImg);

                        // Check if we have a preloaded image
                        if (modalPreloadedImages[currentIndex] && modalPreloadedImages[currentIndex].complete) {
                            console.log(`‚ö° MODAL INSTANT: Using preloaded image ${currentIndex + 1}/${totalImages}`);

                            // Use the EXACT same URL from preloaded image
                            newImg.src = modalPreloadedImages[currentIndex].src;

                            // Since it's preloaded, start animation immediately
                            setTimeout(() => {
                                // Slide out old image
                                currentImg.style.transform = direction === 'prev' ? 'translateX(100%)' : 'translateX(-100%)';
                                currentImg.style.transition = 'transform 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94)';

                                // Slide in new image
                                newImg.style.transform = 'translateX(0)';

                                // Remove old image after animation
                                setTimeout(() => {
                                    if (currentImg && currentImg.parentNode) {
                                        currentImg.remove();
                                    }
                                    newImg.style.position = '';
                                    newImg.style.top = '';
                                    newImg.style.left = '';
                                }, 300);
                            }, 10);

                        } else {
                            console.log(`üêå MODAL SLOW: Loading image ${currentIndex + 1}/${totalImages} from network`);

                            // Fallback to network loading
                            const proxyUrl = `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(imageUrl)}&t=${Date.now()}`;

                            newImg.onload = () => {
                                // Slide out old image
                                currentImg.style.transform = direction === 'prev' ? 'translateX(100%)' : 'translateX(-100%)';
                                currentImg.style.transition = 'transform 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94)';

                                // Slide in new image
                                setTimeout(() => {
                                    newImg.style.transform = 'translateX(0)';
                                }, 10);

                                // Remove old image after animation
                                setTimeout(() => {
                                    if (currentImg && currentImg.parentNode) {
                                        currentImg.remove();
                                    }
                                    newImg.style.position = '';
                                    newImg.style.top = '';
                                    newImg.style.left = '';
                                }, 300);
                            };

                            newImg.src = proxyUrl;
                        }
                    }

                    // Preload next images after navigation
                    preloadModalImages(currentIndex);

                    // Update the original wrapper's current index
                    imageWrapper.currentIndex = currentIndex;
                };

                // Add click handlers for navigation arrows
                leftArrow.addEventListener('click', (e) => {
                    e.stopPropagation();
                    navigateModalGallery('prev');
                });

                rightArrow.addEventListener('click', (e) => {
                    e.stopPropagation();
                    navigateModalGallery('next');
                });

            const hasGallery = galleryData && galleryData.length > 1;

            if (hasGallery) {
                // Add arrows to container
                modalContainer.appendChild(leftArrow);
                modalContainer.appendChild(rightArrow);

                // Animate in arrows
                leftArrow.style.opacity = '0';
                rightArrow.style.opacity = '0';
                leftArrow.style.transition = 'opacity 0.1s ease';
                rightArrow.style.transition = 'opacity 0.1s ease';
            }

                // Add container to overlay
                modalOverlay.appendChild(modalContainer);

                // Start preloading for modal
                if (galleryData && galleryData.length > 1) {
                    setTimeout(() => {
                        preloadModalImages(currentIndex);
                    }, 100);
                }
                document.body.appendChild(modalOverlay);

                // Save global ref
                window.currentModalOverlay = modalOverlay;

                // Trigger opening animation
                setTimeout(() => {
                    modalOverlay.style.backgroundColor = 'rgba(0,0,0,0.8)';
                    modalContent.style.opacity = '1';
                    modalContent.style.transform = 'scale(1)';

                    // Show arrows with same timing
                    leftArrow.style.opacity = '1';
                    rightArrow.style.opacity = '1';
                }, 10);

                // Close modal function
                function closeModal() {
                    videoProcessingAborted = true; // Stop any ongoing video processing

                    // Immediately hide the navigation arrows
                    const leftArrow = modalOverlay.querySelector('.modal-nav-left');
                    const rightArrow = modalOverlay.querySelector('.modal-nav-right');
                    if (leftArrow) leftArrow.style.display = 'none';
                    if (rightArrow) rightArrow.style.display = 'none';

                    modalOverlay.style.backgroundColor = 'rgba(0,0,0,0)';
                    modalContent.style.opacity = '0';
                    modalContent.style.transform = 'scale(0.8)';
                    setTimeout(() => {
                        if (document.body.contains(modalOverlay)) {
                            document.body.removeChild(modalOverlay);
                        }
                    }, 300);
                }

                // ESC key handler
                function handleEscKey(event) {
                    if (event.key === 'Escape') {
                        closeModal();
                        document.removeEventListener('keydown', handleEscKey);
                    }
                }
                document.addEventListener('keydown', handleEscKey);

                // Background click handler - updated to not close when clicking arrows
                modalOverlay.addEventListener('click', function (event) {
                    // Don't close if clicking on video controls, video itself, or navigation arrows
                    if (event.target.closest('video, .plyr, .plyr__controls, .js-player, .modal-nav-arrow')) {
                        return;
                    }

                    // Don't close if clicking on the modal content itself
                    if (event.target.closest('.modal-container') && !event.target.classList.contains('modal-overlay')) {
                        return;
                    }

                    closeModal();
                });
            });
        }

    class ImageHandler {
        constructor() {
            this.knownNewsDomains = new Set([
                "nytimes.com", "apnews.com", "reuters.com", "cnn.com", "bbc.com",
                "cnbc.com", "abcnews.go.com", "aljazeera.com", "nbcnews.com", "independent.co.uk",
                "kstp.com", "nbcnews.to", "nzherald.co.nz", "cnet.com", "latimes.com", "cbsnews.com",
                "spin.com", "xxlmag.com", "newschannel9.com", "kutv.com", "deadline.com",
                "wbez.org", "rawstory.com", "abc15.com", "npr.org", "foxnews.com",
                "washingtonpost.com", "theguardian.com", "wired.com", "bloomberg.com", "politico.com"
            ]);

            this.knownMediaDomains = [
                "i.redd.it", "v.redd.it", "streamable.com", "imgur.com", "preview.redd.it",
                "reddit.com", "wikipedia.com", "gfycat.com", "redgifs.com", "tenor.com",
                "youtube.com", "youtu.be"
            ];

            this.badThumbs = new Set(['self', 'default', 'nsfw', 'spoiler', 'image', '']);
            this.failureCount = new Map(); // Track failures per post
        }

        // Determine if post needs backend scraping
        shouldUseBackendScraper(post) {
            const domain = post.domain || this.getDomainFromUrl(post.url);
            const isGarbageThumb = this.badThumbs.has((post.thumbnail || '').toLowerCase());
            const isSelfPost = post.is_self || (post.domain || '').startsWith('self.');
            const isLinkPost = !isSelfPost;
            const isBareLink = post.selftext === "";
            const isRedditMedia = this.isRedditMediaUrl(post.url);
            const isKnownMediaDomain = this.knownMediaDomains.includes(domain);

            return (
                isLinkPost &&
                isBareLink &&
                isGarbageThumb &&
                !isRedditMedia &&
                (!isKnownMediaDomain || domain === 'youtube.com')
            );
        }

        // Check if URL is Reddit media
        isRedditMediaUrl(url) {
            if (!url) return false;
            return url.includes('v.redd.it') ||
                url.includes('i.redd.it') ||
                url.includes('gfycat.com') ||
                url.includes('imgur.com') ||
                url.includes('/comments/') ||
                url.includes('redgifs.com') ||
                url.endsWith('.gif') ||
                url.endsWith('.mp4') ||
                url.endsWith('.webm');
        }

        // Extract domain from URL
        getDomainFromUrl(url) {
            try {
                return new URL(url).hostname.replace('www.', '');
            } catch {
                return '';
            }
        }

        // Helper function to check if URL is a Reddit domain
        isRedditDomain(url) {
            if (!url) return false;
            const redditDomains = ['i.redd.it', 'v.redd.it', 'reddit.com', 'preview.redd.it', 'external-preview.redd.it'];
            return redditDomains.some(domain => url.includes(domain));
        }

        // Handle image loading with retry logic
        async handleImageLoad(post, resultCard) {
            const postId = post.id;

            // Don't handle images for text posts UNLESS they have extracted media
            if ((post.is_self || (post.domain || '').startsWith('self.')) && !post.url.includes('i.redd.it')) {
                return; 
            }

            // Skip Reddit image domains entirely
            if (this.isRedditDomain(post.url)) {
                // console.log(`üö´ Skipping Reddit image domain: ${post.url}`);
                return;
            }

            const shouldScrape = this.shouldUseBackendScraper(post);

            if (shouldScrape) {
                await this.handleBackendScrapedImage(post, resultCard);
            } else {
                await this.handleDirectImage(post, resultCard);
            }
        }

        // Handle backend-scraped images
        async handleBackendScrapedImage(post, resultCard) {
            const postId = post.id;

            try {
                // Try cached first
                const cached = await this.getCachedImage(postId);
                if (cached.success && cached.data.thumbnail) {
                    this.updateImageSuccess(resultCard, cached.data.thumbnail);
                    this.createLinkPreview(post, resultCard);
                    return;
                }

                // Try scraping
                const scraped = await this.scrapeImage(post);
                if (scraped.success && scraped.data?.thumbnail) {
                    this.updateImageSuccess(resultCard, scraped.data.thumbnail);
                    this.updateCache(postId, scraped);
                    this.createLinkPreview(post, resultCard);
                    return;
                }

                // Failed - increment counter and maybe show news icon
                this.handleImageFailure(postId, resultCard);

            } catch (error) {
                console.error('‚ùå Backend image handling failed:', error);
                this.handleImageFailure(postId, resultCard);
            }
        }

        // Handle direct images (non-scraped)
        async handleDirectImage(post, resultCard) {
            // Skip Reddit domains
            if (this.isRedditDomain(post.url)) {
                console.log(`üö´ Skipping Reddit domain: ${post.url}`);
                return;
            }

            // Save to backend for analytics/caching WITHOUT scraping
            try {
                await fetch('http://localhost:3000/api/save-image', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        reddit_post_id: post.id,
                        subreddit: post.subreddit,
                        title: post.title,
                        url: post.url,
                        thumbnail: post.thumbnail
                    })
                });
            } catch (error) {
                console.log('‚ö†Ô∏è Backend save failed (non-critical):', error);
            }
        }

        // Handle image failure with retry logic
        handleImageFailure(postId, resultCard) {
            const failures = this.failureCount.get(postId) || 0;
            this.failureCount.set(postId, failures + 1);
            console.log(`‚ùå Image failure ${failures + 1} for post ${postId}`);

            // Show news icon immediately for backend scraping failures
            if (failures >= 2) { 
                console.log('üóûÔ∏è Backend scraping failed, showing news icon');
                this.showNewsIcon(resultCard);
            } else {
                this.hideShimmer(resultCard);
            }
        }

      // Update image on success
        updateImageSuccess(resultCard, thumbnailUrl) {
            console.log('üîç updateImageSuccess called with:', thumbnailUrl);
            const image = resultCard.querySelector('img.result-image');
            image.style.opacity = '0';
            image.style.transition = 'opacity 0.3s ease-in-out';
            if (!image) return;

            const proxyUrl = `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(thumbnailUrl)}&t=${Date.now()}`;
            console.log('üîç Setting image src to:', proxyUrl);
            let hasRetried = false;

            const handleLoad = () => {
                console.log('‚úÖ Image loaded successfully');

                // Get shimmer element
                const shimmer = resultCard.querySelector('.image-placeholder');

                // Add styling class
                image.classList.add('show');

                // Make image visible but still transparent
                image.style.display = 'block';

                // Handle fade transitions simultaneously
                if (shimmer) {
                    shimmer.style.opacity = '0';
                    shimmer.style.transition = 'opacity 0.3s ease-in-out';

                    setTimeout(() => {
                        shimmer.style.display = 'none';
                    }, 300);
                }

                // Small delay to ensure display:block is applied, then fade in
                setTimeout(() => {
                    image.style.opacity = '1';
                }, 10);

                // Make container visible
                const container = resultCard.querySelector('.img-container');
                if (container) container.style.visibility = 'visible';

                // Set up modal for scraped images  
                const imgWrapper = resultCard.querySelector('.image-wrapper');
                if (imgWrapper && !imgWrapper._hasModalSetup) {
                    setupImageModal(imgWrapper);
                    imgWrapper._hasModalSetup = true;
                }
            };

            const handleError = () => {
                if (!hasRetried) {
                    console.log('üö´ Proxy failed, retrying raw URL:', thumbnailUrl);
                    hasRetried = true;
                    image.src = thumbnailUrl; // Try raw URL without proxy
                } else {
                    console.log('‚ùå Image load error even after retry');
                    this.handleImageFailure(resultCard.dataset.postId, resultCard);
                }
            };

            // Check if image is already cached/loaded
            if (image.complete && image.naturalWidth > 0) {
                handleLoad();
            } else {
                image.addEventListener('load', handleLoad);
                image.addEventListener('error', handleError);
            }

            image.src = proxyUrl; // Start with proxy
        }

        // Show news icon
        showNewsIcon(resultCard) {
            const imgContainer = resultCard.querySelector('.img-container');
            const shimmer = resultCard.querySelector('.image-placeholder');

            if (shimmer) {
                shimmer.classList.add('hide');
                setTimeout(() => shimmer.style.display = 'none', 300);
            }

            if (imgContainer && !imgContainer.querySelector('.news-icon')) {
                showNewsIcon(imgContainer, shimmer); // Your existing function
            }
        }

        // Hide shimmer animation
        hideShimmer(resultCard) {
            const shimmer = resultCard.querySelector('.image-placeholder');
            if (shimmer) {
                shimmer.classList.add('hide');
                setTimeout(() => shimmer.style.display = 'none', 300);
            }
        }

        // API calls
        async getCachedImage(postId) {
            const response = await fetch(`http://localhost:3000/api/get-cached-image/${postId}`);
            return await response.json();
        }

        // Updated scrapeImage function
        async scrapeImage(post) {
            // Skip Reddit domains
            if (this.isRedditDomain(post.url)) {
                console.log(`üö´ Skipping Reddit domain scraping: ${post.url}`);
                return { success: false, message: 'Skipped Reddit domain' };
            }

            const response = await fetch('http://localhost:3000/api/save-image', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    reddit_post_id: post.id,
                    subreddit: post.subreddit,
                    title: post.title,
                    url: post.url,
                    thumbnail: post.thumbnail
                })
            });
            const text = await response.text();
            if (response.ok) {
                return JSON.parse(text);
            } else {
                console.error('Error:', text);
                return { success: false, message: 'Failed' };
            }
        }

        // Update cache
        updateCache(postId, data) {
            window.cachedPostsById = window.cachedPostsById || {};
            window.cachedPostsById[postId] = data;
        }

        // Create link preview for scraped posts
        createLinkPreview(post, resultCard) {
            if (resultCard.querySelector('.link-preview-card')) return;

            const domain = this.getDomainFromUrl(post.url);
            const linkPreview = document.createElement('div');
            linkPreview.className = 'link-preview-card';
            linkPreview.style.position = 'absolute';
            linkPreview.style.opacity = '0'; 
            linkPreview.style.transition = 'opacity 0.2s ease-in-out'; 
            linkPreview.innerHTML = `
        <div class="link-preview-container">
            <span class="link-domain">${domain}</span>
            <a href="${post.url}" target="_blank" rel="noopener noreferrer" class="link-preview-btn">
                Open
            </a>
        </div>
    `;

            const resultAction = resultCard.querySelector('.result-actions');
            if (resultAction) {
                resultAction.after(linkPreview);

                setTimeout(() => {
                    linkPreview.style.opacity = '1';
                }, 10);
            }
        }
    }

    // Add cache management utility function
    function clearExpiredCaches() {
        const now = Date.now();
        const cachePrefix = 'kf_search_';

        // Loop through all localStorage items
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);

            // Only process our cache keys
            if (key && key.startsWith(cachePrefix)) {
                try {
                    const cachedData = JSON.parse(localStorage.getItem(key));

                    // Remove if expired
                    if (now - cachedData.timestamp >= CACHE_DURATION_MS) {
                        localStorage.removeItem(key);
                        console.log('üßπ Removed expired cache:', key);
                    }
                } catch (e) {
                    // If we can't parse it, remove it
                    localStorage.removeItem(key);
                }
            }
        }
    }

    function createAuthorLink(author) {
            const authorLink = document.createElement('a');
            authorLink.className = 'author-link';
            authorLink.href = `https://www.reddit.com/user/${author}`;
            authorLink.target = '_blank';
            authorLink.textContent = `${author}`;
            return authorLink;
    }

    function applyStaggeredAnimation(selector, classToAdd, delayBetween = 30) {
            const elements = document.querySelectorAll(selector);
            elements.forEach((element, index) => {
                setTimeout(() => {
                    requestAnimationFrame(() => {
                        element.classList.add(classToAdd);
                    });
                }, index * delayBetween);
            });
    }

    function showLoading() {
    
        isLoading = true;
        resultsContainer.innerHTML = '';
        resultsContainer.innerHTML = `
    <div class='results-error' id='spinner-box' style="opacity: 0; transition: opacity 0.25s ease;"></div>
`;
            const spinnerWrapper = createCanvasSpinner();
        const spinnerBox = document.getElementById('spinner-box');
        spinnerBox.appendChild(spinnerWrapper);

        // Trigger the fade-in animation
        setTimeout(() => {
            requestAnimationFrame(() => {
                spinnerBox.style.opacity = '1';
            });
        }, 10);

        paginationContainer.innerHTML = '';
        resultsContainer.style.opacity = 1;
    }

    // Function to fetch and cache comments for a post
        async function fetchComments(permalink, commentsContainer, post) {
            const postId = permalink;
            const now = Date.now();

            // Validate permalink first
            if (!permalink || typeof permalink !== 'string' || !permalink.startsWith('/r/')) {
                console.error('‚ùå Invalid permalink provided to fetchComments:', permalink);
                return;
            }

            // Check database for cached comments
            try {
                const cacheResponse = await fetch(`http://localhost:3000/api/get-comments${permalink}`);
                const cacheData = await cacheResponse.json();

                if (cacheData.success && cacheData.cached && cacheData.comments.length > 0) {
                    // console.log(`‚úÖ Using ${cacheData.comments.length} cached comments from database`);

                    // Keep first 15
                    const dbComments = cacheData.comments.slice(0, 8).map(comment => ({
                        author: comment.author,
                        body: comment.body,
                        score: comment.score,
                        created_utc: comment.created_utc
                    }));


                    renderComments({
                        data: {
                            children: dbComments,
                            totalCount: cacheData.comments.length,
                        }
                    }, commentsContainer, permalink, false, post, cacheData.post_total_comments);

                    // Apply the stagger animation
                    requestAnimationFrame(() => {
                        const comments = commentsContainer.querySelectorAll('.comment');
                        comments.forEach((el, i) => {
                            el.classList.remove('visible');
                            setTimeout(() => {
                                el.classList.add('visible');
                            }, i * 60);
                        });
                    });

                    return;
                }
            } catch (error) {
                console.error('Error checking database cache:', error);
            }

            // If no cache, fetch from Reddit
            const fixedPermalink = permalink.endsWith('.json') ? permalink : `${permalink}.json`;
            const commentsUrl = `http://localhost:3000/reddit?url=https://www.reddit.com${fixedPermalink}%3Flimit%3D15`;

            try {
                const response = await fetch(commentsUrl);
                if (!response.ok) {
                    console.log('Failed to fetch comments.');
                    return;
                }

                const data = await response.json();

                // Grab gallery posts while you're at it
                const fullPost = data?.[0]?.data?.children?.[0]?.data;
                // Only patch if it's actually a gallery post with the required data
                if (fullPost && fullPost.is_gallery && fullPost.gallery_data && fullPost.media_metadata) {
                    const resultCard = document.querySelector(`[data-permalink="${permalink}"]`);
                    if (resultCard) {
                        tryGalleryPatch(fullPost, permalink, resultCard);
                    }
                }

                if (!Array.isArray(data) || !data[1]?.data?.children) {
                    console.warn('‚ö†Ô∏è No comments found in response for permalink:', permalink);
                    return;
                }

                const commentsData = data[1].data.children;
                console.log(`üìä Reddit sent ${commentsData.length} items`);

                    function flattenComments(items) {
                    let allComments = [];
                    items.forEach(item => {
                        if (item.kind === 't1' && item.data && item.data.author && item.data.body) {
                            allComments.push(item);
                        }
                        if (item.data && item.data.replies && item.data.replies.data && item.data.replies.data.children) {
                            const nestedComments = flattenComments(item.data.replies.data.children);
                            allComments = allComments.concat(nestedComments);
                        }
                    });
                    return allComments;
                }

                const flattenedComments = flattenComments(commentsData);
                const allComments = flattenedComments
                    .slice(0, 8)  // 8 comments for THIS post
                    .map(c => ({
                        id: c.data.id,
                        author: c.data.author,
                        body: c.data.body,
                        score: c.data.score,
                        created_utc: c.data.created_utc
                    }));
                const reduced = allComments.slice(0, 8);

                // Validate post id to avoid empty strings
                if (!postId || postId.trim() === '') {
                    console.error('Invalid postId for comment cache:', postId);
                    return;
                }

                renderComments({
                    data: {
                        children: reduced,
                        totalCount: commentsData.length
                    }
                }, commentsContainer, permalink, fullPost?.locked || false, fullPost, null); 

                // Save comments to database
                if (allComments.length > 0) {
                    saveCommentsToDatabase(permalink, allComments, fullPost?.num_comments, fullPost?.stickied);
                }

                // Force a paint first ‚Äî delay after .comment elements exist
                requestAnimationFrame(() => {
                    const comments = commentsContainer.querySelectorAll('.comment');
                    comments.forEach((el, i) => {
                        // Just to be safe, reset first
                        el.classList.remove('visible');
                        setTimeout(() => {
                            el.classList.add('visible');
                        }, i * 60); // stagger
                    });
                });

            } catch (error) {
                console.error('‚ùå Fetch error for', permalink, error);
            }
        }

        function saveCommentsToDatabase(permalink, comments, totalComments, isStickied) {
            fetch('http://localhost:3000/api/save-comments', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    permalink: permalink,
                    comments: comments,
                    total_comments: totalComments,
                    is_stickied: isStickied
                })
            })
                .then(res => res.json())
                .then(data => {
                    if (data.success) {
                        console.log(`üíæ Saved ${data.savedCount} comments to database`);
                    }
                })
                .catch(err => console.error('Save comments failed:', err));
        }

    function showError(message) {
        resultsContainer.innerHTML = `
        <div class='results-error'>
            <p>${message}</p>
        </div>
        `;
        resultsContainer.style.opacity = 0;
        applyStaggeredAnimation('.results-error', 'visible', 60);
        paginationContainer.innerHTML = '';

        // Fade in the results container
        setTimeout(() => {
            resultsContainer.style.transition = 'opacity 0.3s ease';
            resultsContainer.style.opacity = 1;
        }, 10);
    }

    function renderComments(data, commentsContainer, permalink, isPostLocked, post, cachedCommentCount) {
    
            // Don't try to access gallery data if this is just comment data
        // Only try gallery patches when we have the actual post data
        if (data?.kind === 'Listing' && data?.data?.children?.[0]?.kind === 't3') {
            // 't3' is the prefix for posts (not comments)
            const fullPost = data?.data?.children?.[0]?.data;
            if (fullPost?.is_gallery && fullPost?.gallery_data && fullPost?.media_metadata) {
                console.log("üì∏ Triggering gallery patch with full metadata:", fullPost);
                const resultCard = document.querySelector(`[data-permalink="${permalink}"]`);
                tryGalleryPatch(fullPost, permalink, resultCard);

            }
        }

        // Parsing data to show if comments locked or no comments found
        const commentsData = data?.data?.children || [];
        const totalCommentsCount = data?.data?.totalCount 

        const isLocked = isPostLocked;

        if (commentsData.length === 0) {
            commentsContainer.innerHTML = `
        <div class="no-comments">
            ${isLocked ? 'Comments have been locked.' : 'No comments found.'}
            ${isLocked ? '<div class="lock-icon"></div>' : ''}
        </div>
        `;
            return;
        }

            // Sort comments by score (highest first)
            commentsData.sort((a, b) => (b.score || 0) - (a.score || 0));
            commentsContainer.innerHTML = '';

            const topComments = commentsData.slice(0, 8);
            topComments.forEach(comment => {
                const c = comment;

                const commentEl = document.createElement('div');
                commentEl.className = 'comment';

                const authorEl = document.createElement('div');
                authorEl.className = 'comment-author';
                const authorIconEl = document.createElement('div');
                authorIconEl.className = 'comment-author-icon';
                authorIconEl.textContent = c.author.charAt(0).toUpperCase();
                authorEl.appendChild(authorIconEl);
                authorEl.appendChild(createAuthorLink(c.author));

                const textEl = document.createElement('div');
                textEl.className = 'comment-text';
                
                textEl.appendChild(renderCommentBody(c.body));

                const metaEl = document.createElement('div');
                metaEl.className = 'comment-meta';
                const scoreEl = document.createElement('span');
                scoreEl.className = 'comment-score';
                scoreEl.textContent = formatNumber(c.score) + ' points';
                const timeEl = document.createElement('span');
                timeEl.className = 'comment-time';
                timeEl.textContent = formatTimestamp(c.created_utc);
                metaEl.appendChild(scoreEl);
                metaEl.appendChild(timeEl);

                commentEl.appendChild(authorEl);
                commentEl.appendChild(textEl);
                commentEl.appendChild(metaEl);
                commentsContainer.appendChild(commentEl);
            });
                // Use comments count from one source
                const actualCommentCount = cachedCommentCount || post?.num_comments || totalCommentsCount;

                // Then change the if statement:
                if (actualCommentCount > 0) { 
                    const seeMoreEl = document.createElement('div');
                    seeMoreEl.className = 'see-more-comments';
                    seeMoreEl.textContent = `See all ${actualCommentCount} comments`; 
                    seeMoreEl.tabIndex = 0;

                    const openLink = () => window.open(`https://www.reddit.com${permalink}`, '_blank');
                        
                    seeMoreEl.addEventListener('click', openLink);
                    seeMoreEl.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            openLink();
                        }
                    });

                    commentsContainer.appendChild(seeMoreEl);
                    
                } else {
                    const seeMoreE2 = document.createElement('div');
                        seeMoreE2.className = 'see-more-comments';
                        seeMoreE2.textContent = `View on Reddit`;
                        seeMoreE2.tabIndex = 0;

                        const openLink = () => window.open(`https://www.reddit.com${permalink}`, '_blank');

                        seeMoreE2.addEventListener('click', openLink);
                        seeMoreE2.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter' || e.key === ' ') {
                                e.preventDefault();
                                openLink();
                            }
                        });

                        commentsContainer.appendChild(seeMoreE2);
            }
    }

    function extractPreviewFromSelftext(selftext) {
        if (!selftext) return null;

        // Look for direct i.redd.it or preview.redd.it URLs
        const mediaRegex = /(https?:\/\/(?:i\.redd\.it|preview\.redd\.it)\/[^\s]+\.(?:gif|jpg|jpeg|png|webp))/i;
        const match = selftext.match(mediaRegex);

        if (match && match[1]) {
            return match[1];
        }
        return null;
    }

    function updatePagination(targetPage = currentPageIndex) {
        const visibleCards = document.querySelectorAll('.result-card:not([style*="display: none"])');

            let prevButton;
            paginationContainer.innerHTML = '';

        // Show prev button if we're not on page 0
        if (currentPageIndex > 0) {
            const prevButton = document.createElement('button');
            prevButton.className = 'pagination-button';
            prevButton.textContent = '‚Üê Previous';
            prevButton.disabled = currentPageIndex === 0;
            prevButton.addEventListener('click', () => {
                if (currentPageIndex === 0) {
                    return;
                }
                const targetPage = navigationHistory[currentPageIndex];
                const prevToken = targetPage.nextBefore;
                currentPageIndex--;
                performSearch(null, prevToken, true, false);
                savePaginationState();
            });
            paginationContainer.appendChild(prevButton);
        }

        if (visibleCards.length < 10) {
            return;
        }
                     
        if (currentAfter) {
            const nextButton = document.createElement('button');
            nextButton.className = 'pagination-button';
            nextButton.textContent = 'Next ‚Üí';
            nextButton.disabled = false;
            nextButton.addEventListener('click', () => {
    
                const tokenToUse = currentAfter;

                currentPageIndex++;

                // Use the saved token explicitly
                performSearch(tokenToUse, null, false);
                savePaginationState();
            });

            paginationContainer.appendChild(nextButton);
        }
    }

    function savePaginationState() {
        sessionStorage.setItem('kf_current_page_index', currentPageIndex);
        sessionStorage.setItem('kf_current_after', currentAfter || '');
        sessionStorage.setItem('kf_current_filters', JSON.stringify(currentFilters));
        sessionStorage.setItem('kf_navigation_history', JSON.stringify(navigationHistory));
    }

    function formatTimestamp(timestamp) {
        const date = new Date(timestamp * 1000);
        const now = new Date();
        const diffSeconds = Math.floor((now - date) / 1000);

        if (diffSeconds < 60) {
            return `${diffSeconds} second${diffSeconds !== 1 ? 's' : ''} ago`;
        }

        const diffMinutes = Math.floor(diffSeconds / 60);
        if (diffMinutes < 60) {
            return `${diffMinutes} minute${diffMinutes !== 1 ? 's' : ''} ago`;
        }

        const diffHours = Math.floor(diffMinutes / 60);
        if (diffHours < 24) {
            return `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
        }

        const diffDays = Math.floor(diffHours / 24);
        if (diffDays < 30) {
            return `${diffDays} day${diffDays !== 1 ? 's' : ''} ago`;
        }

        const diffMonths = Math.floor(diffDays / 30);
        if (diffMonths < 12) {
            return `${diffMonths} month${diffMonths !== 1 ? 's' : ''} ago`;
        }

        const diffYears = Math.floor(diffMonths / 12);
        return `${diffYears} year${diffYears !== 1 ? 's' : ''} ago`;
    }
    
    function toggleThemeMenu() {
        const dropdown = document.getElementById('themeDropdown');
        dropdown.classList.toggle('show');

        // Update active theme when menu opens
        updateActiveTheme();
    }

    function selectTheme(themeName) {
        // Remove dark mode when user clicks a theme button
        document.body.classList.remove('dark-mode');

        applyTheme(themeName);
        document.getElementById('themeDropdown').classList.remove('show');
    }

    function handleThemeKeydown(event, themeName) {
        if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            selectTheme(themeName);
        }
    }

    function updateActiveTheme() {
        // Get current theme from localStorage
        const currentTheme = localStorage.getItem('selectedTheme') || 'default';

        // Remove active class from all options
        const options = document.querySelectorAll('.theme-option');
        options.forEach(option => option.classList.remove('active'));

        // Add active class to current theme
        const activeOption = document.querySelector(`[onclick="selectTheme('${currentTheme}')"]`);
        if (activeOption) {
            activeOption.classList.add('active');
        }
    }

    // Close dropdown when clicking outside
    document.addEventListener('click', function (event) {
        const dropdown = document.getElementById('themeDropdown');
        const themeButton = document.querySelector('.theme-arrow');

        if (dropdown.classList.contains('show') &&
            !dropdown.contains(event.target) &&
            !themeButton.contains(event.target)) {
            dropdown.classList.remove('show');
        }
    });

    // Close on right-click anywhere
    document.addEventListener('contextmenu', function (event) {
        const dropdown = document.getElementById('themeDropdown');
        if (dropdown.classList.contains('show')) {
            dropdown.classList.remove('show');
        }
    });
    
    function formatNumber(num) {
        if (num >= 1000000) {
            return (num / 1000000).toFixed(1) + 'm';
        }
        if (num >= 1000) {
            return (num / 1000).toFixed(1) + 'k';
        }
        return num.toString();
    }

    function getDomainFromUrl(url) {
        try {
            return new URL(url).hostname.replace('www.', '');
        } catch {
            return null;
        }
    }

    // Verification handler
    document.addEventListener('DOMContentLoaded', function () {
        const urlParams = new URLSearchParams(window.location.search);
        const token = urlParams.get('token');
        if (token) {
            // This is a magic link verification
            verifyMagicLink(token);
        }

        // Check for payment success
        if (urlParams.get('success') === 'true') {
            const sessionId = urlParams.get('session_id');

            // Auto-login after successful payment
            fetch('http://localhost:3000/api/auto-login-after-payment', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ session_id: sessionId })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Set login state
                        isLoggedIn = true;
                        localStorage.setItem('isLoggedIn', 'true');
                        localStorage.setItem('userEmail', data.email);
                        localStorage.setItem('hasSubscription', data.hasSubscription);
                        localStorage.setItem('planType', data.planType);
                        localStorage.setItem('userId', data.userId);

                        // Show correct message
                        if (data.planType === 'premium') {
                            alert("Your account has been created. Thank you for unlocking Premium!");
                        } else if (data.planType === 'pro') {
                            alert("Your account has been created. Thank you for unlocking Pro!");
                        }
                        // FETTI TIME!
                        moneyShot();
                        updateLoginButton();
                        showSpeechBubble("It's great value, honest.");
                    }

                    // Clean URL
                    const cleanUrl = window.location.protocol + "//" +
                        window.location.host +
                        window.location.pathname;
                    window.history.replaceState({}, document.title, cleanUrl);
                });
        }
        updatePlanDisplay();
    });

    function moneyShot() {
        // First burst from center
        confetti({
            particleCount: 200,
            spread: 180,
            origin: { x: 0.5, y: 0.5 }
        });

        // Left side burst
        setTimeout(() => {
            confetti({
                particleCount: 150,
                spread: 120,
                origin: { x: 0.1, y: 0.3 }
            });
        }, 200);

        // Right side burst
        setTimeout(() => {
            confetti({
                particleCount: 150,
                spread: 120,
                origin: { x: 0.9, y: 0.3 }
            });
        }, 400);

        // Top corners
        setTimeout(() => {
            confetti({
                particleCount: 100,
                spread: 90,
                origin: { x: 0.2, y: 0.1 }
            });
            confetti({
                particleCount: 100,
                spread: 90,
                origin: { x: 0.8, y: 0.1 }
            });
        }, 600);

        // Final center blast
        setTimeout(() => {
            confetti({
                particleCount: 300,
                spread: 200,
                origin: { x: 0.5, y: 0.6 },
                colors: ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff']
            });
        }, 800);
    }
    
    // Boolean that gets updated
    let isLoggedIn = localStorage.getItem('isLoggedIn') === 'true';

    function updateLoginButton() {
        const btnText = document.getElementById('loginBtnText');
        const btn = document.getElementById('loginLogoutBtn');

        if (isLoggedIn) {
            btnText.textContent = 'Log Out';
            btn.onclick = () => {
                isLoggedIn = false;
                localStorage.setItem('isLoggedIn', 'false');

                // Clear all user data
                clearUserDataOnLogout();

                // Clear bookmarks
                sessionStorage.removeItem('bookmarks');
                document.querySelectorAll('.bookmark-icon').forEach(icon => {
                icon.classList.remove('saved');
                });

                // Reset theme to default when logging out
                localStorage.setItem('theme', 'default');
                applyTheme('default')

                updateLoginButton();

                // Always redirect to main page on logout
                window.location.href = 'karmafinder.html';
            };
        } else {
            btnText.textContent = 'Log In';
            btn.onclick = () => {
                window.location.href = 'login.html';
            };
        }
        updateThemeToggleVisibility();
        updatePlanDisplay();
    }
    
    function updateThemeToggleVisibility() {
        const themeContainer = document.querySelector('.theme-toggle-container');
        if (isLoggedIn) {
            themeContainer.classList.add('visible');
        } else {
            themeContainer.classList.remove('visible');
        }
    }

    function clearUserDataOnLogout() {
        localStorage.removeItem('userEmail');
        localStorage.removeItem('userId');
        localStorage.removeItem('hasSubscription');
        localStorage.removeItem('planType');
        console.log('üßπ Cleared user data from localStorage');
    }

    async function verifyMagicLink(token) {
        try {
            const response = await fetch(`http://localhost:3000/api/auth/verify/${token}`, {
                method: 'POST'
            });
            const data = await response.json();
            if (response.ok) {
                isLoggedIn = true;
                window.stripeCustomerId = data.userId;
                localStorage.setItem('isLoggedIn', 'true');
                localStorage.setItem('userEmail', data.email);
                localStorage.setItem('hasSubscription', data.hasSubscription);
                localStorage.setItem('planType', data.planType);
                localStorage.setItem('userId', data.userId); 

                updateLoginButton();
                const urlParams = new URLSearchParams(window.location.search);
                const redirect = urlParams.get('redirect');
                if (redirect === 'bookmarks') {
                    window.location.href = 'karmafinder.html?page=bookmarks';
                    return;
                }
                window.history.replaceState({}, document.title, window.location.pathname);
                alert('Successfully logged in!');
            } else {
                alert('Invalid or expired magic link');
            }
        } catch (error) {
            alert('Verification failed. Please try again.');
        }
    }

    document.querySelector('.bookmark-link').addEventListener('click', function (e) {
        if (!isLoggedIn) {
            e.preventDefault();
            window.location.href = 'login.html?redirect=bookmarks';
        }
    });

    document.getElementById('getPremiumContainer').onclick = () => {
        window.open('features.html', '_blank');
    };

    function updatePlanDisplay() {
        const isLoggedIn = localStorage.getItem('isLoggedIn') === 'true';
        const getPremiumContainer = document.getElementById('getPremiumContainer');

        if (isLoggedIn) {
            const userEmail = localStorage.getItem('userEmail');

            // Create a simpler endpoint that just takes email as a parameter
            fetch(`http://localhost:3000/api/subscription/${userEmail}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        localStorage.setItem('hasSubscription', data.hasSubscription);
                        localStorage.setItem('planType', data.planType);
                        getPremiumContainer.style.display = 'none';

                        const planDisplayElement = document.getElementById('plan-display');
                        if (data.hasSubscription && data.planType) {
                            const planName = data.planType.charAt(0).toUpperCase() + data.planType.slice(1);
                            planDisplayElement.textContent = `Current Plan: ${planName}`;

                            // Add plan-specific class
                            planDisplayElement.className = `plan-display plan-${data.planType}`; 
                            planDisplayElement.parentElement.classList.add('visible');
                        }
                    }
                })
                .catch(error => {
                    console.error('Error fetching subscription:', error);
                    // Fallback to showing what's in localStorage
                    showFromLocalStorage();
                    getPremiumContainer.style.display = 'none';
                });
        } else {
            const planDisplayElement = document.getElementById('plan-display');
            planDisplayElement.parentElement.classList.remove('visible');
            getPremiumContainer.style.display = 'flex';
        }
    }

    function showFromLocalStorage() {
        const hasSubscription = localStorage.getItem('hasSubscription') === 'true';
        const planType = localStorage.getItem('planType');
        const planDisplayElement = document.getElementById('plan-display');

        if (hasSubscription && planType) {
            const planName = planType.charAt(0).toUpperCase() + planType.slice(1);
            planDisplayElement.textContent = `Current Plan: ${planName}`;
            planDisplayElement.parentElement.classList.add('visible');
        } else {
            planDisplayElement.parentElement.classList.remove('visible');
        }
    }

    // Security function to prevent XSS
    function sanitizeHTML(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    async function getSubredditIcon(subreddit) {
        console.log('üîç getSubredditIcon called with:', subreddit, typeof subreddit);
        
            // Validate subreddit parameter
            if (!subreddit || subreddit === 'undefined' || subreddit === 'null' || typeof subreddit !== 'string') {
                console.warn('‚ö†Ô∏è getSubredditIcon called with invalid subreddit:', subreddit);
                return '/api/placeholder/20/20';
            }

            // Clean and validate subreddit name
            const cleanSubreddit = subreddit.trim();
            if (cleanSubreddit.length === 0) {
                console.warn('‚ö†Ô∏è getSubredditIcon called with empty subreddit');
                return '/api/placeholder/20/20';
            }

            const storageKey = `subreddit_icon_${cleanSubreddit}`;

            // Check if icon is in sessionStorage
            const cachedIcon = sessionStorage.getItem(storageKey);
            if (cachedIcon !== null) {
                if (cachedIcon === 'null') {
                    return '/api/placeholder/20/20';
                }
                return cachedIcon;
            }

        try {
            const response = await fetch(`http://localhost:3000/reddit/icons?subreddits=${encodeURIComponent(cleanSubreddit)}`);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            const data = await response.json();
            const iconUrl = data[cleanSubreddit];
            if (!iconUrl) {
                sessionStorage.setItem(storageKey, 'null');
                return '/api/placeholder/20/20';
            }
            // Save to sessionStorage
            sessionStorage.setItem(storageKey, iconUrl);
            return iconUrl;
        } catch (err) {
            console.error(`‚ùå Failed to fetch icon for r/${cleanSubreddit}:`, err.message);
            sessionStorage.setItem(storageKey, 'null');
            return '/api/placeholder/20/20';
        }
    }

    function tryMediaPatch(fPost, resultCard, attempt = 1) {
            const cacheKey = fPost.url;
            const cached = window.cachedMediaByUrl[cacheKey];

            // üïó If cache isn't ready yet, wait for it
            if (!window.cachedMediaByUrl) {
                console.log(`‚è≥ Waiting for cache to initialize for URL: ${cacheKey}`);
                document.addEventListener('cachedPostsReady', () => {
                    tryMediaPatch(fPost, resultCard, attempt);
                }, { once: true });
                return;
            }

            if (!cached) {
                if (attempt < 10) { // Increased retry attempts
                    setTimeout(() => tryMediaPatch(fPost, resultCard, attempt + 1), 200); // Longer wait
                } else {
                    // console.warn(`‚ö†Ô∏è No cached media found after ${attempt} tries for ${cacheKey}`);
                }
                return;
            }

            // Preserve original URL before overwriting
            if (!fPost.originalUrl) {
                fPost.originalUrl = fPost.url;
            }

            // Patch media fields from cache with safety checks
            fPost.animated = cached.animated !== undefined ? cached.animated : fPost.animated;
            fPost.frame_count = cached.frame_count !== undefined ? cached.frame_count : fPost.frame_count;
            fPost.duration = cached.duration !== undefined ? cached.duration : fPost.duration;
            fPost.url = cached.url || fPost.url;

            const imgContainer = resultCard.querySelector('.img-container');
            const imgWrapper = resultCard.querySelector('.image-wrapper');
            if (!imgContainer || !imgWrapper) return;

            if (imgContainer.style.visibility === 'hidden') {
                imgContainer.style.visibility = 'visible';
            }

            let shimmer = resultCard.querySelector('.image-placeholder');
            if (!shimmer) {
                shimmer = document.createElement('div');
                shimmer.className = 'image-placeholder shimmer';
                imgWrapper.prepend(shimmer);
            } else {
                shimmer.style.display = 'block';
            }

            const fallbackURL = `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(cached.url)}&t=${Date.now()}`;
            const mediaElement = resultCard.querySelector('.result-image');
            if (!mediaElement) {
                console.warn(`‚ùå No media element found for URL key: ${cacheKey}`);
                return;
            }

            // Check if image-wrapper exists, create if missing
            if (!imgWrapper) {
                // Create the missing wrapper structure
                imgWrapper = document.createElement('div');
                imgWrapper.className = 'image-wrapper';
                imgWrapper.style.cursor = 'pointer';

                // Move the image inside the wrapper
                const parent = mediaElement.parentNode;
                parent.insertBefore(imgWrapper, mediaElement);
                imgWrapper.appendChild(mediaElement);
            }

            mediaElement.onerror = () => {
                console.warn(`üö´ Failed to load media for ${cacheKey}, retrying raw URL`);
                mediaElement.src = cached.url;
            };

            mediaElement.onload = () => {
            console.log(`‚úÖ Patched media loaded for ${cacheKey}`);
            shimmer.style.display = 'none';
            mediaElement.classList.add('show');
            };

            mediaElement.src = fallbackURL;

            // Detect media types
            const isGif = mediaElement.src?.toLowerCase().includes('gif');
            const isActuallyAnimated = fPost.animated === true;
            const isVideo = fPost.is_video ||
                (fPost.domain && fPost.domain.includes('youtu')) ||
                (fPost.url && fPost.url.includes('v.redd.it')) ||
                (fPost.domain && fPost.domain.includes('streamable')) ||
                (fPost.url && fPost.url.endsWith('.gifv'));
        }

    function classifyContentType(post) {
        // Text detection first 
        if (post.is_self === true) return 'text';
        if (post.domain && post.domain.startsWith('self.')) return 'text';
        if (post.url && post.url.includes('/comments/')) return 'text';

        // Video detection
        if (post.is_video === true) return 'video';
        const videoDomains = ['youtube.com', 'youtu.be', 'streamable.com', 'twitch.tv', 'vimeo.com', 'gfycat.com', 'v.redd.it', 'redgifs.com'];
        if (post.domain && videoDomains.some(domain => post.domain.includes(domain))) {
            return 'video';
        }

        // Playable/static GIF detection
        const isActuallyAnimated = post.animated === true;
        const isGalleryGif = (
            post.media_metadata &&
            typeof post.media_metadata === 'object' &&
            Object.values(post.media_metadata).some(item => item.e === 'AnimatedImage')
        );
        const isVideo = post.is_video ||
            (post.domain && post.domain.includes('youtu')) ||
            (post.url && post.url.includes('v.redd.it')) ||
            (post.domain && post.domain.includes('streamable')) ||
            (post.domain && post.domain.includes('redgifs.com')) ||
            (post.url && post.url.endsWith('.gifv'));

        // Same condition as play icon: if it would get a play icon, it's "video"
        if (isGalleryGif || (isVideo && !isActuallyAnimated)) {
            return 'video';
        }

        // Picture detection
        if (post.is_gallery === true) return 'image';
        if (post.preview && post.preview.images && post.preview.images.length > 0) return 'image';
        if (post.media_metadata && Object.keys(post.media_metadata).length > 0) return 'image';

        // If it's not i.redd.it and not a video domain, it's probably external/news = image
        if (post.domain && post.domain !== 'i.redd.it' && !videoDomains.some(domain => post.domain.includes(domain))) {
            return 'image';
        }

        return 'text';
    }

    function loadCachedPosts() {
        // Initialize global cache objects if they don't exist
        if (typeof window !== 'undefined') {
            if (!window.cachedPostsById) window.cachedPostsById = {};
            if (!window.cachedMediaByUrl) window.cachedMediaByUrl = {};
        }

        console.log("loadCachedPosts: Cache objects initialized");

        return Promise.resolve();
    }

    function addPlayIconIfNeeded(fPost, resultCard) {
            const imgContainer = resultCard.querySelector('.img-container');
            const mediaElement = resultCard.querySelector('.result-image');
            if (!imgContainer || !mediaElement) return;
            if (imgContainer.querySelector('.play-icon')) return;
            const isGif = fPost.url?.toLowerCase().includes('gif');
            const isActuallyAnimated = fPost.animated === true;
            const isGalleryGif = (
                fPost.media_metadata &&
                typeof fPost.media_metadata === 'object' &&
                Object.values(fPost.media_metadata).some(item => item.e === 'AnimatedImage')
            );
            const isVideo = fPost.is_video ||
                (fPost.domain && fPost.domain.includes('youtu')) ||
                (fPost.url && fPost.url.includes('v.redd.it')) ||
                (fPost.domain && fPost.domain.includes('streamable')) ||
                (fPost.domain && fPost.domain.includes('redgifs.com')) ||
                (fPost.url && fPost.url.endsWith('.gifv'));

            const isImgur = (fPost.url && fPost.url.includes('imgur')) && (fPost.url && fPost.url.endsWith('.gifv')) && isActuallyAnimated;
            // ‚úÖ Show play icon if it's a gallery gif, or if it's a video and not actually animated
            const shouldShowPlayIcon = isGalleryGif || (isVideo && !isActuallyAnimated);
            // console.log('üé¨ shouldShowPlayIcon:', shouldShowPlayIcon, fPost);
            if (shouldShowPlayIcon && !isImgur) {
                const playIcon = document.createElement('div');
                playIcon.className = 'play-icon';
                playIcon.innerHTML = '‚ñ∂';
                imgContainer.appendChild(playIcon);
            }
        }

    let isPopstateEvent = false;

    function updateURL() {
            const params = new URLSearchParams(window.location.search); // Start with existing params

            // Remove old filter params
            params.delete('q');
            params.delete('sub');
            params.delete('type');
            params.delete('sort');
            params.delete('time');
            params.delete('page');

            // Add current filter params
            if (currentFilters.query) params.set('q', currentFilters.query);
            if (currentFilters.subreddit) params.set('sub', currentFilters.subreddit);
            if (currentFilters.contentType && currentFilters.contentType !== 'all') params.set('type', currentFilters.contentType);
            if (currentFilters.sort && currentFilters.sort !== 'hot') params.set('sort', currentFilters.sort);
            if (currentFilters.time && currentFilters.time !== 'all') params.set('time', currentFilters.time);
            if (currentPageIndex > 0) params.set('page', currentPageIndex);

            const newURL = `${window.location.pathname}?${params.toString()}`;

            if (isPopstateEvent) {
                // Don't modify history during popstate
                return;
            } else {
                history.pushState(null, '', newURL);
            }
        }

   function initPage() {
        updateLoginButton();
   
        const isBookmarksPage = window.location.search.includes('page=bookmarks');

        if (!isBookmarksPage) {
            loadCachedPosts();
        }

        const input = document.querySelector('#subreddit-input');
        const dropdown = document.querySelector('.subreddit-suggestions');
        if (input && dropdown) {
            document.addEventListener('mousedown', (e) => {
                if (!input.contains(e.target) && !dropdown.contains(e.target) && !e.target.classList.contains('delete-recent-btn')) {
                    dropdown.classList.remove('active');
                }
            });
            dropdown.addEventListener('click', (e) => {
                const clickedItem = e.target.closest('.subreddit-suggestion');
                if (clickedItem) {
                    input.value = clickedItem.dataset.name || clickedItem.innerText;
                    dropdown.classList.remove('active');
                }
            });
        }

       if (isBookmarksPage) {
           const userId = window.stripeCustomerId;

           // Get section from URL params first
           const urlParams = new URLSearchParams(window.location.search);
           const sectionParam = urlParams.get('section');
           const urlSectionId = sectionParam ? parseInt(sectionParam) : null;

           initializeTabs().then(() => {
               return fetch(`http://localhost:3000/api/sections/${userId}`);
           })
               .then(response => response.json())
               .then(data => {
                   let targetSectionId;

                   if (urlSectionId && data.sections.find(section => section.id === urlSectionId)) {
                       // Use URL section if it exists in the fetched sections
                       targetSectionId = urlSectionId;
                   } else {
                       // Fall back to first section if URL param doesn't exist or is invalid
                       targetSectionId = data.sections[0]?.id;
                   }

                   loadSectionContent(targetSectionId, false);
               });
           return;
       }
       
        const isBackForwardNavigation = performance.navigation
            ? performance.navigation.type === 2
            : performance.getEntriesByType('navigation')[0]?.type === 'back_forward';

        loadPaginationState(isBackForwardNavigation);

        const urlParams = new URLSearchParams(window.location.search);
        const isHomepageFromURL = currentPageIndex === 0 &&
            !urlParams.has('q') &&
            !urlParams.has('sub') &&
            !urlParams.has('sort') &&
            !urlParams.has('time') &&
            !urlParams.has('type');

        if (isHomepageFromURL) {
            console.log("üõéÔ∏è Loading r/all homepage...");
            currentPageIndex = 0;
            currentAfter = null;
            currentBefore = null;
        }

        let initialAfterToken = null;
        let initialBeforeToken = null;

        if (currentPageIndex > 0) {
            if (navigationHistory.length > currentPageIndex - 1) {
                initialAfterToken = navigationHistory[currentPageIndex - 1]?.after || null;
                initialBeforeToken = navigationHistory[currentPageIndex - 1]?.before || null;
                console.log(`üí° On initial load for page index ${currentPageIndex}, using after token: ${initialAfterToken}`);
            } else {
                console.warn(`‚ö†Ô∏è Navigation history too short to load page index ${currentPageIndex}. Falling back to first page.`);
                currentPageIndex = 0;
                initialAfterToken = null;
                initialBeforeToken = null;
            }
        } else {
            console.log(`üí° On initial load for page index 0, fetching without after/before token.`);
        }

        if (window.stripeCustomerId) {
            preloadBookmarks(window.stripeCustomerId, () => {
                performSearch(initialAfterToken, initialBeforeToken, false, true);
            });
        } else {
            performSearch(initialAfterToken, initialBeforeToken, false, true);
        }
    }
 
    // DOM load wrapper
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                initPage();
                loadBlocklist();
            });
        } else {
            initPage();
            loadBlocklist();
        }

    function resetBookmarksState() {
        if (window.location.search.includes('page=bookmarks')) {
            const newUrl = window.location.pathname;
            window.history.replaceState({}, '', newUrl);
            const tabsSection = document.querySelector('.tabs-section');
            if (tabsSection) tabsSection.remove();
        }
    }

    function getYouTubeThumbnail(url) {
        // Extract video ID from various YouTube URL formats
        const match = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/);
        
        if (match && match[1]) {
            const videoId = match[1];
            return `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;
        }
        
        return null;
    }

    function savePostsToDatabase(posts, pageGroupParam) {

        // Only save if there are 10 or more posts
        if (posts.length < 10) {
            console.log(`Skipping save: only ${posts.length} posts (need 10 minimum)`);
            return;
        }
            const pageGroup = pageGroupParam;

            const cleanPosts = posts.map((post, index) => ({
                data: {
                    id: post.data.id,
                    title: post.data.title || '',
                    url: post.data.url || '',
                    permalink: post.data.permalink || '',
                    subreddit: post.data.subreddit || '',
                    score: post.data.score || 0,
                    is_video: Boolean(post.data.is_video),
                    domain: post.data.domain || '',
                    author: post.data.author || '',
                    created_utc: post.data.created_utc || 0,
                    num_comments: post.data.num_comments || 0,
                    over_18: Boolean(post.data.over_18),
                    selftext: post.data.selftext || '',
                    body: post.data.body || '',
                    is_gallery: Boolean(post.data.is_gallery),
                    gallery_data: post.data.gallery_data || null,
                    media_metadata: post.data.media_metadata || null,
                    crosspost_parent_list: post.data.crosspost_parent_list || [],
                    content_type: post.data.content_type || '',
                    icon_url: post.data.icon_url || null,
                    locked: Boolean(post.data.locked),
                    stickied: Boolean(post.data.stickied),
                    preview: post.data.preview || null,
                    position: index
                }
            }));
       
        // Send to server 
        fetch('http://localhost:3000/api/save-posts', {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify({
             posts: cleanPosts,
             page_group: pageGroup 
         })
     })
            .then(res => {
                if (!res.ok) {
                    throw new Error(`Server error: ${res.status}`);
                }
                return res.json();
            })
            .then(data => console.log(`Saved ${data.savedIds?.length || 0} posts`))
            .catch(err => console.error(`Save failed: ${err.message}`));
    }

    function getThumbnailUrl(post) {
    
            // For Reddit videos without preview, construct DASH thumbnail URL
            if (post.is_video && post.url && post.url.includes('v.redd.it')) {
                const cleanUrl = post.url.split('?')[0];
                const videoId = cleanUrl.split('/').pop();
                const dashUrl = `https://v.redd.it/${videoId}/DASH_480.mp4`;
                // console.log('üé¨ Constructing Reddit video thumbnail:', dashUrl);
                // DON'T proxy video files - return direct URL
                return dashUrl;
            }

            // Check if it's a regular thumbnail
            if (post.thumbnail && !['self', 'default', 'nsfw', 'spoiler', 'image'].includes(post.thumbnail.toLowerCase())) {
                return post.thumbnail;
            }

            // Final fallback: use real_thumbnail if available
            if (post.real_thumbnail && !['self', 'default', 'nsfw', 'spoiler', 'image'].includes(post.real_thumbnail.toLowerCase())) {
                return post.real_thumbnail;
            }

            // Check if the URL is a direct link to media
            if (post.url) {
                const mediaExtensions = [
                    '.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.svg',
                    '.mp4', '.webm', '.mov', '.avi', '.mkv', '.m4v'
                ];

                const mediaHosts = [
                    'i.redd.it', 'v.redd.it', 'preview.redd.it',
                    'i.imgur.com', 'media.giphy.com', 'gfycat.com',
                    'streamable.com'
                ];

                const urlLower = post.url.toLowerCase();
                const isDirectMedia = mediaExtensions.some(ext => urlLower.endsWith(ext)) ||
                    mediaHosts.some(host => urlLower.includes(host));

                if (isDirectMedia) {
                    return post.url;
                }
            }

            return null;
        }

    function decodeEntities(input) {
            const txt = document.createElement('textarea');
            txt.innerHTML = input;
            return txt.value;
    }

    function parseMarkdown(text) {
            let processed = text;

        // Headers (h1-h6) - ADD THIS HERE, FIRST!
        processed = processed.replace(/^#{1,6}\s*(.+)$/gm, (match, content) => {
            const level = match.match(/^#+/)[0].length;
            return `<h${level}>${content}</h${level}>`;
        });

        // Bold
        processed = processed.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
        processed = processed.replace(/__(.+?)__/g, '<strong>$1</strong>');

        // Italic - use word boundaries
        processed = processed.replace(/\*([^*]+?)\*/g, '<em>$1</em>');
        processed = processed.replace(/\b_(.+?)_\b/g, '<em>$1</em>');
        
            // Strikethrough (~~text~~)
            processed = processed.replace(/~~([^~]+)~~/g, '<del>$1</del>');

            // Inline code (`code`)
            processed = processed.replace(/`([^`]+)`/g, '<code>$1</code>');

            // Reddit spoilers (>!text!<)
            processed = processed.replace(/>!([^!]+)!</g, '<span class="spoiler">$1</span>');

            // Quotes (lines starting with >)
            processed = processed.replace(/^>\s?(.+)$/gm, '<blockquote>$1</blockquote>');

            // Links with text [text](url)
            processed = processed.replace(/\[([^\]]+)\]\(([^)]+)\)/g,
                '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
            
            // Line breaks (Reddit uses two spaces at end of line or double newline)
                  if (processed.match(/[\[\(][^\]\)]*$/)) {
            processed = processed.replace(/[\[\(][^\]\)]*$/, '...');
        }
            
            processed = processed.replace(/  \n/g, '<br>');
            processed = processed.replace(/\n\n/g, '<br><br>');

            return processed;
    }

   function renderCommentBody(rawBody) {

        const wrapper = document.createElement('div');
        wrapper.className = 'comment-body';
        wrapper.tabIndex = 0;
        wrapper.setAttribute('aria-label', 'Comment content');
            
        // Decode HTML entities
        const txt = document.createElement("textarea");
        txt.innerHTML = rawBody.trim();
        let decoded = txt.value;

        // Check for Reddit images first
        const imageRegex = /(https:\/\/preview\.redd\.it\/[^\s]+?\.(jpeg|jpg|png|gif|webp)(\?[^\s]*)?)/i;
        const imageMatch = decoded.match(imageRegex);

        // Check for different GIF formats
        const giphyRegex = /!\[gif\]\(giphy\|([^|)]+)(?:\|[^)]*)?\)/i;
        const redditGifRegex = /!\[gif\]\(emote\|[^|]*\|([^\)]+)\)/i;
        const directGifRegex = /(https?:\/\/[^\s]+\.gif(\?[^\s]*)?)/i;

        const giphyMatch = decoded.match(giphyRegex);
        const redditGifMatch = decoded.match(redditGifRegex);
        const directGifMatch = decoded.match(directGifRegex);

        if (imageMatch) {
            // Handle Reddit images
            const img = document.createElement('img');
            img.src = imageMatch[1];
            img.alt = 'Image from comment';
            img.style.maxWidth = '100%';
            img.style.borderRadius = '8px';
            wrapper.appendChild(img);
        } else if (giphyMatch) {
            // Handle Giphy GIFs
            const gifId = giphyMatch[1];
            const img = document.createElement('img');
            img.src = `https://media.giphy.com/media/${gifId}/giphy.gif`;
            img.alt = 'GIF from comment';
            img.style.maxWidth = '100%';
            img.style.borderRadius = '8px';
            wrapper.appendChild(img);
        } else if (redditGifMatch) {
            // Handle Reddit native GIFs
            const gifId = redditGifMatch[1];
            const img = document.createElement('img');
            img.src = `https://www.redditstatic.com/desktop2x/img/gold/badges/award-silver-large.png`; // You'll need the actual Reddit gif URL format
            img.alt = 'Reddit GIF from comment';
            img.style.maxWidth = '100%';
            img.style.borderRadius = '8px';
            wrapper.appendChild(img);
        } else if (directGifMatch) {
            // Handle direct GIF URLs
            const img = document.createElement('img');
            img.src = directGifMatch[1];
            img.alt = 'GIF from comment';
            img.style.maxWidth = '100%';
            img.style.borderRadius = '8px';
            wrapper.appendChild(img);
        } else {
            // Parse markdown ONLY for non-image content
            decoded = parseMarkdown(decoded);
            // Handle text content
            const urlRegex = /(https?:\/\/[^\s<]+)/g;
            const lines = decoded.split('\n');
            lines.forEach(line => {
                const lineEl = document.createElement('div');
                if (line.trim().startsWith('>')) {
                    lineEl.className = 'quote';
                    lineEl.textContent = line.replace(/^>\s?/, '');
                } else {
                    // Only process plain URLs if no anchor tags exist
                    if (!line.includes('<a href=')) {
                        line = line.replace(urlRegex, url => {
                            return `<a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`;
                        });
                    }
                    lineEl.innerHTML = line;
                }
                wrapper.appendChild(lineEl);
            });
        }
        return wrapper;
    }

</script>

<script>
    fetch('words.json')
        .then(res => res.json())
        .then(words => {
            // console.log("‚úÖ Word list loaded:", words.length);
            window.englishWords = words;
            setupSearchSuggestions('search-input', 'suggestions', window.englishWords);
        })
        .catch(err => {
            console.error("‚ùå Failed to load word list:", err);
        });
</script>

<script src="themes.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2/dist/fuse.min.js"></script>
<script src="themetoggle.js" defer></script>
<script src="bookmarks.js"></script>

<div class="hermes-context-menu" id="hermesContextMenu">
    <div class="hermes-context-menu-item" id="muteHermes">
        <span class="bell-unmute"></span>
        <span>Mute Hermes</span>
    </div>
    <div class="hermes-context-menu-item" id="toggleAnimations">
        <span class="checkmark">‚úì</span>
        <span>Animations</span>
    </div>
</div>
</body>

</html>