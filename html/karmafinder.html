<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="stylesheet" href="https://cdn.plyr.io/3.7.8/plyr.css" />
    <link rel="stylesheet" href="styles.css" />
    <link rel="stylesheet" href="bookmarks.css">
    <link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon-32x32.png">
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <script src="https://cdn.plyr.io/3.7.8/plyr.polyfilled.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta property="og:title" content="KarmaFinder - Reddit Search Engine">
    <meta name="description"
        content="Search Reddit like Google. Find exactly what you're looking for across any subreddit.">
    <meta name="keywords"
        content="reddit search, reddit finder, search reddit posts, reddit search engine, reddit viewer">
    <meta property="og:description" content="Reddit Search Engine. Find exactly what you're looking for on Reddit">
    <title>KarmaFinder</title>

</head>

<body>

    <script>

        // Theme definitions
        const themes = {
            default: {
                "--primary-color": "#ff4500",
                "--secondary-color": "#0079d3",
                "--background-color": "#f6f6fbf8",
                "--card-color": "#f9fafe",
                "--card-color-b": "#f5f5fa",
                "--input-bg": "#eeedf3",
                "--comments-bg": "#f1f1f6",
                "--suggestions-bg": "#f2f1f7",
                "--text-color": "#1a1a1b",
                "--text-primary": "#15121c",
                "--text-secondary": "#29213b",
                "--light-text": "#787c7e",
                "--meta-text": "#606065",
                "--placeholder-bg": "#f1f1f6",
                "--footie-color": "#a1a1a1",
                "--border-color": "rgb(210, 210, 218)",
                "--border-dark": "rgb(121, 121, 121)",
                "--shadow-light": "rgba(0, 0, 0, 0.1)",
                "--shadow-card": "rgba(0, 0, 0, 0.25)",
                "--inset-shadow": "rgba(88, 88, 88, 0.4)",
                "--hover-bg": "rgb(163, 163, 176)",
                "--hover-bg-lite": "rgb(231, 233, 238)",
                "--button-bg": "#ececf5",
                "--toggle-bg": "#eff1f6",
                "--disabled-opacity": "0.5",
                "--card-radius": "9px",
                "--input-radius": "6px",
                "--container-max-width": "1200px",
                "--image-width": "160px",
                "--bg-image": "none"
            },

            bluebird: {
                "--primary-color": "rgb(255, 30, 64)",
                "--secondary-color": "#4169e1",
                "--background-color": "rgb(221, 239, 255)",
                "--card-color": "rgb(216, 236, 255)",
                "--card-color-b": "#ddeeff",
                "--input-bg": "rgb(193, 228, 255)",
                "--comments-bg": "rgb(195, 227, 255)",
                "--suggestions-bg": "rgb(214, 235, 255)",
                "--text-color": "rgb(2, 12, 111)",
                "--text-primary": "#light-gray",
                "--text-secondary": "#light-gray",
                "--light-text": "#4682b4",
                "--meta-text": "#5691c8",
                "--placeholder-bg": "#cce7ff",
                "--footie-color": "#6fa8dc",
                "--border-color": "rgb(135, 197, 255)",
                "--border-dark": "rgb(67, 155, 242)",
                "--shadow-light": "rgba(30, 144, 255, 0.1)",
                "--shadow-card": "rgba(1, 23, 44, 0.25)",
                "--inset-shadow": "rgba(10, 113, 164, 0.4)",
                "--hover-bg-lite": "rgb(189, 222, 255)",
                "--hover-bg": "rgb(169, 212, 255)",
                "--button-bg": "rgb(189, 224, 255)",
                "--toggle-bg": "rgb(237, 242, 252)",
                "--disabled-opacity": "0.5",
                "--card-radius": "9px",
                "--input-radius": "6px",
                "--container-max-width": "1200px",
                "--image-width": "160px",
                "--bg-image": "none"
            },

            forest: {
                "--primary-color": "rgb(192, 18, 44)",
                "--secondary-color": "rgb(131, 41, 41)",
                "--background-color": "rgb(38, 56, 51)",
                "--card-color": "rgb(11, 31, 27)",
                "--card-color-b": "#1a3d2a",
                "--input-bg": "rgb(27, 33, 32)",
                "--comments-bg": "rgb(19, 50, 42)",
                "--suggestions-bg": "rgb(24, 46, 37)",
                "--text-color": "rgb(164, 237, 236)",
                "--text-primary": "#ffffff",
                "--text-secondary": "#d4eddb",
                "--light-text": "rgb(65, 127, 111)",
                "--meta-text": "#8ab998",
                "--placeholder-bg": "#2f5d41",
                "--footie-color": "#688b75",
                "--border-color": "rgb(48, 84, 76)",
                "--border-dark": "rgb(77, 134, 114)",
                "--shadow-light": "rgba(0, 0, 0, 0.3)",
                "--shadow-card": "rgba(0, 0, 0, 0.5)",
                "--inset-shadow": "var(--border-color)",
                "--hover-bg-lite": "rgb(26, 39, 32)",
                "--button-bg": "rgb(34, 72, 56)",
                "--toggle-bg": "rgb(30, 55, 42)",
                "--disabled-opacity": "0.5",
                "--card-radius": "9px",
                "--input-radius": "6px",
                "--container-max-width": "1200px",
                "--image-width": "160px",
                "--bg-image": "url('../assets/forest.png')",
                "--bg-size": "cover",
                "--bg-position": "center",
                "--bg-repeat": "no-repeat",
                "--github-button svg": "invert(0)"
            },

            dark: {
                "--background-color": "#151416",
                "--card-color": "#202022",
                "--input-bg": "#1c1c1f",
                "--comments-bg": "#2e2e32",
                "--suggestions-bg": "#232326",
                "--text-color": "#f5f5f5",
                "--text-primary": "#ffffff",
                "--text-secondary": "#dadada",
                "--light-text": "#787c7e",
                "--meta-text": "#8a8a91",
                "--placeholder-bg": "#2e2e32",
                "--darkborder": "#3a3a44",
                "--footie-color": "#636363",
                "--border-color": "#333337",
                "--border-dark": "#787b82",
                "--shadow-light": "rgba(0, 0, 0, 0.3)",
                "--hover-bg": "#36363a",
                "--button-bg": "#29292d",
                "--form-bg": "#2e2e32",
                "--form-text": "white",
                "--form-border": "#444"
            }
        };

        // Check for complex themes first - if found, skip dark/light check
        const selectedTheme = localStorage.getItem('selectedTheme');
        const themedark = localStorage.getItem('theme') === 'dark'
        if (selectedTheme && selectedTheme !== 'default' && !themedark) {
            applyTheme(selectedTheme);
        } else {
            // Only do dark/light check if no complex theme is selected
            if (localStorage.getItem('theme') === 'dark') {
                document.body.classList.add('dark-mode');
            }
            if (localStorage.getItem('theme') === 'light') {
                document.body.classList.remove('dark-mode');
            }
        }

        // Unified theme application function
        function applyTheme(themeName) {
            const root = document.documentElement;
            const theme = themes[themeName] || themes.default;

            // Remove all theme classes first
            document.body.classList.remove('forest-theme', 'bluebird-theme', 'default');

            if (themeName === 'dark') {
                document.body.classList.add('dark-mode');
                // Clear any existing CSS variables that might override
                Object.keys(themes.default).forEach(property => {
                    root.style.removeProperty(property);
                });
            } else {
                // Remove dark-mode when changing to other themes
                document.body.classList.remove('dark-mode');
                localStorage.removeItem('theme');
                // For other themes, apply CSS variables to root
                Object.entries(theme).forEach(([property, value]) => {
                    root.style.setProperty(property, value);
                });

                // Add theme class
                if (themeName === 'forest') {
                    document.body.classList.add('forest-theme');
                } else if (themeName === 'bluebird') {
                    document.body.classList.add('bluebird-theme');
                } else {
                    document.body.classList.add('default-theme');
                }
            }

            // Save theme
            localStorage.setItem('selectedTheme', themeName);
        }

        // Global theme functions for UI controls
        window.toggleThemeMenu = function () {
            const dropdown = document.getElementById('themeDropdown');
            dropdown.classList.toggle('show');
            updateActiveTheme();
        }

        window.selectTheme = function (themeName) {
            applyTheme(themeName);
            document.getElementById('themeDropdown').classList.remove('show');
        }

        window.handleThemeKeydown = function (event, themeName) {
            if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                selectTheme(themeName);
            }
        }

        window.updateActiveTheme = function () {
            const currentTheme = localStorage.getItem('selectedTheme') || 'default';
            const options = document.querySelectorAll('.theme-option');
            options.forEach(option => option.classList.remove('active'));

            const activeOption = document.querySelector(`[onclick="selectTheme('${currentTheme}')"]`);
            if (activeOption) {
                activeOption.classList.add('active');
            }
        }

        window.toggleDarkMode = function () {
            const currentTheme = localStorage.getItem('selectedTheme') || 'default';

            if (currentTheme === 'dark') {
                // Go back to saved non-dark theme
                const previousTheme = localStorage.getItem('previousTheme') || 'default';
                applyTheme(previousTheme);
            } else {
                // Save current theme before going to dark
                localStorage.setItem('previousTheme', currentTheme);
                applyTheme('dark');
            }

            // Update icon
            const themeIcon = document.getElementById('themeIcon');
            if (themeIcon) {
                const nowDark = localStorage.getItem('selectedTheme') === 'dark';
                themeIcon.src = nowDark ? '../assets/sun.png' : '../assets/moon.png';
                themeIcon.alt = nowDark ? 'Switch to light mode' : 'Switch to dark mode';
            }
        }

        window.toggleDarkMode = function () {
            const isDark = document.body.classList.toggle('dark-mode');
            localStorage.setItem('theme', isDark ? 'dark' : 'light');

            // Update icon
            const themeIcon = document.getElementById('themeIcon');
            if (themeIcon) {
                themeIcon.src = isDark ? '../assets/sun.png' : '../assets/moon.png';
                themeIcon.alt = isDark ? 'Switch to light mode' : 'Switch to dark mode';
            }
        }

        // DOMContentLoaded setup
        document.addEventListener('DOMContentLoaded', function () {
            // Set up theme toggle if it exists
            const themeToggle = document.getElementById('themeToggle');
            const themeIcon = document.getElementById('themeIcon');

            if (themeToggle) {
                themeToggle.addEventListener('click', toggleDarkMode);
            }

            if (themeIcon) {
                const isDark = document.body.classList.contains('dark-mode');
                themeIcon.src = isDark ? '../assets/sun.png' : '../assets/moon.png';
                themeIcon.alt = isDark ? 'Switch to light mode' : 'Switch to dark mode';
            }
            // Set loaded state
            setTimeout(() => {
                document.body.classList.add('is-loaded');
            }, 100);
        });

        // Load event
        window.addEventListener('load', () => {
            document.body.classList.add('is-loaded');
        });

        window.authToken = localStorage.getItem('authToken');

    </script>

    <a href="https://ko-fi.com/hawaiichair23" target="_blank" class="donate-btn floating-button">
        <img src="https://storage.ko-fi.com/cdn/cup-border.png" alt="Ko-fi"
            style="height: 20px; width: 20px; margin-right: 3px; vertical-align: middle;">
        Support the Site
    </a>
    <div class="theme-toggle-container">
        <button class="theme-arrow" onclick="toggleThemeMenu()" tabindex="2">🎨</button>
        <div class="theme-dropdown" id="themeDropdown">
            <div class="theme-option" onclick="selectTheme('default')" onkeydown="handleThemeKeydown(event, 'default')"
                aria-label="Select Default theme">
                <div class="theme-preview" style="background: linear-gradient(45deg, #ff4500, #ffffff)"></div>
                <span>Default</span>
            </div>
            <div class="theme-option" onclick="selectTheme('bluebird')"
                onkeydown="handleThemeKeydown(event, 'bluebird')" aria-label="Select Bluebird theme">
                <div class="theme-preview" style="background: linear-gradient(45deg, #94cbff, #217eff)"></div>
                <span>Bluebird</span>
            </div>
            <div class="theme-option" onclick="selectTheme('forest')" onkeydown="handleThemeKeydown(event, 'forest')"
                aria-label="Select Forest theme">
                <div class="theme-preview" style="background: linear-gradient(45deg, #007c51, #004b32)"></div>
                <span>Forest</span>
            </div>
        </div>
    </div>
    <div class="get-premium-container" id="getPremiumContainer">
        <div class="get-premium-text">Get Premium ⭐</div>
    </div>
    </div>
    <div class="plan-display-container" tabindex="3">
        <div id="plan-display">Pro</div>
    </div>
    <div class="container">
        <header
            style="display: flex; justify-content: center; align-items: center; position: relative; padding: 0.3rem 0;">
            <div style="text-align: center;">
                <a href="karmafinder.html" class="link-container">
                    <div class="logo">KarmaFinder</div>
                </a>
                <div class="tagline">Find exactly what you're looking for on Reddit 🔎</div>
                <img src="../assets/hermes.png" alt="Hermes Detective Cat" class="hermes-cat">
                <div id="hermes-speech" class="speech-bubble hidden">
                    <div class="speech-tail speech-tail-outline"></div>
                    <div class="speech-tail speech-tail-inner"></div>
                    <div class="speech-text"></div>
                </div>


            </div>
        </header>
        <button id="themeToggle" class="theme-toggle" aria-label="Toggle Dark Mode" tabindex="1">
            <img id="themeIcon" alt="Toggle theme" />
        </button>
        <a href="?page=bookmarks" class="bookmark-link">
            <span class="bookmark-tiny"></span>
            Bookmarks
        </a>
        <button id="loginLogoutBtn" class="login-link">
            <span class="login-icon login-icon-image"></span>
            <span id="loginBtnText">Log In</span>
        </button>
        <div class="search-container">

            <div class="search-top-row">

                <div class="toggle-group">
                    <div class="toggle-wrapper">
                        <label class="switch">
                            <input type="checkbox" id="toggle1" />
                            <span class="slider" tabindex="0"></span>
                        </label>
                        <span class="toggle-label" tabindex="0">✨ Enhanced Search</span>
                    </div>

                    <div class="toggle-wrapper">
                        <label class="switch">
                            <input type="checkbox" id="toggle2" />
                            <span class="slider" tabindex="0"></span>
                        </label>
                        <span class="toggle-label" tabindex="0">Reddit Search</span>
                    </div>
                </div>

                <div class="search-input-container">
                    <svg class="search-icon" width="22" height="22" viewBox="0 0 24 24" fill="none">
                        <circle cx="10" cy="10" r="7" stroke="currentColor" stroke-width="2" fill="none" />
                        <path d="m15.8 15.8 4.2 4.2" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
                    </svg>
                    <input type="text" id="search-input" class="search-input" placeholder="Search Reddit">
                    <div id="suggestions"></div>
                    <button id="search-button" class="search-button"></button>
                </div>
                <img src="../assets/iconny thingy.png" alt="filter icon" id="filter-icon" />
                <button id="comfy-toggle" aria-label="Toggle Comfy Mode" tabindex="0">
                    <img src="../assets/comfy-default.png" alt="Toggle comfy layout" />
                </button>
                <button id="compact-toggle" aria-label="Toggle Compact Mode" tabindex="0">
                    <img src="../assets/compact-default.png" alt="Toggle compact layout" />
                </button>
            </div>

            <div class="advanced-options">
                <div class="option-group">
                    <label for="sort-select">Sort By</label>
                    <select id="sort-select">
                        <option value="hot">Hot</option>
                        <option value="top">Top</option>
                        <option value="new">New</option>
                        <option value="relevance">Relevance</option>
                    </select>
                </div>

                <div class="option-group">
                    <label for="time-select">Time Period</label>
                    <select id="time-select">
                        <option value="all">All Time</option>
                        <option value="year">Past Year</option>
                        <option value="month">Past Month</option>
                        <option value="week">Past Week</option>
                        <option value="day">Past 24 Hours</option>
                        <option value="hour">Past Hour</option>
                    </select>

                </div>
                <div class="option-group">
                    <label for="safesearch-select">SafeSearch</label>
                    <select id="safesearch-select">
                        <option value="on">On</option>
                        <option value="off">Off</option>
                    </select>
                </div>

                <div class="option-group subreddit-dropdown">
                    <label for="subreddit-input">Subreddit (optional)</label>
                    <input type="text" id="subreddit-input" placeholder="e.g., AskReddit">
                    <div id="subreddit-suggestions-container">
                        <div id="subreddit-suggestions" class="subreddit-suggestions"></div>
                    </div>
                    <div class="filter-chip-container" id="subreddit-chip-container">
                        <span class="chip-text"></span>
                        <span class="remove-chip">×</span>
                    </div>
                </div>

                <div class="option-group">
                    <label for="content-select">Content Type</label>
                    <select id="content-select">
                        <option value="all">All Content</option>
                        <option value="video">Video Posts Only</option>
                        <option value="image">Picture Posts Only</option>
                        <option value="text">Text Posts Only</option>
                    </select>
                </div>
            </div>
        </div>

        <div id="results" class="results-container">
        </div>

        <div id="pagination" class="pagination">
        </div>
        <footer>
            <p>KarmaFinder is an independent search utility and is not affiliated with Reddit Inc.</p>
            <br>
            <a href="https://github.com/hawaiichair23/KarmaFinder" class="github-button" id="button" target="_blank"
                rel="noopener noreferrer">
                <svg width="24" height="24" viewBox="0 0 16 16" fill="white" alt="Github">
                    <path
                        d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z" />
                </svg>
                Github</a>
            <br>
            <br>
            <p class="footie" tabindex="0">Made by hawaiichair23</p>
        </footer>
    </div>

    <script>

        // SEVEN MINUTES. SEVEN MINUTES IS ALL I CAN SPARE TO PLAY WITH YOU.
        const CACHE_DURATION_MS = 7 * 60 * 1000;

        // Configuration 
        const IMAGE_PROXY_BASE = location.hostname === 'localhost'
            ? 'http://localhost:3000'
            : 'https://karmafinder.onrender.com';

        const API_BASE = location.hostname === 'localhost'
            ? 'http://localhost:3000'
            : 'https://karmafinder.site';

        let searchTimeout = null;

        function preloadBookmarks(callback) {
            const authToken = getAuthToken();

            if (!authToken) {
                sessionStorage.removeItem('bookmarks');
                document.querySelectorAll('.bookmark-icon').forEach(icon => {
                    icon.classList.remove('saved');
                });
                if (callback) callback();
                return;
            }

            fetch(`${API_BASE}/api/bookmarks?limit=1000`, {
                headers: {
                    'Authorization': authToken
                }
            })
                .then(res => res.json())
                .then(data => {
                    const bookmarks = {};
                    data.bookmarks.forEach(post => {
                        bookmarks[post.reddit_post_id] = true;
                    });

                    sessionStorage.setItem('bookmarks', JSON.stringify(bookmarks));

                    // Apply bookmarks to any currently rendered icons
                    document.querySelectorAll('.bookmark-icon').forEach(icon => {
                        const postId = icon.dataset.postId;
                        if (bookmarks[postId]) {
                            icon.classList.add('saved');
                        } else {
                            icon.classList.remove('saved');
                        }
                    });

                    if (callback) callback();
                })
                .catch(err => {
                    console.error('❌ Failed to preload bookmarks:', err);
                    if (callback) callback();
                });
        }

        // DOM Elements
        const searchInput = document.getElementById('search-input');
        const suggestionsDiv = document.getElementById('suggestions');
        const searchButton = document.getElementById('search-button');
        const sortSelect = document.getElementById('sort-select');
        const timeSelect = document.getElementById('time-select');
        const subredditInput = document.getElementById('subreddit-input');
        const contentSelect = document.getElementById('content-select');
        const resultsContainer = document.getElementById('results');
        const paginationContainer = document.getElementById('pagination');
        const subredditSuggestions = document.getElementById('subreddit-suggestions');
        const subredditChipContainer = document.getElementById('subreddit-chip-container');
        const dropdown = document.getElementById('subreddit-suggestions');

        // State
        const savedCommentCache = localStorage.getItem('commentCache');
        const commentCache = savedCommentCache ? JSON.parse(savedCommentCache) : {};

        window.cachedMediaByUrl = {};

        let activeQueryToken = 0;
        let cachedPostsById = {};
        let pendingCatReaction = null;
        let bannedSubreddits = [];
        let isScrambled = false;
        let searchCount = parseInt(localStorage.getItem('searchCount')) || 0;
        let currentPageIndex = 0;
        let lastQuery = "";
        let isTalking = false;
        let mouthTimeout;
        let hermesLineCount = 0;
        let currentVectorResults = [];
        let currentVectorOffset = 0;
        let hasMoreVectorResults = false;
        let vectorScrollHandler = null;
        let isVectorLoading = false;
        let currentAfter = null;
        let currentBefore = null;
        let isLoading = false;
        let currentFilters = {
            sort: 'hot',
            time: 'all',
            subreddit: '',
        };

        // Data for html injection
        if (window.preloadedSearchData && window.preloadedQuery !== undefined) {

            // Set the search input
            searchInput.value = window.preloadedQuery;

            // Set the subreddit if one was preloaded
            if (window.preloadedSubreddit) {

                const subredditInput = document.getElementById('subreddit-input');
                if (subredditInput) {
                    subredditInput.value = window.preloadedSubreddit;
                }
            }

            // Process the data the same way performSearch does
            const data = window.preloadedSearchData;
            currentAfter = data.data.after || null;
            currentBefore = data.data.before || null;

            // Trim the data
            const trimmedData = data.data.children.map(post => trimRedditPostData(post));

            displayResults(trimmedData);
            preloadBookmarks();
            updatePagination();

            // Clean up
            delete window.preloadedSearchData;
            delete window.preloadedQuery;
            delete window.preloadedSubreddit;
        }

        // Load Blocklist 
        async function loadBlocklist() {
            try {
                const response = await fetch('./blocklist.json');
                const data = await response.json();
                bannedSubreddits = data.bannedSubreddits;
            } catch (error) {
                console.warn('No blocklist found');
            }
        }

        function updateSubredditChip(sub) {
            const chipContainer = document.querySelector('.chip-container');
            if (!chipContainer) return;

            chipContainer.innerHTML = '';

            // Only show if it's not "all" or empty
            if (sub && sub !== 'all') {
                const chip = document.createElement('div');
                chip.className = 'chip';
                chip.textContent = sub;
                chipContainer.appendChild(chip);
            }
        }

        function restoreToggleStates() {
            const toggle1 = document.getElementById('toggle1');
            const toggle2 = document.getElementById('toggle2');
            const savedToggle1 = sessionStorage.getItem('toggle1State');
            const savedToggle2 = sessionStorage.getItem('toggle2State');

            if (savedToggle1 !== null) toggle1.checked = savedToggle1 === 'true';
            if (savedToggle2 !== null) toggle2.checked = savedToggle2 === 'true';

            // Re-run logic to reflect the change visually
            const toggleManager = new ToggleManager();
            toggleManager.validateState();
            toggleManager.updateSortDropdown();
        }

        function loadPaginationState() {
            const params = new URLSearchParams(window.location.search);
            const pageIndex = parseInt(params.get('page'), 10);
            currentPageIndex = isNaN(pageIndex) ? 0 : pageIndex;
            currentAfter = params.get('after') || null;
            currentBefore = params.get('before') || null;
        }



    window.addEventListener('popstate', () => {
        //console.log('✅ popstate fired');
        //console.log('🌍 current URL during popstate:', window.location.href);
    });
    window.addEventListener('DOMContentLoaded', () => {
        //console.log('📥 DOMContentLoaded fired');
    });
        window.addEventListener('popstate', () => {
                setTimeout(() => {
                    const urlParams = new URLSearchParams(window.location.search);
                    const isBookmarksPage = urlParams.get('page') === 'bookmarks';

                    if (isBookmarksPage) {
                        const sectionId = parseInt(urlParams.get('section') || '1', 10);
                        //console.log('🔁 Restoring bookmarks page to section', sectionId);
                        isLoading = false;
                        //console.log("SECTION ID FROM MOOKBARK", sectionId)
         
                            loadSectionContent(sectionId, false, true); // Pass true for fromPopstate

                        initializeTabs();
                        // Visually activate the corresponding tab
                        document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                        const activeTab = document.querySelector(`.tab[data-tab-id="${sectionId}"]`);
                        if (activeTab) {
                            activeTab.classList.add('active');
                        }

                        return;
                    }

                    // ✅ This is the original behavior for search/home
                    isPopstateEvent = true;

                    applyFiltersToUI(getFiltersFromURL());
                    restoreToggleStates();
                    loadPaginationState('refresh');

                    const cachedPage = loadPageDataFromSession(currentPageIndex);

                    if (cachedPage?.results?.length) {
                        //console.log('🧭 Restoring page from popstate cache:', currentPageIndex);

                        currentAfter = cachedPage.after || null;
                        currentBefore = cachedPage.before || null;

                        if (typeof cachedPage.toggle1 === 'boolean') {
                            document.getElementById('toggle1').checked = cachedPage.toggle1;
                            document.getElementById('toggle2').checked = cachedPage.toggle2;
                            toggleManager.updateSortDropdown();
                        }

                        displayResults(cachedPage.results);
                        preloadBookmarks(window.stripeCustomerId);
                        updatePagination();
                        setTimeout(() => window.scrollTo(0, 0), 0);
                    } else {
                        handleSearchRequest(null, null, true, true);
                    }

                    isPopstateEvent = false;
                }, 0);
            });







        let animationsEnabled = true;
        let isSleeping = false;
        let blinkTimer1, blinkTimer2, blinkTimer3;
        let sleepTimer;

        // Single blink (e.g., on mouseover)
        function singleBlink() {
            if (!animationsEnabled || isSleeping) return;

            const img = document.querySelector('.hermes-cat');
            img.src = '../assets/hermes-blink.png';
            setTimeout(() => {
                if (!isSleeping) img.src = '../assets/hermes.png';
            }, 150);
        }

        // Random automatic blinking
        function randomBlink() {
            if (!animationsEnabled || isSleeping) return;

            const img = document.querySelector('.hermes-cat');

            // First blink
            img.src = '../assets/hermes-blink.png';
            setTimeout(() => {
                if (!isSleeping) img.src = '../assets/hermes.png';
            }, 150);

            // Random delay between double blinks (500–2000ms)
            const delayBetween = Math.random() * 1500 + 500;
            blinkTimer1 = setTimeout(() => {
                if (!isSleeping) {
                    img.src = '../assets/hermes-blink.png';
                    setTimeout(() => {
                        if (!isSleeping) img.src = '../assets/hermes.png';
                    }, 150);
                }
            }, delayBetween);

            // Random delay until next double blink (5–13 seconds)
            const nextBlink = Math.random() * 8000 + 5000;
            blinkTimer2 = setTimeout(randomBlink, nextBlink);
        }

        // Start automatic blinking when page loads
        randomBlink();

        // Mouseover triggers a single blink
        document.querySelector('.hermes-cat').addEventListener('mouseover', singleBlink);

        // Sleep timer logic: go to sleep after inactivity
        function resetSleepTimer() {
            clearTimeout(sleepTimer);

            if (isSleeping) wakeUp();

            sleepTimer = setTimeout(() => {
                if (!isSleeping) startSleeping();
            }, 60000); // 60 seconds 
        }

        // Start sleep
        function startSleeping() {
            isSleeping = true;
            // Clear all blink timers
            clearTimeout(blinkTimer1);
            clearTimeout(blinkTimer2);
            clearTimeout(blinkTimer3);

            // Start the repeated slow Zzz...
            loopZzz();

            sleepAnimation();
        }

        function loopZzz() {
            if (!isSleeping) return;

            const bubble = document.getElementById('hermes-speech');
            const textElement = bubble.querySelector('.speech-text');
            bubble.classList.remove('hidden');
            typewriterEffect(textElement, "Zzz...", 600);

            // After it finishes, call again
            setTimeout(loopZzz, "Zzz...".length * 600 + 1000);
        }

        // Wake up
        function wakeUp() {
            isSleeping = false;
            const img = document.querySelector('.hermes-cat');
            img.src = '../assets/hermes.png';

            // Hide speech bubble
            const bubble = document.getElementById('hermes-speech');
            bubble.classList.add('hidden');

            // Restart normal blinking
            randomBlink();
        }


        // Sleep animation (head bobbing loop)
        function sleepAnimation() {
            if (!animationsEnabled || !isSleeping) return;

            const img = document.querySelector('.hermes-cat');

            // Step 1: start from normal closed eyes
            img.src = '../assets/hermes-blink.png';

            // Falling down part (accelerating)
            setTimeout(() => {
                img.src = '../assets/hermes-sleep2.png';
            }, 400); // quick

            setTimeout(() => {
                img.src = '../assets/hermes-sleep3.png';
            }, 800); // still quick

            setTimeout(() => {
                img.src = '../assets/hermes-sleep4.png';
            }, 1300); // a bit slower

            // Rising up part (decelerating)
            setTimeout(() => {
                img.src = '../assets/hermes-sleep3.png';
            }, 1900); // slower

            setTimeout(() => {
                img.src = '../assets/hermes-sleep2.png';
            }, 2500); // even slower

            setTimeout(() => {
                img.src = '../assets/hermes-blink.png';
                // Loop again if still sleeping
                if (isSleeping) {
                    setTimeout(sleepAnimation, 800); // pause before repeating
                }
            }, 3200); // final slow return to top
        }

        // Activity resets sleep timer
        ['mousemove', 'keypress', 'click', 'scroll'].forEach(event =>
            document.addEventListener(event, resetSleepTimer)
        );

        // Start sleep timer on page load
        resetSleepTimer();

        let currentTypewriterTimeout;

        function typewriterEffect(element, text, speed = 50) {
            if (!animationsEnabled) {
                // Just show the text instantly
                element.textContent = text;
                return;
            }
            // Only clear existing typewriter 80% of the time
            if (Math.random() < 0.80) {
                clearTimeout(currentTypewriterTimeout);
            }

            element.textContent = '';
            let i = 0;
            function typeChar() {
                if (i < text.length) {
                    element.textContent += text.charAt(i);
                    i++;
                    currentTypewriterTimeout = setTimeout(typeChar, speed);
                }
            }
            typeChar();
        }

        function showSpeechBubble(messages) {
            const bubble = document.getElementById('hermes-speech');
            const textElement = bubble.querySelector('.speech-text');
            const message = Array.isArray(messages) ?
                messages[Math.floor(Math.random() * messages.length)] : messages;

            // Early return for mute toggle
            if (!hermesEnabled) return;

            if (message.length > 27) {
                let cutPoint = 27;
                // Find the last space before the limit
                while (cutPoint > 0 && message[cutPoint] !== ' ') {
                    cutPoint--;
                }
                // If no space found, fall back to character limit
                if (cutPoint === 0) cutPoint = 27;

                const firstPart = message.substring(0, cutPoint);
                const remainingPart = message.substring(cutPoint + 1);

                // Show first part
                bubble.classList.remove('hidden');
                startTalking();
                typewriterEffect(textElement, firstPart, 50);

                // After first part finishes, call showSpeechBubble again for remaining part, splitting again
                setTimeout(() => {
                    stopTalking();
                    hideSpeechBubble();
                    showSpeechBubble(remainingPart); // This will re-check the 27 char limit
                }, firstPart.length * 50 + 700);
                return;
            }

            // Normal case
            bubble.classList.remove('hidden');
            startTalking();
            typewriterEffect(textElement, message, 50);
            setTimeout(() => stopTalking(), message.length * 50 + 700);
        }

        function startTalking() {

            isTalking = true;
            mouthMovement();
        }

        function mouthMovement() {
            if (!isTalking || !animationsEnabled) return;

            const img = document.querySelector('.hermes-cat');

            // Open mouth
            img.src = '../assets/hermes-mouthopen.png';

            // Mouth open duration
            const openDuration = Math.random() * 90 + 150;

            setTimeout(() => {
                if (!isTalking) return;

                // Close mouth
                img.src = '../assets/hermes.png';

                // Mouth closed duration
                const closedDuration = Math.random() * 50 + 60;

                // Continue the cycle
                mouthTimeout = setTimeout(mouthMovement, closedDuration);
            }, openDuration);
        }

        function stopTalking() {
            isTalking = false;
            clearTimeout(mouthTimeout);

            // Make sure mouth is closed
            const img = document.querySelector('.hermes-cat');
            img.src = '../assets/hermes.png';
        }

        function hideSpeechBubble() {
            const bubble = document.getElementById('hermes-speech');
            bubble.classList.add('hidden');
        }

        let clickCount = 0;
        let firstClickTime = 0;
        let isBlocked = false;

        function scrambleYeller() {
            const now = Date.now();
            if (now - firstClickTime > 2000) {
                clickCount = 0;
                firstClickTime = now;
            }
            clickCount++;
            if (clickCount >= 5) {
                isScrambled = true; // Set blocked state

                showSpeechBubble([
                    "YOU KNOW I GET SCRAMBLED!",
                    "STOP!",
                    "GOOD GRIEF!",
                    "ONE AT A TIME."
                ]);

                setTimeout(() => {
                    isScrambled = false; // Unblock after 2.5 seconds
                    clickCount = 0;
                }, 2500);

                return true;
            }
            return isScrambled || false;
        }

        async function showRareLines() {
            try {
                const response = await fetch(`${API_BASE}/api/rare-line`);
                const data = await response.json();

                if (data.line) {
                    clearTimeout(currentTypewriterTimeout);
                    showSpeechBubble(data.line);
                } else if (data.sequential) {
                    // Show 5-7
                    showSpeechBubble(data.sequential[0]);
                    setTimeout(() => {
                        showSpeechBubble(data.sequential[1]);
                        setTimeout(() => {
                            showSpeechBubble(data.sequential[2]);
                        }, 3000); // 3 seconds
                    }, 31000); // 31
                }
            } catch (error) {
                console.error('Error fetching rare line:', error);
            }
        }

        let hermesEnabled = true;
        let blinkTimeout;

        document.querySelector('.hermes-cat').addEventListener('contextmenu', function (e) {
            e.preventDefault();

            const menu = document.getElementById('hermesContextMenu');
            menu.style.display = 'block';
            menu.style.left = e.pageX + 'px';
            menu.style.top = e.pageY + 'px';
        });

        // Hide context menu when clicking elsewhere
        document.addEventListener('click', function () {
            document.getElementById('hermesContextMenu').style.display = 'none';
        });

        // Hide context menu when right-clicking elsewhere
        document.addEventListener('contextmenu', function (e) {
            // Only hide if the right-click is NOT on the hermes cat
            if (!e.target.closest('.hermes-cat')) {
                document.getElementById('hermesContextMenu').style.display = 'none';
            }
        });





        // ANIMATIONS TOGGLE WITH LOCALSTORAGE
        document.addEventListener('DOMContentLoaded', function () {
            // Initialize toggle system
            const toggleManager = new ToggleManager();
            const muteBtn = document.getElementById('muteHermes');
            const animBtn = document.getElementById('toggleAnimations');

            // Load saved settings or use defaults
            hermesEnabled = localStorage.getItem('hermesEnabled') !== 'false'; // default true
            animationsEnabled = localStorage.getItem('animationsEnabled') !== 'false'; // default true

            function playGreeting() {
                if (!hermesEnabled) return;
                setTimeout(() => { showSpeechBubble("Welcome back."); }, 350);
            }

            // Handle first visit greeting
            if (!sessionStorage.getItem('hasVisited')) {
                playGreeting();
                sessionStorage.setItem('hasVisited', 'true');
            }

            // Apply saved settings on page load
            function applySavedSettings() {
                // Apply hermes/bell setting
                const bellElement = muteBtn.querySelector('.bell, .bell-unmute');
                if (bellElement) {
                    bellElement.classList.toggle('bell', !hermesEnabled);
                    bellElement.classList.toggle('bell-unmute', hermesEnabled);
                }

                // Apply animations setting
                const checkmark = animBtn.querySelector('.checkmark');
                if (checkmark) {
                    checkmark.style.visibility = animationsEnabled ? 'visible' : 'hidden';
                }

                const catImg = document.querySelector('.hermes-cat');
                if (!animationsEnabled) {
                    clearTimeout(blinkTimeout);
                    clearTimeout(mouthTimeout);
                    if (catImg) catImg.src = '../assets/hermes.png';
                } else {
                    randomBlink?.();
                }

                if (!hermesEnabled) {
                    hideSpeechBubble?.();
                    stopTalking?.();
                }
            }

            // Apply settings immediately
            applySavedSettings();

            // Hermes toggle
            muteBtn.addEventListener('click', function () {
                hermesEnabled = !hermesEnabled;
                localStorage.setItem('hermesEnabled', hermesEnabled);

                const bellElement = this.querySelector('.bell, .bell-unmute');
                if (bellElement) {
                    bellElement.classList.toggle('bell');
                    bellElement.classList.toggle('bell-unmute');
                }
                if (!hermesEnabled) {
                    hideSpeechBubble?.();
                    stopTalking?.();
                }
            });

            // Animations toggle
            animBtn.addEventListener('click', function () {
                animationsEnabled = !animationsEnabled;
                localStorage.setItem('animationsEnabled', animationsEnabled);

                const checkmark = this.querySelector('.checkmark');
                checkmark.style.visibility = animationsEnabled ? 'visible' : 'hidden';
                const catImg = document.querySelector('.hermes-cat');
                if (!animationsEnabled) {
                    clearTimeout(blinkTimeout);
                    clearTimeout(mouthTimeout);
                    if (catImg) catImg.src = '../assets/hermes.png';
                } else {
                    randomBlink?.();
                }
            });
        });

        function handleRandomResponse(responses, nothingChance = 0.5, dotsChance = 0.08) {
            const randomChance = Math.random();
            const dotsThreshold = nothingChance + dotsChance;
            if (randomChance < nothingChance) {
                // Nothing happens
                hideSpeechBubble();
                stopTalking();
                return true;
            } else if (randomChance < dotsThreshold) {
                // Show dots
                showSpeechBubble("...");
                stopTalking();
                return true;
            } else {
                // Show random message from array
                showSpeechBubble(responses);
                return true;
            }
        }

        function getCatReactionForSubreddit(input, isSubreddit = false) {
            if (isSubreddit) {
                const reactions = {
                    'amitheasshole': ["My cousin ended up on there once.", "I know you are, but what am I?"],
                    'gonewild': ["My cousin ended up on there once."],
                    'carsfuckingdragons': ["Touch grass.", "Oh.", "Uhh..."],
                    'anime_irl': ["Touch grass.", "Uhh...", "Oh."],
                    'newjersey': ['The Garden State.'],
                    'npr': ['I think about Car Talk every day.'],
                    'grilling': ["You should look up uhh, uh, Bratwurst. On a Weber Ranch.", "Hardwood lump charcoal or don't bother."],
                    'traeger': ["I always used a Weber myself."],
                    'mac': ["I've never understood the price point on these things."],
                    'ipad': ["I've never understood the price point on these things."],
                    'ipadpro': ["I've never understood the price point on these things."],
                    'booksuggestions': ["Kitchen Confidential.", "I suggest The Maltese Falcon.", "How to Win Friends and Influence People.", "The Gift of Fear. Check it out."],
                    'suggestmeabook': ["Kitchen Confidential.", "I suggest The Maltese Falcon.", "How to Win Friends and Influence People.", "The Gift of Fear. Check it out."],
                    'electricvehicles': ["Been thinking about an EV myself."],
                    'bettercallsaul': ["He defecated through a sunroof!", "Showtime.", "I KNEW IT WAS 1216! ONE AFTER MAGNA CARTA", "I AM NOT CRAZY! I am not crazy! I know he swapped those numbers!"],
                    'okbuddychicanery': ["He defecated through a sunroof!", "Showtime.", "I KNEW IT WAS 1216! ONE AFTER MAGNA CARTA", "I AM NOT CRAZY! I am not crazy! I know he swapped those numbers!", "Kid named Finger:"],
                    'breakingbadmemes': ["Kid named Finger:"],
                    'mensfashion': ["Every man needs a trilby."],
                    'classicalmusic': ["Peter and the Wolf, Op. 67.", "Daphnis et Chloe - Ravel.", "You can't go wrong with The Planets Suite."],
                    'mario': ["Do you think they took Diddy Kong out of the new game because of... the allegations?"],
                    'mariokart': ["Do you think they took Diddy Kong out of the new game because of... the allegations?"],
                    'mariokartworld': ["Do you think they took Diddy Kong out of the new game because of... the allegations?"],
                    'oneorangebraincell': ["Tell me about it."],
                    'moviedetails': ["You know, Viggo really broke his toe when he kicked the helmet.", "The cat in the scene with the Don, it just wandered in the set, I heard."],
                    'marvelmemes': ["That just happened.", "He's... right behind me, isn't he?"],
                    'marvel': ["Iron Man is the best one. Fight me."],
                    'stopsmoking': ["I went back to the old toothpick method myself.", "Apple a day to balance it out, amiright?"],
                    'okbuddyarkham': ["Man...", "Officer Boals. I knew him."],
                    'batmanarkham': ["Man...", "Officer Boals. I knew him."],
                    'historyporn': ["You know, everyone thinks the Berlin Wall was Reagan... I was there. It was a bureaucratic screwup.", "Uh, do you ever listen to Hardcore History. There was a cult in Germany in that town that's named after cheese. Yeah it was a cult."],
                    'history': ["You know, everyone thinks the Berlin Wall was Reagan... I was there. It was a bureaucratic screwup.", "Uh, do you ever listen to Hardcore History. There was a cult in Germany in that town that's named after cheese. Yeah it was a cult."],
                    'thesopranos': ["How about that prick's face when he saw the gat?", "Gandolfini based Tony on a guy he knew in Jersey. Real guy."],
                    'thesopranos_memes': ["How about that prick's face when he saw the gat?"],
                    'buyitforlife': ["One word. Air. Fryer. That's two words. I never use my oven now.", "Get you a good blender. It'll make you soups, too."],
                    'lego': ["My kids love those. My wallet, not so much."],
                    'educationalgifs': ["Look up the Chernobyl, uh, reactor containment.", "Don't look up MRI of person speaking. That is disgusting."],
                    'marvelrivals': ["I don't do those team fighter games. Besides CS Go."],
                    'overwatch': ["I don't do those team fighter games. Besides CS Go."],
                    'steamdeck': ["Good processing power.", "Civ 5 is the best one. They shouldn't even make any more."],
                    'memes': ["Some of these are definitely jokes."],
                    'dankmemes': ["Some of these are definitely jokes."],
                    'mystery': ["Lot more homework than you'd expect."],
                    'law': ["Lot more homework than you'd expect.", "Never let the law search your car without a warrant. Ever."],
                    'legaladvice': ["Lot more homework than you'd expect.", "Never let the law search your car without a warrant. Ever."],
                    'malelivingspace': ["Oh, yeah. This is my place."],
                    'mancave': ["Oh, yeah. This is my place."],
                    'showerthoughts': ["I do my thinking in the rain."],
                    'bmw': ["Good taste."],
                    'tifu': ["So, the song. CBAT..? My cousin told me to give it a listen. Something about interpretive dance."],
                    'askreddit': ["Have you ever heard of the Swamps of Dagobah?"],
                    'starwars': ["Have you ever heard of the Swamps of Dagobah?", "So anyway, I started blasting."],
                    'alwayssunnymemes': ["So anyway, I started blasting."],
                    'IASIP': ["So anyway, I started blasting."],
                    'cars': ["You seen the new GTXi Turbo Plus?", "Exactly.", "You should look up the VIN before buying.", "They need to ditch the damn touchscreens."],
                    'tesla': ["Tch."],
                    'jokes': ["Updog.", "Why did the chicken cross the road? Well I don't know, but it probably had something to do with me! Hahahaha!"],
                    'scams': ["Always do a reverse image search. My client fell for that one.", "Advance fee fraud. My client fell for that one."],
                    'floridaman': ["I used to live in Tampa.", "What do you have to do in a Chuck E. costume to get arrested?", "So you should try to look up on Google, look up 'Florida Man' plus your birthday, and you'll find 6 crazy stories, trust me."],
                    'florida': ["I used to live in Tampa.", "The Sunshine State."],
                    'texas': ["Quality of life. Look it up."],
                    'nyc': ["Overpriced? Yeah but I get it.", "Best pizza's not even in Manhattan anymore.", "The Empire State Building tour is worth it, but they do force you to do a picture, so keep that in mind."],
                    'disneyworld': ["So overpriced these days.", "I used to live in Tampa.", "You're wondering how I feel about mice."],
                    'disney': ["You're wondering how I feel about mice."],
                    'helldivers': ["My cousin is into that one."],
                    'helldivers2': ["My cousin is into that one."],
                    'iwanttolearn': ["I wanna learn the piano. I have my eyes on a $200 keyboard from Amazon."],
                    'piano': ["I wanna learn the piano. I have my eyes on a $200 keyboard from Amazon."],
                    'jazz': ["Try Ella Fitzgerald, Lullaby of the Leaves."],
                    'musicsuggestions': ["Les parapluies de cherbourg - Nana Mouskouri.", "Twilight - Electric Light Orchestra.", "Ava Adore - Smashing Pumpkins.", "The Strange Boutique - The Monochrome Set."],
                    'musicrecommendations': ["Les parapluies de cherbourg - Nana Mouskouri.", "Twilight - Electric Light Orchestra.", "Ava Adore - Smashing Pumpkins.", "The Strange Boutique - The Monochrome Set."],
                    'actionfigures': ["My cousin is into those."],
                    'homeimprovement': ["Redid my cousin's bathroom tile once. No experience, just Youtube University. And the spacing was, well, I had to redo the spacing, but.", "DeWalt. Everything else is toys."],
                    'cod': ["My cousin is into that one."],
                    'movies': ["I feel like I'm supposed to like Blade Runner. You know, the run time just doesn't do it for me.", "Casablanca.", "They say Citizen Kane is the best film ever made. I wanna argue with it, but I really can't argue with it. That is a damn good movie."],
                    'letterboxd': ["I feel like I'm supposed to like Blade Runner. You know, the run time just doesn't do it for me.", "Casablanca.", "They say Citizen Kane is the best film ever made. I wanna argue with it, but I really can't argue with it. That is a damn good movie."],
                    'cybertruck': ["Tch.", "*wheeze*"],
                    'personalfinance': ["Know when to hold 'em... I bet you don't know that song.", "My cousin has a VTI. You should look into that."],
                    'wallstreetbets': ["Know when to hold 'em... I bet you don't know that song.", "My cousin told me about GameStop? I thought they were outta business, honestly."],
                    'fire': ["My cousin has a VTI. You should look into that.", "I'm basically retired. Hahaha and then I wake up."],
                    'privacy': ["Travel burner phone.", "VPN."],
                    'prequelmemes': ["Ehhhh..."],
                    'gameofthrones': ["I dropped it after Season 4.", "You can only be disappointed by something that was great."],
                    'houseofcards': ["DO NOT continue after Season 2.", "You can only be disappointed by something that was great."],
                    'coffee': ["For me, I don't like none of that fancy stuff.", "Now they say you have to aerate the beans like they breathe oxygen.", "Cold brews at these new places are always rancid."],
                    'terminator': ["I'll be back..."],
                    'saltierthancrait': ["Ehhhh...", "Okay.", "Tch.", "Sure.", "I mean..."],
                    'foodporn': ["Have you heard of this Ube stuff. They keep coming out with new foods.", "Always marinade.", "This place makes me think going vegetarian could be survivable."],
                    'food': ["Always marinade.", "This place makes me think going vegetarian could be survivable.", "Apparently spaghetti isn't really Italian.", "Have you heard of this Ube stuff. They keep coming out with new foods."],
                    'maliciouscompliance': ["That's how you end up on my good list.", "All legal-like."],
                    'pettyrevenge': ["That's how you end up on my good list.", "All legal-like."],
                    'antiwork': ["My uncle was Teamsters for 30 years.", "That's how you end up on my good list.", "Join. A. Union.", "Document everything.", "Remember, they wouldn't hesitate."],
                    'nygiants': ["Every damn year.", "My therapist is booked solid.", "Don't even start."],
                    'starbucks': ["I always preferred Dunkin."],
                };

                // Check for specific subreddit first
                if (reactions[input.toLowerCase()]) {
                    return reactions[input.toLowerCase()];
                }
            }
            const nsfwPattern = /\b(tits|titties|rape|raped|tiddies|massivecock|nudes|onlyfans|hentai|boobs|cum|cock|cocks|cunt|gape|gooning|gooner|goon|pussy|porn)\b/i;
            if (nsfwPattern.test(input)) {
                return ["Really?", "Okay.", "Interesting.", "Bud...", "The usual suspects.", "For research purposes?"];
            }
            return null;
        }





        // Event Listeners
        searchButton.addEventListener('click', async () => {
            // Pressing button too fast
            if (scrambleYeller()) return;
            pendingCatReaction = null;
            // Reset search button
            setTimeout(() => {
                searchButton.style.backgroundImage = "url('../assets/search-default.png')";
            }, 500);

            const subreddit = subredditInput.value.trim();
            searchButton.style.backgroundImage = "url('../assets/search-pressed.png')";
            currentPageIndex = 0;

            // Check blocklist 
            if (subreddit && bannedSubreddits.includes(subreddit.toLowerCase())) {

                showError(`
                <div style="text-align: center;">
                    <img src="https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExOWtmaXgzdmdxdzU0dHJ0dXB5MXV2bWdpb2FqYXZndWc1eGNuZTAwMSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/Vuw9m5wXviFIQ/giphy.gif" 
                 alt="Rick Astley dancing" 
                 style="width: 300px; border-radius: 8px;">
                </div>
            `);
                // Reset search button
                setTimeout(() => {
                    searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                }, 500);
                return;
            }

            if (currentFilters.sort === 'relevance' && (!searchInput.value || searchInput.value.trim() === '')) {

                showError("No search terms detected. 🔎");
                // Reset search button
                setTimeout(() => {
                    searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                }, 500);

                handleRandomResponse([
                    "I couldn't find that, kid.",
                    "Sorry, squirt.",
                    "I'm gonna need more than that.",
                    "That's not on my records.",
                    "Shucks.",
                    "Nada.",
                    "I got nothin'.",
                    "That's a dead end.",
                    "Not in my files.",
                    "Zilch.",
                    "Throw me a bone here.",
                    "Don't know where I'd find 'blankity blank blank.'",
                    "No can do."
                ]);
                return;
            }

            if (subreddit && subreddit !== 'undefined' && subreddit !== 'null') {

                setTimeout(() => {
                    searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                }, 500);
                // Check for single character inputs
                if (subreddit.length === 1) {

                    showError("Couldn't find a valid subreddit. 🔎");
                    if (subreddit.toUpperCase() === 'F') {
                        handleRandomResponse(["You paying respects?", "Funny.", "Brother..."]);
                    } else {
                        handleRandomResponse([
                            `That's it? Just "${subreddit}"?`,
                            "I'm gonna need more than that."
                        ]);
                    }
                    return;
                }

                const catReaction = getCatReactionForSubreddit(subreddit, true);
                if (catReaction) {
                    pendingCatReaction = catReaction;
                }

                // 🌐 Check if the subreddit exists using about.json
                try {
                    const res = await fetch(`${API_BASE}/reddit?url=https://www.reddit.com/r/${subreddit}/about.json`);
                    if (!res.ok) {

                        showError("Couldn't find a valid subreddit. 🔎");
                        // Reset search button
                        setTimeout(() => {
                            searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                        }, 500);

                        handleRandomResponse([
                            "I couldn't find that, kid.",
                            "Is that a word?",
                            "Sorry, squirt.",
                            "That's not on my records.",
                            "Shucks.",
                            "Nada.",
                            "I got nothin'.",
                            "Not familiar with that.",
                            "That's a dead end.",
                            "Not in my files.",
                            "Never heard of that place.",
                            "Zilch.",
                            "No can do."
                        ]);
                        return;
                    }

                    const json = await res.json();

                    if (!json || !json.data || json.data.subreddit_type === 'private') {

                        showError("This subreddit is private.");
                        // Reset search button
                        setTimeout(() => {
                            searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                        }, 500);

                        handleRandomResponse([
                            "Sorry, squirt.",
                            "That's classified.",
                            "That's private.",
                            "No can do."
                        ]);
                        return;
                    }

                } catch (err) {

                    showError("Couldn't find a valid subreddit. 🔎");
                    setTimeout(() => {
                        searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                    }, 500);
                    noResultsMessage();
                    return;
                }
            }

            // Store the search suggestion
            const searchTerm = searchInput.value.trim();
            if (searchTerm) {
                try {
                    const searchType = determineSearchType();
                    const isVectorSearch = searchType === 'vector';

                    fetch(`${API_BASE}/api/suggestions/store`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            query: searchTerm,
                            subreddit: (subreddit && subreddit !== 'undefined' && subreddit !== 'null') ? subreddit : null,
                            is_vector_search: isVectorSearch
                        })
                    })
                        .catch(err => {
                            console.error("Failed to store suggestion in background:", err);
                        });
                } catch (err) {
                    console.error("Error setting up suggestion storage:", err);
                }
            }

            handleSearchRequest();

            searchCount++;
            localStorage.setItem('searchCount', searchCount);
            // Premium reminders at specific search counts
            if (!isLoggedIn) {
                if (searchCount === 7) {
                    setTimeout(() => {
                        showSpeechBubble("My client told me to inform you that the Bookmarks feature comes with Premium.");
                    }, 300);
                } else if (searchCount === 37) {
                    setTimeout(() => {
                        showSpeechBubble("My client told me to inform you that the Enhanced Search feature comes with Premium. 'Search Reddit Like Google', he says.");
                    }, 300);
                } else if (searchCount === 77) {
                    setTimeout(() => {
                        showSpeechBubble("My client told me to inform you that the Color Themes feature comes with Premium.");
                    }, 300);
                }
            }

            setTimeout(() => {
                searchButton.style.backgroundImage = "url('../assets/search-default.png')";
            }, 500);

            if (pendingCatReaction) {
                const randomChance = Math.random();
                if (randomChance < 0.82) {
                    hideSpeechBubble();
                    stopTalking();
                } else if (randomChance < 0.5) {
                    showSpeechBubble("...");
                    stopTalking();
                } else {
                    showSpeechBubble(pendingCatReaction);
                }
            }
        });

        [subredditInput, searchInput].forEach(input => {
            input.addEventListener('keydown', async (e) => {
                if (e.key === 'Tab') {
                    let dropdown, suggestions, currentHighlighted;

                    // Check suggestions dropdown first
                    dropdown = document.querySelector('#suggestions');
                    if (dropdown && dropdown.style.display !== 'none') {
                        suggestions = dropdown.querySelectorAll('div');
                        currentHighlighted = dropdown.querySelector('.highlighted');
                    } else {
                        // Check subreddit dropdown
                        dropdown = document.querySelector('.subreddit-suggestions');
                        if (dropdown && dropdown.classList.contains('active')) {
                            suggestions = dropdown.querySelectorAll('.subreddit-suggestion');
                            currentHighlighted = dropdown.querySelector('.highlighted');
                        }
                    }

                    if (suggestions && suggestions.length > 0) {
                        if (currentHighlighted) {
                            const currentIndex = Array.from(suggestions).indexOf(currentHighlighted);
                            currentHighlighted.classList.remove('highlighted');

                            if (currentIndex < suggestions.length - 1) {
                                suggestions[currentIndex + 1].classList.add('highlighted');
                                e.preventDefault();
                            } else {
                                // After last suggestion, hide dropdown and allow tab to continue
                                if (dropdown.id === 'suggestions') {
                                    dropdown.innerHTML = '';
                                    dropdown.style.display = 'none';
                                } else if (dropdown.classList.contains('subreddit-suggestions')) {
                                    dropdown.classList.remove('active');
                                }
                            }
                        } else {
                            // No current highlight — highlight first suggestion
                            suggestions[0].classList.add('highlighted');
                            e.preventDefault();
                        }

                    }
                }

                // Up and Down Arrows Input  
                if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                    let dropdown, suggestions, currentHighlighted;

                    // Check which dropdown is active (same logic as Tab)
                    dropdown = document.querySelector('#suggestions');
                    if (dropdown && dropdown.style.display !== 'none') {
                        suggestions = dropdown.querySelectorAll('div');
                        currentHighlighted = dropdown.querySelector('.highlighted');
                    } else {
                        dropdown = document.querySelector('.subreddit-suggestions');
                        if (dropdown && dropdown.classList.contains('active')) {
                            suggestions = dropdown.querySelectorAll('.subreddit-suggestion');
                            currentHighlighted = dropdown.querySelector('.highlighted');
                        }
                    }

                    if (suggestions && suggestions.length > 0) {
                        e.preventDefault();

                        // Remove current highlight
                        if (currentHighlighted) {
                            currentHighlighted.classList.remove('highlighted');
                        }

                        let nextIndex;
                        if (e.key === 'ArrowDown') {
                            // Move down
                            if (currentHighlighted) {
                                const currentIndex = Array.from(suggestions).indexOf(currentHighlighted);
                                nextIndex = (currentIndex + 1) % suggestions.length;
                            } else {
                                nextIndex = 0; // Start at first item
                            }
                        } else {
                            // Move up
                            if (currentHighlighted) {
                                const currentIndex = Array.from(suggestions).indexOf(currentHighlighted);
                                nextIndex = currentIndex <= 0 ? suggestions.length - 1 : currentIndex - 1;
                            } else {
                                nextIndex = suggestions.length - 1; // Start at last item
                            }
                        }

                        suggestions[nextIndex].classList.add('highlighted');
                    }
                }

                if (e.key === 'Enter') {
                    // Check both dropdowns
                    let highlighted = document.querySelector('#suggestions .highlighted') ||
                        document.querySelector('.subreddit-suggestions .highlighted');

                    if (highlighted) {
                        e.preventDefault();
                        highlighted.click();
                        highlighted.classList.remove('highlighted');
                        return;
                    }
                    // Pressing button too fast
                    if (scrambleYeller()) return;
                    pendingCatReaction = null;
                    // Reset search button
                    setTimeout(() => {
                        searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                    }, 500);

                    const subreddit = subredditInput.value.trim();
                    const searchTerm = searchInput.value.trim();

                    searchButton.style.backgroundImage = "url('../assets/search-pressed.png')";
                    currentPageIndex = 0;

                    // **BLOCKLIST CHECK**
                    if (subreddit && bannedSubreddits.includes(subreddit.toLowerCase())) {

                        showError(`
                            <div style="text-align: center;">
                                <img src="https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExOWtmaXgzdmdxdzU0dHJ0dXB5MXV2bWdpb2FqYXZndWc1eGNuZTAwMSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/Vuw9m5wXviFIQ/giphy.gif" 
                            alt="Rick Astley dancing" 
                            style="width: 300px; border-radius: 8px;">
                            </div>
                        `);
                        // Reset search button
                        setTimeout(() => {
                            searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                        }, 500);
                        return;
                    }

                    // **RELEVANCE SEARCH TERM CHECK**
                    if (currentFilters.sort === 'relevance' && !searchTerm) {

                        showError("No search terms detected. 🔎");
                        setTimeout(() => {
                            searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                        }, 500);
                        handleRandomResponse([
                            "I couldn't find that, kid.",
                            "Sorry, squirt.",
                            "That's not on my records.",
                            "Shucks.",
                            "Nada.",
                            "I got nothin'.",
                            "That's a dead end.",
                            "Not in my files.",
                            "Zilch.",
                            "Don't know where I'd find 'blankity blank blank.'",
                            "No can do."
                        ]);
                        return;
                    }

                    // **SUBREDDIT VALIDATION**
                    if (subreddit && subreddit !== 'undefined' && subreddit !== 'null') {
                        // Check for single character inputs
                        if (subreddit.length === 1) {

                            showError("Couldn't find a valid subreddit. 🔎");
                            setTimeout(() => {
                                searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                            }, 500);
                            if (subreddit.toUpperCase() === 'F') {
                                handleRandomResponse(["You paying respects?", "Funny.", "Brother..."]);
                            } else {
                                handleRandomResponse([
                                    `That's it? Just "${subreddit}"?`,
                                    "I'm gonna need more than that.",
                                    "Brother..."
                                ]);
                            }
                            return;
                        }

                        const catReaction = getCatReactionForSubreddit(subreddit, true);
                        if (catReaction) {
                            pendingCatReaction = catReaction;
                        }

                        try {
                            const res = await fetch(`${API_BASE}/reddit?url=https://www.reddit.com/r/${subreddit}/about.json`);
                            if (!res.ok) {

                                showError("Couldn't find a valid subreddit. 🔎");
                                setTimeout(() => {
                                    searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                                }, 500);
                                handleRandomResponse([
                                    "I couldn't find that, kid.",
                                    "Is that a word?",
                                    "Sorry, squirt.",
                                    "That's not on my records.",
                                    "Shucks.",
                                    "Nada.",
                                    "I got nothin'.",
                                    "Not familiar with that.",
                                    "That's a dead end.",
                                    "Not in my files.",
                                    "Never heard of that place.",
                                    "Zilch.",
                                    "No can do."
                                ]);
                                return;
                            }

                            const json = await res.json();

                            if (!json || !json.data || json.data.subreddit_type === 'private') {

                                showError("This subreddit is private.");
                                setTimeout(() => {
                                    searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                                }, 500);
                                handleRandomResponse([
                                    "Sorry, squirt.",
                                    "That's classified.",
                                    "That's private.",
                                    "No can do."
                                ]);
                                return;
                            }

                        } catch (err) {

                            showError("Couldn't find a valid subreddit. 🔎");
                            setTimeout(() => {
                                searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                            }, 500);
                            noResultsMessage();
                            return;
                        }
                    }

                    // **STORE SEARCH SUGGESTION**
                    if (searchTerm) {
                        try {
                            const searchType = determineSearchType();
                            const isVectorSearch = searchType === 'vector';

                            await fetch(`${API_BASE}/api/suggestions/store`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    query: searchTerm,
                                    subreddit: (subreddit && subreddit !== 'undefined' && subreddit !== 'null') ? subreddit : null,
                                    is_vector_search: isVectorSearch
                                })
                            });
                        } catch (err) {
                            console.error("Failed to store suggestion:", err);
                        }
                    }

                    // **PERFORM SEARCH**
                    handleSearchRequest();

                    searchCount++;
                    localStorage.setItem('searchCount', searchCount);
                    // Premium reminders at specific search counts
                    if (!isLoggedIn) {
                        hideSpeechBubble();
                        if (searchCount === 7) {
                            setTimeout(() => {
                                showSpeechBubble("My client told me to inform you that the Bookmarks feature comes with Premium.");
                            }, 500);
                        } else if (searchCount === 37) {
                            setTimeout(() => {
                                showSpeechBubble("My client told me to inform you that the Enhanced Search feature comes with Premium. 'Search Reddit Like Google', he says.");
                            }, 500);
                        } else if (searchCount === 77) {
                            setTimeout(() => {
                                showSpeechBubble("My client told me to inform you that the Color Themes feature comes with Premium.");
                            }, 500);
                        }
                    }

                    setTimeout(() => {
                        searchButton.style.backgroundImage = "url('../assets/search-default.png')";
                    }, 500);

                    // **CAT REACTION LOGIC**
                    if (pendingCatReaction) {
                        const randomChance = Math.random();
                        if (randomChance < 0.82) {
                            hideSpeechBubble();
                            stopTalking();
                        } else if (randomChance < 0.4) {
                            showSpeechBubble("...");
                            stopTalking();
                        } else {
                            showSpeechBubble(pendingCatReaction);
                        }
                    }
                }

                // Reset highlight when typing
                if (e.key.length === 1 || e.key === 'Backspace') {
                    highlightedIndex = -1;
                    const dropdown = document.querySelector('.suggestions-dropdown');
                    if (dropdown) {
                        const suggestions = dropdown.querySelectorAll('.suggestion-item');
                        suggestions.forEach(item => item.classList.remove('highlighted'));
                    }
                }
            });

            // Click listener for subreddit input
            if (input === subredditInput) {
                input.addEventListener('click', (e) => {
                    if (e.target.value.trim()) {
                        handleSubredditSuggestions(e.target.value.trim());
                        // Also make sure the dropdown shows
                        const dropdown = document.querySelector('.subreddit-suggestions');
                        if (dropdown) {
                            dropdown.classList.add('active');
                        }
                    }
                });
            }

            // Remove chip if user typed a sub
            if (input === subredditInput) {
                input.addEventListener('input', (e) => {
                    if (e.target.value.trim()) {
                        currentFilters.subreddit = '';
                        subredditChipContainer.style.display = 'none';
                    }
                });
            }
        });

        document.querySelector('#subreddit-input').addEventListener('focus', (e) => {
            if (!e.target.value.trim()) {
                const popularSubs = [
                    { name: 'AskReddit', icon: null },
                    { name: 'pics', icon: null },
                    { name: 'mildlyinteresting', icon: null },
                    { name: 'funny', icon: null },
                    { name: 'worldnews', icon: null }
                ];

                // Load recent subs
                const recent = JSON.parse(localStorage.getItem('recentSubs')) || [];
                const recentSubs = recent.map(name => ({ name, icon: null, isRecent: true }));

                // Combine with section headers
                const combinedSubs = [
                    ...popularSubs,
                    ...(recentSubs.length > 0 ? [{ name: 'Recently Searched', isHeader: true }] : []),
                    ...recentSubs
                ];

                populateSubredditSuggestions(combinedSubs);
                document.querySelector('.subreddit-suggestions').classList.add('active');
            }
        });

        // Save short subreddit search history
        function saveRecentSubreddit(subreddit) {
            let recent = JSON.parse(localStorage.getItem('recentSubs')) || [];

            // Convert input to lowercase for comparison, but keep original case for storage
            const subredditLower = subreddit.toLowerCase();

            // Remove if already exists (case-insensitive)
            recent = recent.filter(s => s.toLowerCase() !== subredditLower);

            // Add to start (keep original casing)
            recent.unshift(subreddit);

            // Keep only last 2
            recent = recent.slice(0, 2);
            localStorage.setItem('recentSubs', JSON.stringify(recent));
        }

        // Toggle Management System
        class ToggleManager {
            constructor() {
                this.toggle1 = document.getElementById('toggle1');
                this.toggle2 = document.getElementById('toggle2');
                this.sortContainer = document.getElementById('sort-select').parentElement;

                this.init();
            }

            init() {

                // Add single event listeners
                this.toggle1.addEventListener('click', (e) => this.handleToggle1Click(e));
                this.toggle2.addEventListener('click', (e) => this.handleToggle2Click(e));

                // Update sort dropdown based on current state
                this.updateSortDropdown();
            }

            handleToggle1Click(e) {
                if (!isLoggedIn) {
                    // Prevent any change and redirect
                    e.preventDefault();
                    this.toggle1.checked = false;
                    window.open('features.html', '_blank');
                    return;
                }

                if (this.toggle1.checked) {
                    // Enable enhanced search
                    this.toggle2.checked = false;
                    this.saveState(true, false);
                } else {
                    // Disable enhanced search
                    this.toggle2.checked = true;
                    this.saveState(false, true);
                }

                this.updateSortDropdown();
            }

            handleToggle2Click(e) {
                if (!isLoggedIn) {
                    // Prevent any change and redirect
                    e.preventDefault();
                    this.toggle2.checked = true;
                    window.open('features.html', '_blank');
                    return;
                }

                if (this.toggle2.checked) {
                    // Enable reddit search
                    this.toggle1.checked = false;
                    this.saveState(false, true);
                } else {
                    // Disable reddit search
                    this.toggle1.checked = true;
                    this.saveState(true, false);
                }

                this.updateSortDropdown();
            }

            saveState(toggle1State, toggle2State) {
                if (isLoggedIn) {
                    sessionStorage.setItem('toggle1State', toggle1State.toString());
                    sessionStorage.setItem('toggle2State', toggle2State.toString());
                }
            }

            validateState() {
                // Ensure exactly one toggle is always on
                if (this.toggle1.checked && this.toggle2.checked) {
                    // Both on - default to reddit search
                    this.toggle1.checked = false;
                    this.toggle2.checked = true;
                } else if (!this.toggle1.checked && !this.toggle2.checked) {
                    // Both off - default to reddit search
                    this.toggle1.checked = false;
                    this.toggle2.checked = true;
                }
            }

            updateSortDropdown() {
                if (this.toggle1.checked) {
                    this.showUltimateSort();
                } else {
                    this.restoreNormalSort();
                }
            }

            showUltimateSort() {
                const oldSelect = document.getElementById('sort-select');
                const newSelect = document.createElement('select');
                newSelect.id = 'sort-select';
                newSelect.disabled = true;
                newSelect.innerHTML = '<option value="ultimate">ULTIMATE ✨</option>';
                this.sortContainer.replaceChild(newSelect, oldSelect);
                currentFilters.sort = 'ultimate';
            }

            restoreNormalSort() {
                const oldSelect = document.getElementById('sort-select');
                const newSelect = document.createElement('select');
                newSelect.id = 'sort-select';
                newSelect.innerHTML = `
        <option value="hot">Hot</option>
        <option value="top">Top</option>
        <option value="new">New</option>
        <option value="relevance">Relevance</option>
    `;
                this.sortContainer.replaceChild(newSelect, oldSelect);

                newSelect.addEventListener('change', () => {
                    currentFilters.sort = newSelect.value;
                    if (newSelect.value !== 'relevance') {
                        handleSearchRequest();
                    }
                });

                currentFilters.sort = 'hot';
            }
        }

        sortSelect.addEventListener('change', () => {
            currentFilters.sort = sortSelect.value;

            // Only perform search if NOT relevance
            if (sortSelect.value !== 'relevance') {

                // Reset pagination state
                currentIndex = 0;
                handleSearchRequest();

            }
        });

        timeSelect.addEventListener('change', () => {
            currentFilters.time = timeSelect.value;

            // Reset pagination state
            currentIndex = 0;
            handleSearchRequest();
        });

        function forceUltimateSortDropdown() {
            const oldSelect = document.getElementById('sort-select');
            if (!oldSelect) return;

            const newSelect = document.createElement('select');
            newSelect.id = 'sort-select';
            newSelect.disabled = true;
            newSelect.innerHTML = '<option value="ultimate">ULTIMATE ✨</option>';

            oldSelect.parentElement.replaceChild(newSelect, oldSelect);

            if (typeof currentFilters !== 'undefined') {
                currentFilters.sort = 'ultimate';
            }
        }

        document.getElementById('safesearch-select').addEventListener('change', function () {
            const enabled = this.value === 'on';
            document.body.classList.toggle('safe-search-enabled', enabled);
        });

        contentSelect.addEventListener('change', () => {
            currentFilters.contentType = contentSelect.value;
            // Reset pagination state
            currentIndex = 0;
            handleSearchRequest();
        });

        const comfyToggle = document.getElementById('comfy-toggle');
        const compactToggle = document.getElementById('compact-toggle');

        // Use sessionStorage - resets when tab closes, persists on refresh
        let isComfyActive = sessionStorage.getItem('isComfyActive') === 'true' || false;
        let isCompactActive = sessionStorage.getItem('isCompactActive') === 'true' || false;
        let hasClickedOnce = sessionStorage.getItem('hasClickedOnce') === 'true' || false;

        // Apply saved states on page load
        function applyButtonStates() {
            if (isComfyActive) {
                comfyToggle.querySelector('img').src = '../assets/comfy-pressed.png';
                document.body.classList.add('comfy-mode');
            } else {
                comfyToggle.querySelector('img').src = '../assets/comfy-default.png';
                document.body.classList.remove('comfy-mode');
            }

            if (isCompactActive) {
                compactToggle.querySelector('img').src = '../assets/compact-pressed.png';
            } else {
                compactToggle.querySelector('img').src = '../assets/compact-default.png';
            }

            if (hasClickedOnce) {
                document.body.classList.add('hasClickedOnce');
            }
        }

        applyButtonStates();

        // Save states to sessionStorage
        function saveStates() {
            sessionStorage.setItem('isComfyActive', isComfyActive);
            sessionStorage.setItem('isCompactActive', isCompactActive);
            sessionStorage.setItem('hasClickedOnce', hasClickedOnce);
        }

        comfyToggle.addEventListener('click', () => {
            if (isComfyActive) {
                if (hasClickedOnce && !isCompactActive) return;
                isComfyActive = false;
                comfyToggle.querySelector('img').src = '../assets/comfy-default.png';
            } else {
                isComfyActive = true;
                comfyToggle.querySelector('img').src = '../assets/comfy-pressed.png';
                isCompactActive = false;
                compactToggle.querySelector('img').src = '../assets/compact-default.png';
            }
            hasClickedOnce = true;
            document.body.classList.add('hasClickedOnce');

            if (isComfyActive) {
                document.body.classList.add('comfy-mode');
            } else {
                document.body.classList.remove('comfy-mode');
            }

            refreshInfiniteScrollLayout();

            saveStates();
        });

        compactToggle.addEventListener('click', () => {
            hasClickedOnce = true;
            document.body.classList.add('hasClickedOnce');
            compactToggle.querySelector('img').src = '../assets/compact-pressed.png';
            document.body.classList.remove('comfy-mode');
            isComfyActive = false;
            isCompactActive = true;
            comfyToggle.querySelector('img').src = '../assets/comfy-default.png';

            refreshInfiniteScrollLayout();

            saveStates();
        });

        function refreshInfiniteScrollLayout() {
            // Trigger window resize event to refresh any scroll calculations
            window.dispatchEvent(new Event('resize'));

            // Wait for CSS layout to finish, then recalculate scroll indicator
            setTimeout(() => {
                positionScrollIndicator();
            }, 250); // Small delay to let CSS changes take effect
        }

        function positionScrollIndicator() {
            const indicator = document.querySelector('.scroll-container-minimal');

            const body = document.body;
            const html = document.documentElement;

            // Get the actual height of all content
            const documentHeight = Math.max(
                body.scrollHeight,
                body.offsetHeight,
                html.clientHeight,
                html.scrollHeight,
                html.offsetHeight
            );

            // Position it near the bottom of content
            indicator.style.position = 'absolute';
            indicator.style.top = (documentHeight + 1005) + 'px';
            indicator.style.left = '50%';
            indicator.style.transform = 'translateX(-50%)';

            // Get active section
            const activeTab = document.querySelector('.tab.active');
            if (!activeTab) {
                indicator.style.display = 'none';
                return;
            }
            const sectionId = activeTab.dataset.tabId;

            // Check section-specific hasMoreBookmarks
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('page') === 'bookmarks' && hasMoreBookmarks[sectionId]) {
                setTimeout(() => {
                    indicator.style.display = 'flex';
                    indicator.style.opacity = '1';

                }, 1000);
            } else {
                indicator.style.display = 'none';
            }
        }

        document.addEventListener('click', function (event) {
            const suggestionsDiv = document.getElementById('suggestions');
            const input = document.getElementById('search-input');

            // If the click target is NOT the input or a suggestion
            if (!suggestionsDiv.contains(event.target) && event.target !== input) {
                suggestionsDiv.innerHTML = '';
                suggestionsDiv.style.display = 'none';
            }
        });

        document.querySelector('#search-input').addEventListener('focus', function () {
            if (this.value === '') {
                fetch(`${API_BASE}/api/top-searches`)
                    .then(res => res.json())
                    .then(data => {
                        const suggestionsDiv = document.querySelector('#suggestions');
                        displaySuggestions(data, suggestionsDiv);
                    });
            }
        });

        document.querySelector('.search-input-container').addEventListener('click', function (e) {
            // Only focus if they didn't click the input itself, search button, or filter icon
            if (!e.target.matches('.search-input') &&
                !e.target.matches('.search-button') &&
                !e.target.matches('#filter-icon') &&
                !e.target.closest('.search-button')) {
                document.querySelector('#search-input').focus();
            }
        });

        // Grow comment images
        document.addEventListener('click', function (e) {
            if (e.target.matches('.comment-body img')) {
                let currentWidth = e.target.offsetWidth;
                e.target.style.transition = 'width 0.07s ease';

                if (e.target.style.width) {
                    e.target.style.width = '';
                } else {
                    e.target.style.width = (currentWidth * 1.7) + 'px';
                }
            }
        });

        // Remove subreddit filter when clicking X
        subredditChipContainer.querySelector('.remove-chip').addEventListener('click', () => {
            currentFilters.subreddit = '';
            subredditChipContainer.style.display = 'none';
        });

        // Handle suggestion selection
        subredditSuggestions.addEventListener('click', (e) => {
            // Don't select if delete button was clicked
            if (e.target.classList.contains('delete-recent-btn')) {
                return;
            }

            const suggestion = e.target.closest('.subreddit-suggestion');
            if (suggestion) {
                const subName = suggestion.getAttribute('data-name');
                selectSubreddit(subName);
            }
        });

        // Handle typing in subreddit input
        subredditInput.addEventListener('input', () => {
            const query = subredditInput.value.toLowerCase().trim();
            lastQuery = query;

            // Show dropdown immediately with a loading spinner
            if (query.length > 0) {
                if (!subredditSuggestions.querySelector('.custom-spinner-wrapper')) {
                    subredditSuggestions.innerHTML = '';
                    subredditSuggestions.appendChild(createCanvasSpinner());
                }

                subredditSuggestions.classList.add('active');
            } else {
                subredditSuggestions.classList.remove('active');
            }

            // Debounce Reddit API call
            if (searchTimeout) clearTimeout(searchTimeout);

            searchTimeout = setTimeout(() => {
                handleSubredditSuggestions(query);
            }, 200); // delay debounce here
        });

        document.addEventListener('click', function (e) {
            if (e.target.closest('.plan-display-container')) {
                const userEmail = localStorage.getItem('userEmail');
                if (userEmail) {
                    // Show spinner immediately
                    const planDisplayElement = document.getElementById('plan-display');
                    const originalContent = planDisplayElement.innerHTML;
                    const spinnerWrapper = createCanvasSpinner();
                    spinnerWrapper.style.transform = 'scale(0.6)';
                    planDisplayElement.innerHTML = '';
                    planDisplayElement.appendChild(spinnerWrapper);

                    fetch(`${API_BASE} /api/create-checkout`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ email: userEmail })
                    })
                        .then(response => response.json())
                        .then(data => {
                            if (data.url) {
                                window.location.href = data.url;
                            } else {
                                // Restore original content if no URL
                                planDisplayElement.innerHTML = originalContent;
                                planDisplayElement.classList.remove('loading');
                            }
                        })
                        .catch(error => {
                            console.error('Error:', error);
                            Swal.fire('Error', 'Could not open billing portal');
                            // Restore original content on error
                            planDisplayElement.innerHTML = originalContent;
                            planDisplayElement.classList.remove('loading');
                        });
                }
            }
        });

        // Cubic-bezier easing 
        function cubicBezier(p0, p1, p2, p3) {
            return function (t) {
                const cx = 3 * (p1 - p0);
                const bx = 3 * (p2 - p1) - cx;
                const ax = 1 - cx - bx;

                const cy = 3 * (p1 - p0);
                const by = 3 * (p2 - p1) - cy;
                const ay = 1 - cy - by;

                let x = t, t2 = t;
                for (let i = 0; i < 5; i++) {
                    const f = ax * t2 * t2 * t2 + bx * t2 * t2 + cx * t2 - x;
                    const df = 3 * ax * t2 * t2 + 2 * bx * t2 + cx;
                    t2 = t2 - f / df;
                    t2 = Math.max(0, Math.min(t2, 1));
                }

                return ay * t2 * t2 * t2 + by * t2 * t2 + cy * t2;
            };
        }

        function getThemeColor() {
            const body = document.body;
            if (body.classList.contains('forest-theme')) {
                return 'rgb(65, 127, 111)'; // Green
            } else if (body.classList.contains('bluebird-theme')) {
                return "rgb(135, 197, 255)"; // Blue
            } else if (body.classList.contains('dark-theme')) {
                return '#ffffff'; // White
            }
            return '#C1C0C1'; // Gray
        }

        // Begin animation
        function startSpinnerAnimation(ctx, color = "#C1C0C1") {
            const easeCustom = cubicBezier(0.1, 0.83, 0.37, 1);
            const cycleDuration = 700;
            let startTime = null;

            function animate(timestamp) {
                if (!startTime) startTime = timestamp;

                const elapsed = timestamp - startTime;
                const t = (elapsed % cycleDuration) / cycleDuration;
                const ramp = Math.pow(t, 0.8);
                const eased = easeCustom(ramp);

                const angle = (eased * 6.28 + 7.8) % 6.28;
                const shrinkEase = easeCustom(t);
                const sinePhase = Math.sin(shrinkEase * Math.PI);
                const shrinkPhase = easeCustom(sinePhase);
                const shrink = 0.5 + 0.5 * shrinkPhase;
                const arcLength = Math.PI * 0.7 * shrink;

                ctx.clearRect(0, 0, 50, 50);
                ctx.beginPath();
                const arcStart = angle - arcLength;
                ctx.arc(25, 25, 18, arcStart, angle);
                ctx.strokeStyle = color;
                ctx.lineWidth = 4;
                ctx.stroke();

                requestAnimationFrame(animate);
            }

            requestAnimationFrame(animate);
        }

        function createCanvasSpinner(color = null) {
            const wrapper = document.createElement('div');
            wrapper.className = 'custom-spinner-wrapper';

            const canvas = document.createElement('canvas');
            canvas.width = 50;
            canvas.height = 50;
            canvas.id = 'main-spinner-placeholder';
            wrapper.appendChild(canvas);

            const ctx = canvas.getContext('2d');
            const spinnerColor = color || getThemeColor();
            startSpinnerAnimation(ctx, spinnerColor);

            return wrapper;
        }

        document.getElementById('content-select').addEventListener('change', function () {
            currentFilters.contentType = this.value;
            updateURL();
        });

        async function handleSubredditSuggestions(query) {
            if (!query || query.trim() === '') {
                subredditSuggestions.innerHTML = '';
                return;
            }

            const cleanQuery = query.replace(/^r\//, '');
            const queryToken = ++activeQueryToken;

            let timeoutId;

            timeoutId = setTimeout(() => {
                if (queryToken === activeQueryToken) {
                    subredditSuggestions.innerHTML = '<div class="subreddit-suggestion-err">No subreddits found</div>';
                    subredditSuggestions.classList.add('active');
                }
            }, 1600);

            try {
                const res = await fetch(`${API_BASE}/reddit?url=https://www.reddit.com/subreddits/search.json?q=${encodeURIComponent(query)}`);
                const data = await res.json();

                if (queryToken !== activeQueryToken) return;

                let matches = [];

                if (data?.data?.children) {
                    const filtered = [];
                    const partialMatches = [];

                    for (const child of data.data.children) {
                        const name = child?.data?.display_name?.toLowerCase();
                        if (!name) continue;

                        const queryLower = cleanQuery.toLowerCase();
                        if (name.startsWith(queryLower) && filtered.length < 6) {
                            filtered.push(child.data.display_name);
                        } else if (name.includes(queryLower) && partialMatches.length < 10) {
                            partialMatches.push(child.data.display_name);
                        }

                        if (filtered.length >= 6 && partialMatches.length >= 10) break;
                    }

                    if (filtered.length < 4) {
                        const needed = 4 - filtered.length;
                        filtered.push(...partialMatches.slice(0, needed));
                    }

                    const finalResults = filtered.slice(0, 4);
                    matches = finalResults.map(name => ({ name, icon: null }));
                }

                if (matches.length > 0) {
                    clearTimeout(timeoutId);
                    populateSubredditSuggestions(matches);
                }
                // else: don't clear timeout — let the 2s fallback run

            } catch (err) {
                console.error("❌ Subreddit suggestion fetch failed:", err);
                clearTimeout(timeoutId);

                if (queryToken === activeQueryToken) {
                    subredditSuggestions.innerHTML = '<div class="subreddit-suggestion-err">No subreddits found</div>';
                    subredditSuggestions.classList.add('active');
                }
            }
        }


        function populateSubredditSuggestions(subreddits) {

            // Sort subreddits by relevance to the search query
            const query = subredditInput.value.toLowerCase().trim();
            if (query.length > 0) {
                // Filter out header items before sorting
                const actualSubs = subreddits.filter(sub => !sub.isHeader);
                actualSubs.sort((a, b) => {
                    const aName = a.name.toLowerCase();
                    const bName = b.name.toLowerCase();

                    // Exact matches first
                    if (aName === query && bName !== query) return -1;
                    if (bName === query && aName !== query) return 1;

                    // Then starts with matches
                    if (aName.startsWith(query) && !bName.startsWith(query)) return -1;
                    if (bName.startsWith(query) && !aName.startsWith(query)) return 1;

                    // Then contains matches (already handled by filtering)
                    // Finally alphabetical
                    return aName.localeCompare(bName);
                });
                subreddits = actualSubs; // Use sorted subs without headers when searching

                // Add recent subreddits that match the query
                const recent = JSON.parse(localStorage.getItem('recentSubs')) || [];
                const matchingRecent = recent.filter(name =>
                    name.toLowerCase().startsWith(query)
                );

                if (matchingRecent.length > 0) {
                    subreddits = [
                        ...subreddits,
                        { name: 'Recently Searched', isHeader: true },
                        ...matchingRecent.map(name => ({ name, icon: null, isRecent: true }))
                    ];
                }
            }

            // If there are results from filtering, add them
            if (subreddits.length > 0) {

                // Wait for all icon fetches to complete
                Promise.all(subreddits.map(sub => Promise.resolve(sub))).then(() => {
                    subredditSuggestions.innerHTML = '';
                    subreddits.forEach(sub => {

                        // Handle header items
                        if (sub.isHeader) {
                            const header = document.createElement('div');
                            header.className = 'subreddit-section-header';
                            header.textContent = sub.name;
                            subredditSuggestions.appendChild(header);
                            return;
                        }

                        // Skip if no name
                        if (!sub.name) {
                            return;
                        }

                        const suggestion = document.createElement('div');
                        suggestion.className = 'subreddit-suggestion';
                        suggestion.setAttribute('data-name', sub.name);
                        const iconEl = document.createElement('div');
                        iconEl.className = 'subreddit-icon';

                        if (sub.icon && sub.icon.startsWith('http')) {
                            const img = document.createElement('img');
                            img.alt = sub.name;
                            img.src = sub.icon;
                            img.onerror = () => {
                                img.remove();
                                const fallback = document.createElement('span');
                                fallback.textContent = sub.name.charAt(0).toUpperCase();
                                iconEl.appendChild(fallback);
                            };
                            iconEl.appendChild(img);
                            // Force a repaint
                            iconEl.offsetHeight;
                        } else {
                            // Fallback if icon is missing or invalid
                            iconEl.textContent = sub.name.charAt(0).toUpperCase();
                        }

                        suggestion.appendChild(iconEl);
                        suggestion.appendChild(document.createTextNode(sub.name));
                        // Add delete button for recent items
                        if (sub.isRecent) {
                            const deleteBtn = document.createElement('span');
                            deleteBtn.className = 'delete-recent-btn';
                            deleteBtn.textContent = '×';
                            deleteBtn.onclick = (e) => {
                                e.stopPropagation();
                                e.preventDefault();
                                // Remove from localStorage
                                let recent = JSON.parse(localStorage.getItem('recentSubs')) || [];
                                recent = recent.filter(name => name !== sub.name);
                                localStorage.setItem('recentSubs', JSON.stringify(recent));
                                // Refresh dropdown
                                handleSubredditSuggestions(subredditInput.value);
                            };
                            suggestion.appendChild(deleteBtn);
                        }

                        subredditSuggestions.appendChild(suggestion);

                        if (sub.name) {
                            // Fetch icon async and replace when it loads
                            getSubredditIcon(sub.name).then(iconUrl => {
                                if (iconUrl && iconUrl.startsWith('http')) {
                                    const img = document.createElement('img');
                                    img.alt = sub.name;
                                    img.src = iconUrl;
                                    img.onload = () => {
                                        iconEl.textContent = ''; // Clear the letter
                                        iconEl.appendChild(img);
                                        iconEl.classList.add('icon-loaded');
                                    };
                                }
                            }).catch(err => {
                                console.error("❌ Error fetching icon:", err);
                                // Keep the letter fallback if fetch fails
                            });
                        }
                    });
                    subredditSuggestions.setAttribute('data-has-results', 'true');
                })
                    .catch(err => {
                        console.error("❌ Error rendering suggestions:", err);
                        subredditSuggestions.innerHTML = '<div class="subreddit-suggestion-err">Error loading suggestions</div>';
                    });
            }
        }

        function getFiltersFromURL() {
                const params = new URLSearchParams(window.location.search);
                return {
                    pageIndex: parseInt(params.get('page'), 10) || 0,
                    subreddit: params.get('sub') || '',  
                    query: params.get('q') || '',
                    sort: params.get('sort') || 'hot',
                    time: params.get('time') || 'all',
                    contentType: params.get('type') || 'all'
                };
            }


        function applyFiltersToUI(filters) {
            //console.log('📦 Filters loaded:', filters);
            //console.log('🔍 contentType:', filters?.contentType);

            document.querySelector('#search-input').value = filters.query || '';
            document.querySelector('#subreddit-input').value = (filters.subreddit && filters.subreddit !== 'all') ? filters.subreddit : '';
            document.querySelector('#sort-select').value = filters.sort || 'relevance';
            document.querySelector('#time-select').value = filters.time || 'all';
            document.querySelector('#content-select').value = filters.contentType || 'all';

            // Manage chip UI
            const chipTextEl = subredditChipContainer.querySelector('.chip-text');
            if (!filters.subreddit || filters.subreddit === 'all') {
                subredditChipContainer.style.display = 'none';
                if (chipTextEl) chipTextEl.textContent = '';
            } else {
                subredditChipContainer.style.display = 'flex';
                if (chipTextEl) chipTextEl.textContent = `r/${filters.subreddit}`;
            }
        }


        function getCurrentFiltersFromUI() {
            const query = searchInput.value.trim();
            const subredditTyped = document.getElementById('subreddit-input').value.trim();
            const chipVisible = subredditChipContainer.style.display === 'flex';
            const subreddit = chipVisible
                ? subredditChipContainer.querySelector('.chip-text').textContent.replace('r/', '')
                : subredditTyped;
            return {
                query,
                time: document.getElementById('time-select').value,
                sort: document.getElementById('sort-select').value,
                contentType: document.getElementById('content-select').value,
                subreddit
            };
        }

        function setupSearchSuggestions(inputId, suggestionsId, dictionary) {
            let timeout;

            const input = document.getElementById(inputId);
            const suggestionsDiv = document.getElementById(suggestionsId);

            input.addEventListener('input', function (e) {
                const query = e.target.value;
                clearTimeout(timeout);

                input.addEventListener('click', function (e) {
                    const query = e.target.value.trim();
                    if (query) {
                        getSmartSuggestions(query, suggestionsDiv, dictionary);
                    }
                });

                timeout = setTimeout(() => {
                    getSmartSuggestions(query, suggestionsDiv, dictionary);
                }, 170);
            });

            // On click listener
            document.querySelector('#search-input').addEventListener('click', function () {
                const suggestionsDiv = document.querySelector('#suggestions');
                getSmartSuggestions(this.value, suggestionsDiv, dictionary);
            });
        }

        async function getSmartSuggestions(query, suggestionsDiv, dictionary) {
            let trimmedQuery = query.trim();

            // If empty, show top searches instead
            if (!trimmedQuery) {
                const response = await fetch(`${API_BASE}/api/top-searches`);
                const data = await response.json();
                const filteredData = data.filter(item => item.query.length > 2);
                displaySuggestions(filteredData, suggestionsDiv);
                return;
            }

            // Always spell check
            const correctedQuery = correctLastWord(trimmedQuery, dictionary);
            if (correctedQuery !== trimmedQuery) {
                trimmedQuery = correctedQuery;
            }

            // Recalculate words after potential correction
            const words = trimmedQuery.split(' ');
            const lastWord = words[words.length - 1];
            const fuse = new Fuse(dictionary, { threshold: 0.4 });

            // Get stored suggestions from database first
            let storedSuggestions = [];
            try {
                const subreddit = subredditInput.value?.trim() || '';
                const url = `${API_BASE}/api/suggestions?q=${encodeURIComponent(query)}`;
                const response = await fetch(url);
                const data = await response.json();
                storedSuggestions = data
                    .filter(item => item.query.length > 2)
                    .map(item => ({
                        query: item.query,
                        subreddit: item.subreddit,
                        isStored: true
                    }));
            } catch (error) {
                console.error("❌ Stored suggestions error:", error);
            }

            // Calculate remaining slots for pattern suggestions
            const remainingSlots = Math.max(0, 6 - storedSuggestions.length);
            let patternSuggestions = [];

            if (remainingSlots > 0) {
                const hasTrailingSpace = query.endsWith(' ');
                const isElonMode = (words.length === 1 && dictionary.includes(trimmedQuery.toLowerCase())) ||
                    (hasTrailingSpace && words.length === 1);
                if (isElonMode) {
                    // Search for next term after first word mode ('elon musk')
                    try {
                        const apiUrl = `https://api.datamuse.com/words?rel_trg=${encodeURIComponent(trimmedQuery)}&max=${remainingSlots}`;
                        const response = await fetch(apiUrl);
                        const data = await response.json();
                        const apiWords = data.map(item => `${trimmedQuery} ${item.word}`);

                        // If no API results, show the original query as fallback
                        if (apiWords.length === 0) {
                            patternSuggestions = [trimmedQuery];
                        } else {
                            patternSuggestions = [trimmedQuery, ...apiWords].slice(0, remainingSlots);
                        }
                    } catch (error) {
                        console.error("❌ Datamuse error:", error);
                        patternSuggestions = [trimmedQuery];
                    }
                } else {
                    // Complete the word mid-phrase mode ('grilled chick -> grilled chicken')
                    const results = fuse.search(lastWord).slice(0, remainingSlots - 1);
                    const fullSuggestions = results.map(result => {
                        const newWords = [...words];
                        newWords[newWords.length - 1] = result.item;
                        return newWords.join(' ');
                    });

                    // If no fuzzy results, show the original query as fallback
                    if (fullSuggestions.length === 0) {
                        patternSuggestions = [trimmedQuery];
                    } else {
                        patternSuggestions = [trimmedQuery, ...fullSuggestions].slice(0, remainingSlots);
                    }
                }
            }

            // Only filter out the original query if there are other suggestions
            if (patternSuggestions.length > 1) {
                patternSuggestions = patternSuggestions.filter(suggestion =>
                    suggestion.toLowerCase() !== trimmedQuery.toLowerCase()
                );
            }

            // Remove duplicates, keep stored suggestions first
            const seen = new Set();
            const deduplicated = [];

            storedSuggestions.forEach(suggestion => {
                const key = suggestion.query.toLowerCase().trim();
                if (!seen.has(key)) {
                    seen.add(key);
                    deduplicated.push(suggestion);
                }
            });

            patternSuggestions.forEach(suggestion => {
                const key = suggestion.toLowerCase().trim();
                if (!seen.has(key)) {
                    seen.add(key);
                    deduplicated.push(suggestion);
                }
            });

            displaySuggestions(deduplicated, suggestionsDiv);
        }

        function isIncompleteWord(word, dictionary) {
            return !dictionary.includes(word.toLowerCase());
        }

        function correctLastWord(query, dictionary) {
            const words = query.trim().split(' ');
            const lastWord = words[words.length - 1];

            // ✅ If the word is already in the dictionary, leave it alone
            if (dictionary.includes(lastWord.toLowerCase())) {
                return query;
            }

            const fuse = new Fuse(dictionary, {
                threshold: 0.4,
                includeScore: true,
            });

            let results = fuse.search(lastWord);

            if (results.length === 0) {
                return query; // no suggestions
            }

            // ✅ Penalize suggestions that are too long or short
            results = results.map(result => {
                const lenDiff = Math.abs(result.item.length - lastWord.length);
                const penalty = lenDiff * 0.01; // mild penalty
                return {
                    ...result,
                    adjustedScore: result.score + penalty,
                };
            });

            results.sort((a, b) => a.adjustedScore - b.adjustedScore);

            const best = results[0];
            const second = results[1];


            // ✅ Only correct if the match is pretty confident
            if (best.adjustedScore < 0.3) {
                words[words.length - 1] = best.item;
                return words.join(' ');
            }

            return query;
        }


        function displaySuggestions(suggestions, suggestionsDiv) {
            // Fuck 'contrabassoon' in particular, that actually came up in the word completion api
            const nsfwPattern = /(tits|titties|rape|raped|contrabassoon|fucking|fuck|fucker|fucked|breeder|tiddies|nudes|onlyfans|hentai|gonewild|boobs|cum|cock|shit|shits|shitted|shat|cocksucker|cocks|cunt|gape|gooning|gooner|goon|pussy|porn)/i;

            // Filter out NSFW suggestions
            const exceptions = /(peacock|woodcock|gamecock|cockpit|cocktail|cockroach|hancock|hitchcock|cucumber|circumference|document|accumulate|succumb|grape|drape|scrape|therapeutic)/i;
            const filteredSuggestions = suggestions.filter(suggestion => {
                const query = typeof suggestion === 'string' ? suggestion : suggestion.query;

                // If it matches an exception, keep it
                if (exceptions.test(query)) {
                    return true;
                }

                // Otherwise apply NSFW filter
                return !nsfwPattern.test(query);
            });

            const suggestionsHtml = filteredSuggestions.map(suggestion => {
                const word = typeof suggestion === 'string' ? suggestion : suggestion.query;
                const suggestionSubreddit = typeof suggestion === 'object' ? suggestion.subreddit : null;

                const iconContent = suggestionSubreddit ?
                    `<span class="suggestion-icon subreddit-icon">${suggestionSubreddit.charAt(0).toUpperCase()}</span>` :
                    '<img src="../assets/search-favicon.png" class="suggestion-favicon" alt="Search">';

                const subredditName = suggestionSubreddit ? `<span class="suggestion-subreddit">• r/${suggestionSubreddit.toLowerCase()}</span>` : '';

                return `<div onclick="selectSuggestion('${word}', 'search-input', 'suggestions', '${suggestionSubreddit || ''}')" data-subreddit="${suggestionSubreddit || ''}" class="suggestion-item">
            ${iconContent}
            ${word}
            ${subredditName}
        </div>`;
            }).join('');

            suggestionsDiv.innerHTML = suggestionsHtml;
            suggestionsDiv.style.display = 'block';

            // Add real icons for suggestions that have subreddit data
            const suggestionElements = suggestionsDiv.querySelectorAll('[data-subreddit]');
            suggestionElements.forEach(element => {
                const subredditName = element.getAttribute('data-subreddit');
                if (subredditName) {
                    addIconToSuggestion(element, subredditName);
                }
            });
        }

        async function addIconToSuggestion(suggestionElement, subreddit) {
            if (!subreddit) return;

            suggestionElement.querySelector('.suggestion-favicon')?.remove();

            const iconContainer = suggestionElement.querySelector('.suggestion-icon');

            // Start with letter fallback
            iconContainer.textContent = subreddit.charAt(0).toUpperCase();

            const storageKey = `subreddit_icon_${subreddit}`;
            const cachedIcon = sessionStorage.getItem(storageKey);

            // Check sessionStorage first
            if (cachedIcon && cachedIcon !== 'null' && cachedIcon !== '/api/placeholder/20/20') {
                const img = document.createElement('img');
                img.src = cachedIcon;
                img.alt = `Icon for r/${subreddit}`;
                img.className = 'subreddit-icon-img';
                iconContainer.textContent = '';
                iconContainer.appendChild(img);
                setTimeout(() => img.classList.add('fade-in'), 10);
                iconContainer.classList.add('icon-loaded');
            } else if (!cachedIcon || cachedIcon === 'null') {
                // Fetch from API
                getSubredditIcon(subreddit).then(iconUrl => {
                    if (iconUrl && iconUrl !== '/api/placeholder/20/20') {
                        const img = document.createElement('img');
                        img.src = iconUrl;
                        img.alt = `Icon for r/${subreddit}`;
                        img.className = 'subreddit-icon-img';
                        iconContainer.textContent = '';
                        iconContainer.appendChild(img);
                        setTimeout(() => img.classList.add('fade-in'), 10);
                        iconContainer.classList.add('icon-loaded');
                        sessionStorage.setItem(storageKey, iconUrl);
                    }
                });
            }
        }

        function selectSuggestion(word, inputId, suggestionsId, subreddit = null) {
            document.getElementById(inputId).value = word;
            document.getElementById(suggestionsId).innerHTML = '';

            // If this suggestion has a subreddit, auto-select it
            if (subreddit) {
                selectSubreddit(subreddit);
            }

            currentFilters = getCurrentFiltersFromUI();

            // Store/increment the suggestion
            if (word) {
                try {
                    const searchType = determineSearchType();
                    const isVectorSearch = searchType === 'vector';

                    fetch(`${API_BASE}/api/suggestions/store`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            query: word,
                            subreddit: (subreddit && subreddit !== 'undefined' && subreddit !== 'null') ? subreddit : null,
                            is_vector_search: isVectorSearch
                        })
                    });
                } catch (err) {
                    console.error("Failed to store suggestion:", err);
                }
            }

            // Reset page index and history for new search
            currentPageIndex = 0;
            handleSearchRequest();
        }

        function selectSubreddit(subName) {
            if (!subName || subName.toLowerCase() === 'all') {
                subredditChipContainer.style.display = 'none';

                return; // ⛔ don't show chip for default
            }

            subredditChipContainer.style.display = 'flex';
            subredditChipContainer.querySelector('.chip-text').textContent = 'r/' + subName;
            subredditInput.value = '';
            subredditSuggestions.classList.remove('active');
        }

        function buildCacheKey(baseToken, filters) {
            const encode = str => encodeURIComponent(str || '');

            const query = encode(filters.query);
            const subreddit = encode((filters.subreddit || 'all').toLowerCase());

            // Force 'ultimate' to be treated as 'hot' in cache key
            const rawSort = filters.sort || 'hot';
            const sort = encode(rawSort === 'ultimate' ? 'hot' : rawSort);

            const time = encode(filters.time || 'all');

            return `${baseToken}__${subreddit}__${sort}__${query}__${time}`;
        }

        function performEnhancedSearch() {
            //console.log("Enhanced Search Requested");
            //console.time('total-search');
            
            currentFilters = getCurrentFiltersFromUI();
            const query = currentFilters.query?.trim() || '';
            const subreddit = currentFilters.subreddit || null;

            // Handle empty cases
            if (!query && !subreddit) {
                showError("No search terms detected. 🔎");
                handleRandomResponse([
                    "Throw me a bone here.",
                    "I'm gonna need more than that.",
                    "That's not on my records.",
                    "Don't know where I'd find 'blankity blank blank.'",
                    "No can do."
                ]);
                return;
            }

            // If no query but has subreddit, fall back to regular search
            if (!query && subreddit) {
                handleSearchRequest(null, null, false, false, true);
                return;
            }

            if (subreddit && subreddit !== 'all') {
                saveRecentSubreddit(subreddit);
            }

            //console.log('🔍 Enhanced Search Request:');
            //console.log('  Query:', query);
            //console.log('  Subreddit:', subreddit);
            //console.log('  Current Filters:', currentFilters);
            document.querySelector('.vector-scroll-loader')?.remove();
            showLoading();
            //console.time('fetch-request');

            // Only do vector search if there is a query
            fetch(`${API_BASE}/api/vector-search`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    query: query,
                    subreddit: subreddit === 'all' ? null : subreddit,
                    limit: 100, // Get 100 results for scrollination
                    timeFilter: currentFilters.time || 'all'
                })
            })
                .then(response => {
                    //console.timeEnd('fetch-request');
                    //console.time('response-processing');
                    return response.json();
                })
                .then(vectorData => {
                    // Store all results for scrollination
                    const allResults = vectorData.data.children.map(trimRedditPostData);

                    // Only show first 10 initially
                    const initialResults = allResults.slice(0, 10);
                    // Generate pagination token from the last post shown
                    const paginationToken = initialResults.length === 10 ? `t3_${initialResults[9].id}` : null;

                    // Set global tokens
                    currentAfter = paginationToken;
                    currentBefore = null;

                    // Save history
                    savePaginationState(initialResults);
                    // Store for scrollination
                    currentVectorResults = allResults;
                    currentVectorOffset = 10;
                    hasMoreVectorResults = allResults.length > 10;

                    displayResults(initialResults);
                    preloadBookmarks();
                    window.scrollTo(0, 0);
                    paginationContainer.innerHTML = '';
                    updateURL();
                    // Create vector scroll indicator 
                    if (!document.querySelector('.vector-scroll-loader')) {
                        const indicator = document.createElement('div');
                        indicator.className = 'vector-scroll-loader';
                        indicator.style.display = 'flex';
                        indicator.innerHTML = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="6 9 12 15 18 9"></polyline>
                        </svg>`;
                        document.body.appendChild(indicator);
                    }

                    // Position the indicator
                    positionVectorScrollIndicator();
                    setupVectorScrollListener();
                    //console.timeEnd('response-processing');
                    //console.timeEnd('total-search');
                })
                .catch(error => {
                    //console.timeEnd('fetch-request');
                    //console.timeEnd('response-processing');
                    //console.timeEnd('total-search');
                    //console.error('Vector search failed:', error);
                    showError("Vector search failed");
                });
        }

        function loadMoreVectorResults() {
            if (isVectorLoading || !hasMoreVectorResults) return;

            isVectorLoading = true;

            // Get next 10 results from currentVectorResults
            const nextResults = currentVectorResults.slice(currentVectorOffset, currentVectorOffset + 10);

            if (nextResults.length === 0) {
                hasMoreVectorResults = false;
                positionVectorScrollIndicator();
                isVectorLoading = false;
                return;
            }

            // Transform to the format displayResults expects
            const transformedData = {
                data: {
                    children: nextResults.map(post => ({ data: post }))
                }
            };

            // Display with isLoadMore = true
            displayResults(transformedData, true);

            // Update offset
            currentVectorOffset += 10;

            // Check if we have more
            if (currentVectorOffset >= currentVectorResults.length) {
                hasMoreVectorResults = false;
                // Hide indicator immediately when we've loaded everything
                const indicator = document.querySelector('.vector-scroll-loader');
                if (indicator) {
                    indicator.style.display = 'none';
                }
            }

            // Update indicator position
            positionVectorScrollIndicator();
            isVectorLoading = false;
        }

        function setupVectorScrollListener() {
            vectorScrollHandler = function () {
                // Only run during vector search - check if we have vector results
                if (!currentVectorResults.length || !hasMoreVectorResults || isVectorLoading) return;

                if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 100) {
                    loadMoreVectorResults();
                }
            };
            window.addEventListener('scroll', vectorScrollHandler);
            setTimeout(() => {
                paginationContainer.innerHTML = '';
            }, 1000);
        }

        function positionVectorScrollIndicator() {
            const indicator = document.querySelector('.vector-scroll-loader');
            if (!indicator) return;

            const footer = document.querySelector('footer');
            if (footer) {
                footer.appendChild(indicator);
                indicator.style.position = 'relative';
                indicator.style.top = '-210px';
                indicator.style.left = '50%';
                indicator.style.transform = 'translateX(-50%)';

                // ONLY show if we actually have more results
                if (hasMoreVectorResults) {
                    setTimeout(() => {
                        // Double-check hasMoreVectorResults in case it changed
                        if (hasMoreVectorResults) {
                            indicator.style.display = 'flex';
                        } else {
                            indicator.style.display = 'none';
                        }
                    }, 1000);
                } else {
                    // Hide immediately if no more results
                    indicator.style.display = 'none';
                }
            }
        }

        function determineSearchType() {
            const filters = getCurrentFiltersFromUI();
            const isEnhancedOn = document.getElementById('toggle1').checked;
            const hasQuery = filters.query && filters.query.trim() !== '';
            const hasSubreddit = filters.subreddit && filters.subreddit.trim() !== '';

            // First, reset title and housekeeping before search
            hideSpeechBubble();
            showRareLines();

            // Reset title and meta tags back to normal
            document.title = "KarmaFinder";
            document.querySelector('meta[name="description"]').content = "Find exactly what you're looking for on Reddit";
            document.querySelector('meta[property="og:title"]').content = "KarmaFinder";

            // Enhanced search with query = vector search
            if (isEnhancedOn && hasQuery) {
                return 'vector';
            }

            // Enhanced search with only subreddit = regular search  
            if (isEnhancedOn && hasSubreddit && !hasQuery) {
                return 'regular';
            }

            // Progressive search conditions (ONLY when enhanced is OFF)
            if (!isEnhancedOn) {
                const hasTimeFilter = filters.time !== 'all';
                const hasContentFilter = filters.contentType !== 'all';
                const isHotOrNew = filters.sort === 'new' || filters.sort === 'hot';
                const needsProgressive = (isHotOrNew && hasTimeFilter) || hasContentFilter;

                if (needsProgressive) {
                    return 'progressive';
                }
            }

            // Default to regular search
            return 'regular';
        }

        function handleSearchRequest(after = null, before = null, navigateBack = false, isInitialLoad = false) {
            if (isPopstateEvent) navigateBack = true;

            // Clean after/before tokens from URL when landing on first page
            if (currentPageIndex === 0) {
                const params = new URLSearchParams(window.location.search);
                params.delete('after');
                params.delete('before');
                const newURL = `${window.location.pathname}?${params.toString()}`;

                window.history.replaceState({}, '', newURL);
                const tabsSection = document.querySelector('.tabs-section');
                if (tabsSection) tabsSection.remove();
            }

            const searchType = determineSearchType();

            // Remove vector scroll behavior if switching away
            if (searchType !== 'vector' && vectorScrollHandler) {
                window.removeEventListener('scroll', vectorScrollHandler);
                vectorScrollHandler = null;
                const indicator = document.querySelector('.vector-scroll-loader');
                if (indicator) indicator.remove();
            }

            // Reset pagination + clean URL if new progressive search
            if (!navigateBack && searchType === 'progressive') {
                currentPageIndex = 0;
                currentAfter = null;
                currentBefore = null;
                isPopstateEvent = false;
            }

            switch (searchType) {
                case 'vector':
                    return performEnhancedSearch(after, before, navigateBack, isInitialLoad);
                case 'progressive':
                    return performProgressiveSearch(after, before, navigateBack, isInitialLoad);
                case 'regular':
                default:
                    return performSearch(after, before, navigateBack, isInitialLoad);
            }
        }

        async function performProgressiveSearch(after = null, before = null, navigateBack = false, isInitialLoad = false) {
            //console.log("🚀 Progressive search initiated...");

            showLoading();

            if (navigateBack || isPopstateEvent) {
                const cachedPage = loadPageDataFromSession(currentPageIndex);
                if (cachedPage?.results?.length) {
                    //console.log("🧭 Using cached page from session (back/forward)");

                    currentAfter = cachedPage.after || null;
                    currentBefore = cachedPage.before || null;

                    displayResults(cachedPage.results);
                    preloadBookmarks(window.stripeCustomerId);
                    updatePagination();
                    updateURL();
                    window.scrollTo(0, 0);
                    return;
                }
            }

            const filters = getCurrentFiltersFromUI();
            const query = filters.query?.trim() || '';
            const subreddit = filters.subreddit || '';
            const sort = filters.sort;
            const time = filters.time;
            const contentType = filters.contentType;

            const limit = 10;
            const MAX_FETCHES = 5;
            let fetchCount = 0;
            let allFilteredPosts = [];
            let currentAfterToken = after || currentAfter;

            //console.log(`➡️ Starting search from page ${currentPageIndex}, after token: ${currentAfterToken}`);

            async function fetchBatch() {
                const finalUrl = buildRedditUrl(query, subreddit, sort, time, limit, currentAfterToken);
                //console.log(`🌐 Fetching from Reddit URL: ${finalUrl}`);
                const response = await fetch(`${API_BASE}/reddit?url=${encodeURIComponent(finalUrl)}`);
                const data = await response.json();
                return data;
            }

            while (allFilteredPosts.length < 10 && fetchCount < MAX_FETCHES) {
                fetchCount++;
                //console.log(`🔄 Fetch attempt ${fetchCount}/${MAX_FETCHES}`);

                try {
                    const batchData = await fetchBatch();

                    if (!batchData.data.children?.length) {
                        //console.log('🛑 No posts returned, ending fetch loop.');
                        break;
                    }

                    const trimmedData = batchData.data.children.map(post => trimRedditPostData(post));
                    let filteredBatch = filterPostsByTime(trimmedData, time);
                    filteredBatch = filterPostsByContent(filteredBatch, contentType);

                    if (fetchCount === 1 && filteredBatch.length === 0) {
                        //console.log('🛑 First fetch had no relevant results, stopping early.');
                        break;
                    }

                    if (trimmedData.length && filteredBatch.length === 0 && time !== 'all') {
                        //console.log('🛑 Got posts but none matched time filter, stopping.');
                        break;
                    }

                    allFilteredPosts.push(...filteredBatch);
                    //console.log(`🎯 Filtered posts collected: ${allFilteredPosts.length}`);

                    currentAfterToken = batchData.data.after;
                    //console.log(`⬅️ Received new after token: ${currentAfterToken}`);

                    if (!currentAfterToken) {
                        //console.log('🛑 No more pages, end of feed.');
                        break;
                    }

                } catch (err) {
                    console.error('❌ Error during fetch:', err);
                    break;
                }
            }

            const finalResults = allFilteredPosts.slice(0, 10);
            const paginationToken = finalResults.length === 10 ? `t3_${finalResults[9].id}` : null;

            //console.log(`🧭 Final paginationToken: ${paginationToken}`);
            //console.log(`💾 Saving page ${currentPageIndex} with ${finalResults.length} results.`);

            currentFilters = filters;
            currentBefore = null;
            currentAfter = paginationToken;

            savePaginationState(finalResults);
            displayResults(finalResults);
            preloadBookmarks();
        }

















    function performSearch(after = null, before = null, navigateBack = false, isInitialLoad = false) {
        //console.log('🟢 performSearch() called with:', { after, before, navigateBack, isInitialLoad });
        //console.log('🔍 Current Index:', currentPageIndex);

        // Handle back navigation with saved page state
        if (navigateBack || isPopstateEvent) {
            currentFilters = getFiltersFromURL();
        } else {
            currentFilters = getCurrentFiltersFromUI();
        }

        const query = currentFilters.query?.trim() || '';
        const subreddit = currentFilters.subreddit || '';
        const sort = currentFilters.sort || 'hot';
        const time = currentFilters.time || 'all';
        const contentType = currentFilters.contentType || 'all';
        const limit = 10;

        // Clear tokens if we're on front page (page 0)
        if (currentPageIndex === 0) {
            currentAfter = null;
            currentBefore = null;
            after = null;
            before = null;
        }

        // Handle back navigation with saved page state
        if (navigateBack || isPopstateEvent) {
            currentFilters = getFiltersFromURL();
            const cachedPage = loadPageDataFromSession(currentPageIndex);

            if (
                cachedPage?.results?.length &&
                cachedPage.query === currentFilters.query &&
                cachedPage.subreddit === currentFilters.subreddit
            ) {
                //console.log("🧭 Using cached page from session (back/forward)");

                currentAfter = cachedPage.after || null;
                currentBefore = cachedPage.before || null;

                const tokenForThisPage = buildCacheKey(
                    currentPageIndex === 0 ? 'page_1' : currentAfter,
                    currentFilters
                );
                //console.log('🏷️ Token for this page (cached):', tokenForThisPage);

                displayResults(cachedPage.results);
                preloadBookmarks(window.stripeCustomerId);
                updatePagination();
                updateURL();
                window.scrollTo(0, 0);
                return;
            }
        }

        // Set tokens
        if (!navigateBack) {
            currentAfter = after || currentAfter;
            currentBefore = before || currentBefore;
        }

        if (subreddit && subreddit !== 'all') {
            saveRecentSubreddit(subreddit);
        }

        // Generate a consistent cache key for DB + Redis
        const tokenForThisPage = buildCacheKey(currentPageIndex === 0 ? 'page_1' : currentAfter, currentFilters);
        //console.log('🏷️ Token for this page:', tokenForThisPage);

        // Build Reddit URL
        const finalUrl = buildRedditUrl(query, subreddit, sort, time, limit, currentAfter, currentBefore);
        //console.log('🔍 Filters applied:', currentFilters);
        //console.log('🔗 Final Reddit URL:', finalUrl);

        // Build backend query
        const params = new URLSearchParams();
        if (subreddit && subreddit !== 'all') params.append('subreddit', subreddit);
        if (query) params.append('query', query);
        if (time !== 'all') params.append('time', time);
        if (sort) params.append('sort', sort);
        if (after) params.append('after', after);
        params.append('limit', limit.toString());

        showLoading();

        // Attempt DB fetch first
        fetch(`${API_BASE}/api/db-posts?${params.toString()}`)
            .then(res => res.json())
            .then(dbResult => {
                if (!dbResult || !dbResult.data || !Array.isArray(dbResult.data.children) || dbResult.data.children.length === 0) {
                    //console.log('No DB results. Falling back to Reddit API.');
                } else {
                    //console.log(`🗃️ Loaded ${dbResult.data.children.length} posts from DB`);
                    currentAfter = dbResult.data.after || null;
                    currentBefore = dbResult.data.before || null;
                    const trimmedData = dbResult.data.children.map(trimRedditPostData);
                    const filtered = filterPostsByTime(trimmedData, currentFilters.time);
   
                    saveAfterToken(currentFilters, currentPageIndex + 1, currentAfter);
                    savePaginationState(filtered);
           
                    displayResults(filtered);
                    preloadBookmarks(window.stripeCustomerId);
                    updatePagination();
                    updateURL();
                    window.scrollTo(0, 0);
                    return;
                }

                // Reddit API fallback
                return fetch(`${API_BASE}/reddit?url=${encodeURIComponent(finalUrl)}`)
                    .then(res => {
                        if (!res.ok) throw new Error('Reddit API failed');
                        return res.json();
                    })
                    .then(data => {
                        currentAfter = data.data.after || null;
                        currentBefore = data.data.before || null;

                        const trimmedData = data.data.children.map(trimRedditPostData);
                        const filtered = filterPostsByTime(trimmedData, currentFilters.time);

                        if (filtered.length === 10) {
                            savePostsToDatabase(filtered.map(p => ({ data: p })), tokenForThisPage);
                        }
  
                        saveAfterToken(currentFilters, currentPageIndex + 1, currentAfter);
                        savePaginationState(filtered);

                        displayResults(filtered);
                        preloadBookmarks();
                        setTimeout(() => {
                            if (!filtered.length) noResultsMessage();
                        }, 0);

                        updatePagination();
                        updateURL();
                        window.scrollTo(0, 0);
                    });
            })
            .catch(err => {
                showError("Something went wrong. Please try again.");
            });
    }







        function loadAfterToken(filters, index) {
                const key = `kf_after_${index}`;
                const raw = sessionStorage.getItem(key);
                if (!raw) return null;

                const data = JSON.parse(raw);
                if (
                    data.query === filters.query &&
                    data.subreddit === filters.subreddit &&
                    data.sort === filters.sort &&
                    data.time === filters.time &&
                    data.contentType === filters.contentType
                ) {
                    return data.after || null;
                }

                return null;
            }

        function saveAfterToken(filters, index, afterToken) {
            if (!afterToken) return;

            const key = `kf_after_${index}`;
            const data = {
                query: filters.query,
                subreddit: filters.subreddit,
                sort: filters.sort,
                time: filters.time,
                contentType: filters.contentType,
                after: afterToken
            };

            sessionStorage.setItem(key, JSON.stringify(data));
        }


        function trimRedditPostData(post) {
            return {
                id: post.data.id,
                title: post.data.title,
                url: post.data.url,
                permalink: post.data.permalink,
                subreddit: post.data.subreddit,
                score: post.data.score,
                is_video: post.data.is_video,
                domain: post.data.domain,
                author: post.data.author,
                created_utc: post.data.created_utc,
                num_comments: post.data.num_comments,
                over_18: post.data.over_18,
                preview: post.data.preview,
                selftext: post.data.selftext,
                body: post.data.body,
                is_gallery: post.data.is_gallery,
                gallery_data: post.data.gallery_data,
                media_metadata: post.data.media_metadata,
                crosspost_parent_list: post.data.crosspost_parent_list || [],
                content_type: post.data.content_type || '',
                icon_url: null,
                locked: post.data.locked,
                stickied: post.data.stickied
            };
        }

        function tryGalleryPatch(fullPost, permalink, resultCard, attempt = 1) {
            const galleryData = fullPost.gallery_data?.items;
            const mediaMetadata = fullPost.media_metadata;

            // Don't proceed if essential pieces are missing
            if (!galleryData || !mediaMetadata || !resultCard) {
                if (!resultCard && attempt < 5) {
                    setTimeout(() => tryGalleryPatch(fullPost, permalink, resultCard, attempt + 1), 100);
                }
                return;
            }

            const imgContainer = resultCard.querySelector('.img-container');
            const imgWrapper = resultCard.querySelector('.image-wrapper');
            if (!imgContainer || !imgWrapper) {
                return;
            }

            // Send gallery data to modal
            imgWrapper.galleryData = galleryData;
            imgWrapper.mediaMetadata = mediaMetadata;
            imgWrapper.currentIndex = 0;

            const { useSameSize } = analyzeGalleryAspectRatios(galleryData, mediaMetadata);
            imgWrapper.useSameSize = useSameSize;

            // Initialize gallery state
            let currentIndex = 0;
            const totalImages = galleryData.length;
            const preloadedImages = {};
            imgWrapper.preloadedImages = preloadedImages;
            let navigationSequence = 0;

            // Add gallery navigation elements
            if (!imgWrapper.querySelector('.gallery-nav')) {
                // Make image-wrapper relative for absolute positioning
                imgWrapper.style.position = 'relative';

                // Create navigation container
                const navContainer = document.createElement('div');
                navContainer.className = 'gallery-nav';

                // Left arrow
                const leftArrow = document.createElement('button');
                leftArrow.className = 'gallery-arrow gallery-arrow-left';
                leftArrow.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none">
            <path d="M15 18l-6-6 6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    `;
                leftArrow.style.cssText = `
        position: absolute;
        left: 2px;
        top: 50%;
        transform: translateY(-50%);
        background: rgba(0, 0, 0, 0.5);
        color: white;
        border: none;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        cursor: pointer;
        z-index: 10;
        display: flex;
        align-items: center;
        justify-content: center;
    `;

                // Right arrow
                const rightArrow = document.createElement('button');
                rightArrow.className = 'gallery-arrow gallery-arrow-right';
                rightArrow.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none">
            <path d="M9 18l6-6-6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    `;
                rightArrow.style.cssText = `
        position: absolute;
        right: 2px;
        top: 50%;
        transform: translateY(-50%);
        background: rgba(0, 0, 0, 0.5);
        color: white;
        border: none;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        cursor: pointer;
        z-index: 10;
        display: flex;
        align-items: center;
        justify-content: center;
    `;

                // Counter
                const counter = document.createElement('div');
                counter.className = 'gallery-counter';
                counter.style.cssText = `
                position: absolute;
                top: 3px;
                right: 3px;
                background: rgba(0, 0, 0, 0.5);
                color: white;
                padding: 3px 7px;
                border-radius: 10px;
                font-size: 10px;
                font-weight: bold;
                z-index: 10;
            `;

                // Update counter function
                const updateCounter = () => {
                    counter.textContent = `${currentIndex + 1}/${totalImages}`;
                };

                const preloadNextImage = (index) => {
                    if (!preloadedImages[index]) {
                        const item = galleryData[index];
                        const mediaId = item.media_id;
                        const media = mediaMetadata[mediaId];
                        const original = media?.s?.u?.replace(/&amp;/g, '&');
                        const resolutionFallback = media?.p?.[media.p.length - 1]?.u?.replace(/&amp;/g, '&');
                        const imageUrl = original || resolutionFallback;

                        if (imageUrl) {
                            const img = new Image();
                            const proxyUrl = `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(imageUrl)}&t=${Date.now()}`;
                            img.src = proxyUrl;
                            preloadedImages[index] = img;
                        }
                    }
                };

                const preloadAllImages = () => {

                    // Preload 2 back, current, and 5 forward 
                    for (let i = -2; i <= 5; i++) {
                        const index = (currentIndex + i + totalImages) % totalImages;

                        if (!preloadedImages[index]) {
                            const item = galleryData[index];
                            const mediaId = item.media_id;
                            const media = mediaMetadata[mediaId];
                            const original = media?.s?.u?.replace(/&amp;/g, '&');
                            const resolutionFallback = media?.p?.[media.p.length - 1]?.u?.replace(/&amp;/g, '&');
                            const imageUrl = original || resolutionFallback;

                            if (imageUrl) {
                                const img = new Image();
                                const proxyUrl = `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(imageUrl)}&t=${Date.now()}`;

                                img.onerror = () => {

                                    // First retry after 500ms
                                    setTimeout(() => {
                                        const retryImg1 = new Image();
                                        retryImg1.src = proxyUrl;
                                        retryImg1.onload = () => {
                                            preloadedImages[index] = retryImg1;
                                        };
                                        retryImg1.onerror = () => {

                                            // Second retry after additional 1000ms
                                            setTimeout(() => {
                                                const retryImg2 = new Image();
                                                retryImg2.src = proxyUrl;
                                                retryImg2.onload = () => {
                                                    preloadedImages[index] = retryImg2;
                                                };
                                                retryImg2.onerror = () => {
                                                };
                                            }, 1000);
                                        };
                                    }, 500);
                                };

                                img.src = proxyUrl;
                                preloadedImages[index] = img;
                            }
                        }
                    }
                };

                const updatePreloadStatus = () => {
                    const readyCount = Object.values(preloadedImages).filter(img => img.complete).length;
                };

                const navigateGallery = (direction) => {
                    navigationSequence++;
                    const thisNavigationId = navigationSequence;

                    const resultImg = resultCard.querySelector('img.result-image');
                    const imgWrapper = resultCard.querySelector('.image-wrapper');

                    if (!resultImg || !imgWrapper) {
                        return;
                    }

                    const targetIndex = direction === 'prev'
                        ? (currentIndex > 0 ? currentIndex - 1 : totalImages - 1)
                        : (currentIndex < totalImages - 1 ? currentIndex + 1 : 0);

                    const mediaId = galleryData[targetIndex].media_id;
                    const media = mediaMetadata[mediaId];
                    const original = media?.s?.u?.replace(/&amp;/g, '&');
                    const resolutionFallback = media?.p?.[media.p.length - 1]?.u?.replace(/&amp;/g, '&');
                    const imageUrl = original || resolutionFallback;

                    if (!imageUrl) {
                        return;
                    }

                    const newImg = new Image();
                    newImg.className = 'result-image';
                    newImg.navigationId = thisNavigationId;

                    const isComfyMode = document.body.classList.contains('comfy-mode');

                    if (useSameSize && isComfyMode && imgWrapper.comfyFirstWidth && imgWrapper.comfyFirstHeight) {
                        newImg.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: ${imgWrapper.comfyFirstWidth}px !important;
            height: ${imgWrapper.comfyFirstHeight}px !important;
            object-fit: cover;
            transform: ${direction === 'prev' ? 'translateX(-100%)' : 'translateX(100%)'};
            transition: transform 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.2s ease-in-out;
            opacity: 0;
        `;
                    } else {
                        newImg.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: ${direction === 'prev' ? 'translateX(-100%)' : 'translateX(100%)'};
            transition: transform 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.2s ease-in-out;
            opacity: 0;
        `;
                    }

                    Array.from(imgWrapper.children).forEach(child => {
                        if (child.classList.contains('result-image') && child !== resultImg) {
                            child.remove();
                        }
                    });

                    imgWrapper.appendChild(newImg);

                    const finalizeImageTransition = () => {
                        if (thisNavigationId !== navigationSequence) {
                            newImg.remove();
                            return;
                        }

                        currentIndex = targetIndex;
                        updateCounter();

                        newImg.offsetHeight;

                        // Start new image's slide-in and fade-in
                        newImg.style.transform = 'translateX(0)';
                        newImg.style.opacity = '1';

                        // Start old image's slide-out and fade-out
                        resultImg.style.transform = direction === 'prev' ? 'translateX(100%)' : 'translateX(-100%)';
                        resultImg.style.opacity = '0';
                        resultImg.style.transition = 'transform 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.2s ease-in-out';

                        // This timeout removes the OLD image after its transition.
                        setTimeout(() => {
                            if (thisNavigationId === navigationSequence && resultImg && resultImg.parentNode) {
                                resultImg.remove();
                            }
                        }, 450);

                        setTimeout(() => {
                            if (thisNavigationId === navigationSequence) {
                                newImg.style.position = '';
                                newImg.style.top = '';
                                newImg.style.left = '';
                                newImg.style.transition = '';
                            }
                        }, 450);
                    };

                    // Force wait on decoding
                    if (preloadedImages[targetIndex] && preloadedImages[targetIndex].complete) {
                        // Force decode the preloaded image before using it
                        preloadedImages[targetIndex].decode().then(() => {
                            if (thisNavigationId !== navigationSequence) {
                                newImg.remove();
                                return;
                            }
                            newImg.src = preloadedImages[targetIndex].src;
                            finalizeImageTransition();
                        }).catch(() => {
                            // Fallback if decode fails
                            const proxyUrl = `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(imageUrl)}&t=${Date.now()}`;
                            newImg.onload = () => finalizeImageTransition();
                            newImg.src = proxyUrl;
                        });
                    } else {
                        // Fallback to loading on-demand
                        const proxyUrl = `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(imageUrl)}&t=${Date.now()}`;

                        newImg.onload = () => {
                            if (thisNavigationId !== navigationSequence) {
                                newImg.remove();
                                return;
                            }
                            finalizeImageTransition();
                        };
                        newImg.onerror = () => {
                            if (thisNavigationId === navigationSequence) {
                                newImg.remove();
                            }
                        };
                        newImg.src = proxyUrl;
                    }

                    if (direction === 'next') {
                        const preloadIndex = (targetIndex + 6) % totalImages;
                        preloadNextImage(preloadIndex);
                    } else {
                        const preloadIndex = (targetIndex - 3 + totalImages) % totalImages;
                        preloadNextImage(preloadIndex);
                    }
                };

                // Throttling variables
                let lastNavigationTime = 0;
                const THROTTLE_DELAY = 70; // 70ms delay

                leftArrow.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const now = Date.now();
                    if (now - lastNavigationTime >= THROTTLE_DELAY) {
                        lastNavigationTime = now;
                        navigateGallery('prev');
                    }
                });

                leftArrow.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        e.stopPropagation();
                        const now = Date.now();
                        if (now - lastNavigationTime >= THROTTLE_DELAY) {
                            lastNavigationTime = now;
                            navigateGallery('prev');
                        }
                    }
                });

                rightArrow.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const now = Date.now();
                    if (now - lastNavigationTime >= THROTTLE_DELAY) {
                        lastNavigationTime = now;
                        navigateGallery('next');
                    }
                });

                rightArrow.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        e.stopPropagation();
                        const now = Date.now();
                        if (now - lastNavigationTime >= THROTTLE_DELAY) {
                            lastNavigationTime = now;
                            navigateGallery('next');
                        }
                    }
                });

                // Hide arrows if only one image
                if (totalImages <= 1) {
                    leftArrow.style.display = 'none';
                    rightArrow.style.display = 'none';
                }

                // Add elements to wrapper
                navContainer.appendChild(leftArrow);
                navContainer.appendChild(rightArrow);
                navContainer.appendChild(counter);
                imgWrapper.appendChild(navContainer);

                // Initialize counter
                updateCounter();
                preloadAllImages(currentIndex);
            }

            const mediaId = galleryData[0]?.media_id;
            const media = mediaMetadata[mediaId];

            // Force container visible if valid
            if (imgContainer.style.visibility === 'hidden') {
                imgContainer.style.visibility = 'visible';
            }

            // Ensure shimmer exists
            let shimmer = resultCard.querySelector('.image-placeholder');
            if (!shimmer) {
                shimmer = document.createElement('div');
                shimmer.className = 'image-placeholder shimmer';
                imgWrapper.prepend(shimmer);
            } else {
                shimmer.style.display = 'block';
            }

            // Gather best available image sources
            const original = media?.s?.u?.replace(/&amp;/g, '&');
            const resolutionFallback = media?.p?.[media.p.length - 1]?.u?.replace(/&amp;/g, '&');
            const fallbacks = [original, resolutionFallback].filter(Boolean);

            // Your existing patchImage logic...
            const patchImage = (img) => {
                const trySrc = (index = 0) => {
                    if (index >= fallbacks.length) {
                        img.style.display = 'none';
                        showNewsIcon(imgWrapper, shimmer);
                        return;
                    }
                    const fallbackURL = `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(fallbacks[index])}&t=${Date.now()}`;
                    img.onerror = () => {
                        trySrc(index + 1);
                    };
                    img.onload = () => {
                        img.classList.add('show');
                        img.style.opacity = '1';
                        shimmer.style.display = 'none';

                        // Capture first thumbnail size for comfy mode fixed sizing
                        if (useSameSize && document.body.classList.contains('comfy-mode') && !imgWrapper.comfyFirstWidth) {
                            imgWrapper.comfyFirstWidth = img.offsetWidth;
                            imgWrapper.comfyFirstHeight = img.offsetHeight;
                        }
                    };
                    img.src = fallbackURL;
                };
                trySrc();
            };

            const resultImg = resultCard.querySelector('img.result-image');
            if (resultImg) {
                patchImage(resultImg);
            } else if (attempt < 3) {
                setTimeout(() => tryGalleryPatch(fullPost, permalink, resultCard, attempt + 1), 100);
            }
        }

        function buildRedditUrl(query, subreddit, sort, time, limit, after = null, before = null) {
            let finalUrl = '';
            const isQuerying = query && query.length > 0;
            const encodedQuery = encodeURIComponent(query || '');

            // Convert ultimate sort to hot for Reddit API
            const redditSort = (sort === 'ultimate') ? 'hot' : sort;

            if (isQuerying) {
                finalUrl = `https://www.reddit.com${subreddit ? `/r/${subreddit}` : ''}/search.json?q=${encodedQuery}&sort=${redditSort}&restrict_sr=1&limit=${limit}&t=${time}`;
            } else if (subreddit) {
                finalUrl = `https://www.reddit.com/r/${subreddit}/${redditSort}.json?limit=${limit}&t=${time}`;
            } else {
                finalUrl = `https://www.reddit.com/r/all/${redditSort}.json?limit=${limit}&t=${time}`;
            }

            if (after) finalUrl += `&after=${after}`;
            if (before) finalUrl += `&before=${before}`;

            return finalUrl;
        }

        function noResultsMessage() {
            showError("Couldn't find those terms. 🔎");
            handleRandomResponse([
                "I couldn't find that, kid.",
                "Sorry, squirt.",
                "That's not on my records.",
                "Shucks.",
                "Nada.",
                "I got nothin'.",
                "Not familiar with that.",
                "That's a dead end.",
                "Not in my files.",
                "Never heard of that place.",
                "Zilch.",
                "No can do."
            ]);
        }

        function showNewsIcon(imgWrapper, shimmer) {
            // Hide shimmer if it exists
            if (shimmer) {
                shimmer.style.display = 'none';
            }

            // Also try to find shimmer directly if not passed
            if (!shimmer) {
                const foundShimmer = imgWrapper.querySelector('.image-placeholder');
                if (foundShimmer) {
                    foundShimmer.style.display = 'none';
                }
            }

            // Find and remove the existing result-image
            const existingImg = imgWrapper.querySelector('.result-image');
            if (existingImg) {
                existingImg.remove();
            }

            // Create and show news icon
            const newsIcon = document.createElement('div');
            newsIcon.className = 'news-icon-fallback';
            newsIcon.setAttribute('aria-label', 'Article thumbnail');
            newsIcon.style.opacity = '0';
            newsIcon.style.transition = 'opacity 0.3s ease-in-out';
            imgWrapper.appendChild(newsIcon);

            // Fade in news icon
            setTimeout(() => {
                newsIcon.style.opacity = '1';
            }, 10);
        }

        function filterPostsByContent(posts, contentType) {
            if (contentType === 'all') {
                return posts;
            }

            return posts.filter(post => {
                const postContentType = classifyContentType(post);
                return postContentType === contentType;
            });
        }

        function filterPostsByTime(posts, timeFilter) {
            if (timeFilter === 'all') {
                return posts;
            }

            const now = Math.floor(Date.now() / 1000);
            let timeCutoff = 0;

            switch (timeFilter) {
                case "hour": timeCutoff = now - 7140; break;     // 119 minutes
                case "day": timeCutoff = now - 169200; break;    // 47 hours  
                case "week": timeCutoff = now - 604800; break;   // 7 days
                case "month": timeCutoff = now - 2592000; break; // 30 days
                case "year": timeCutoff = now - 31536000; break; // 365 days
                default: timeCutoff = 0;
            }

            return posts.filter(post => post.created_utc >= timeCutoff);
        }


        async function displayResults(data, isAppend = false) {
            // For append mode in bookmarks
            if (!isAppend) {
                resultsContainer.style.opacity = 0;
                resultsContainer.innerHTML = '';
            }

            const selectedFilter = document.getElementById('content-select').value;
            const isFromCache = Array.isArray(data);
            const posts = isFromCache
                ? data
                : data.data?.children.map(item => item.data) || [];

            if (!isFromCache) {
                currentAfter = data.data?.after || null;
                currentBefore = data.data?.before || null;
            }

            // Process posts in batches of 3
            const BATCH_SIZE = 3;

            for (let i = 0; i < posts.length; i += BATCH_SIZE) {
                const batch = posts.slice(i, i + BATCH_SIZE);

                // Display results
                for (const post of batch) {
                    const postId = post.id || (post.permalink?.split("/")[4] ?? "unknown_id");
                    const bookmarkId = post.id || post.reddit_post_id;
                    const redditPostId = post.reddit_post_id || (post.name?.startsWith('t3_') ? post.name.slice(3) : undefined);

                    let postContentType;

                    // Display domain in url
                    //console.log(post)

                    // Extract selftext preview image if available
                    const selftextPreview = extractPreviewFromSelftext(post.selftext);
                    if (selftextPreview && post.url && (post.url.includes('/comments/') || post.url.includes('reddit.com'))) {
                        post.url = selftextPreview;
                    }

                    const domain = getDomainFromUrl(post.url);

                    const title = decodeEntities(post.title?.toLowerCase() || '');
                    const isProbablyNSFW = post.over_18 || /\b(tits|titties|rape|raped|tiddies|hentai|nudes|onlyfans|boobs|cum|cock|cocks|cunt|gape|gooning|gooner|goon|pussy)\b/i.test(title);

                    const resultCard = document.createElement('div');
                    resultCard.className = 'result-card';
                    resultCard.dataset.permalink = post.permalink;
                    resultCard.dataset.bookmarkId = bookmarkId;

                    if (isProbablyNSFW) {
                        resultCard.classList.add('nsfw');
                    }

                    // Create comments section outer shell
                    const commentsSection = document.createElement('div');
                    commentsSection.className = 'comments-section';

                    // Create inner scrollable area
                    const commentsScroll = document.createElement('div');
                    commentsScroll.className = 'comments-scroll';

                    // Put a loading message in the scroll area
                    commentsScroll.innerHTML = '<div class="no-comments">Loading comments...</div>';

                    // Append scrollable div inside the outer container
                    commentsSection.appendChild(commentsScroll);

                    // Fetch comments INTO the inner scrollable div
                    fetchComments(post.permalink, commentsScroll);

                    // Vote section
                    const voteSection = document.createElement('div');
                    voteSection.className = 'vote-section';

                    if (post.stickied) {
                        // Pushpin for sticky posts
                        const pushpinIcon = document.createElement('div');
                        pushpinIcon.className = 'pushpin-icon';
                        voteSection.appendChild(pushpinIcon);
                    }

                    const permalinkUrl = `https://www.reddit.com${post.permalink}`;

                    const upvoteBtn = document.createElement('a');
                    upvoteBtn.href = permalinkUrl;
                    upvoteBtn.target = '_blank';
                    upvoteBtn.className = 'vote-button-red';
                    upvoteBtn.innerHTML = `
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="18 15 12 9 6 15"></polyline>
        </svg>`;

                    const voteCount = document.createElement('div');
                    voteCount.className = 'vote-count';
                    voteCount.textContent = formatNumber(post.score);

                    const downvoteBtn = document.createElement('a');
                    downvoteBtn.href = permalinkUrl;
                    downvoteBtn.target = '_blank';
                    downvoteBtn.className = 'vote-button';
                    downvoteBtn.innerHTML = `
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="6 9 12 15 18 9"></polyline>
        </svg>`;

                    voteSection.appendChild(upvoteBtn);
                    voteSection.appendChild(voteCount);
                    voteSection.appendChild(downvoteBtn);

                    // Content section
                    const contentSection = document.createElement('div');
                    contentSection.className = 'content-section';

                    // Result header with subreddit, author, time
                    const resultHeader = document.createElement('div');
                    resultHeader.className = 'result-header';

                    const subredditLink = document.createElement('a');
                    subredditLink.className = 'result-subreddit';
                    subredditLink.href = `https://www.reddit.com/r/${post.subreddit}`;
                    subredditLink.target = '_blank';

                    subredditLink.addEventListener('click', (e) => {
                        e.preventDefault();
                        const subredditName = post.subreddit;

                        // Check banned subreddits list
                        if (bannedSubreddits.includes(subredditName.toLowerCase())) {
                            showError(`
                    <div style="text-align: center;">
                        <img src="https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExOWtmaXgzdmdxdzU0dHJ0dXB5MXV2bWdpb2FqYXZndWc1eGNuZTAwMSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/Vuw9m5wXviFIQ/giphy.gif"
                    alt="Rick Astley dancing"
                    style="width: 300px; border-radius: 8px;">
                    </div>
                `);
                            return;
                        }

                        // Clear any existing search term (for hot posts behavior)
                        searchInput.value = '';

                        // Set the subreddit in the input
                        subredditInput.value = subredditName;
                        // Set filter to hot
                        sortSelect.value = 'hot';
                        currentFilters.sort = 'hot';

                        // Update the chip to show this subreddit
                        if (subredditChipContainer) {
                            subredditChipContainer.querySelector('.chip-text').textContent = `r/${subredditName}`;
                            subredditChipContainer.style.display = 'flex';
                        }

                        // Reset page index and history for new search
                        currentPageIndex = 0;

                        // Perform the search
                        handleSearchRequest();
                    });

                    const bookmarkContainer = document.createElement('div');
                    bookmarkContainer.className = 'bookmark-container';

                    const bookmarkIcon = document.createElement('div');
                    bookmarkIcon.className = 'bookmark-icon';
                    bookmarkIcon.title = 'Save post';
                    bookmarkIcon.dataset.postId = bookmarkId;
                    bookmarkIcon.setAttribute('tabindex', '0');

                    // Handle tab + enter on bookmark icons
                    document.addEventListener('keydown', function (e) {
                        if ((e.key === 'Enter' || e.key === ' ') && e.target.classList.contains('bookmark-icon')) {
                            e.preventDefault();
                            e.target.click();
                        }
                    });

                    const savedBookmarks = JSON.parse(sessionStorage.getItem('bookmarks') || '{}');
                    if (savedBookmarks[bookmarkId]) {
                        bookmarkIcon.classList.add('saved');
                    }

                    bookmarkContainer.appendChild(bookmarkIcon);
                    resultCard.appendChild(bookmarkContainer);

                    // Subreddit icon
                    const subredditIcon = document.createElement('div');
                    subredditIcon.className = 'subreddit-icon';

                    // Always show fallback letter immediately
                    subredditIcon.textContent = post.subreddit.charAt(0).toUpperCase();

                    const storageKey = `subreddit_icon_${post.subreddit}`;
                    const cachedIcon = sessionStorage.getItem(storageKey);
                    const fallbackIcon = '/api/placeholder/20/20';

                    function tryLoadIcon(url) {
                        const img = document.createElement('img');
                        img.src = url;
                        img.alt = `Icon for r/${post.subreddit}`;
                        img.className = 'subreddit-icon-img';

                        img.onload = () => {
                            subredditIcon.textContent = '';
                            subredditIcon.appendChild(img);
                            setTimeout(() => img.classList.add('fade-in'), 10);
                            subredditIcon.classList.add('icon-loaded');
                            post.icon_url = url;
                            sessionStorage.setItem(storageKey, url);
                        };

                        img.onerror = () => {
                            console.warn(`⚠️ Icon failed to load for r/${post.subreddit}: ${url}`);
                        };
                    }

                    if (cachedIcon && cachedIcon !== 'null' && cachedIcon !== fallbackIcon) {
                        tryLoadIcon(cachedIcon);
                    } else if (post.icon_url && post.icon_url !== null && post.icon_url !== fallbackIcon) {
                        tryLoadIcon(post.icon_url);
                        sessionStorage.setItem(storageKey, post.icon_url);
                    } else {
                        getSubredditIcon(post.subreddit).then(iconUrl => {
                            if (iconUrl && iconUrl !== fallbackIcon) {
                                tryLoadIcon(iconUrl);
                            } else {
                                tryLoadIcon(fallbackIcon); 
                            }
                        }).catch(() => {
                            tryLoadIcon(fallbackIcon);
                        });
                    }

                    subredditLink.appendChild(subredditIcon);
                    subredditLink.appendChild(document.createTextNode('r/' + post.subreddit));

                    const authorSpan = document.createElement('span');
                    authorSpan.className = 'result-author';
                    authorSpan.textContent = 'Posted by u/' + post.author;

                    // Wrap the span in a link
                    const authorLink = document.createElement('a');
                    authorLink.className = 'result-author';
                    authorLink.href = `https://www.reddit.com/user/${post.author}`;
                    authorLink.target = '_blank';
                    authorLink.setAttribute('aria-label', `Posted by user ${post.author}`);
                    authorLink.appendChild(authorSpan);

                    const timeSpan = document.createElement('span');
                    timeSpan.className = 'result-time';
                    timeSpan.textContent = formatTimestamp(post.created_utc);
                    timeSpan.tabIndex = 0;
                    timeSpan.setAttribute('aria-label', `Posted ${formatTimestamp(post.created_utc)}`);

                    const metaRow = document.createElement('div');
                    metaRow.className = 'result-meta';

                    metaRow.appendChild(subredditLink);
                    metaRow.appendChild(authorLink);
                    metaRow.appendChild(timeSpan);

                    resultHeader.appendChild(metaRow);

                    // Result title
                    const resultTitle = document.createElement('div');
                    resultTitle.className = 'result-title';

                    const titleLink = document.createElement('a');
                    titleLink.href = `https://www.reddit.com${post.permalink}`;
                    titleLink.target = '_blank';
                    titleLink.textContent = decodeEntities(post.title || 'Comment in thread');

                    // Detect long title length for CSS
                    if (post.title.length > 100) {
                        resultTitle.classList.add('long-title');
                    }

                    resultTitle.appendChild(titleLink);

                    // Result content (text or snippet)
                    const resultContent = document.createElement('div');
                    resultContent.className = 'result-content';

                    let snippet = '';
                    let isFromCrosspost = false;

                    if (post.selftext && post.selftext.trim() !== '') {
                        const decodedText = decodeEntities(post.selftext);
                        snippet = decodedText.length > 300
                            ? decodedText.substring(0, 300) + '...'
                            : decodedText;
                    } else if (post.body && post.body.trim() !== '') {
                        const decodedBody = decodeEntities(post.body);
                        snippet = decodedBody.length > 300
                            ? decodedBody.substring(0, 300) + '...'
                            : decodedBody;
                    } else if (
                        post.crosspost_parent_list?.[0]?.selftext &&
                        post.crosspost_parent_list[0].selftext !== ''
                    ) {
                        // Set flag for crossposted content
                        isFromCrosspost = true;
                        const decodedCrosspostText = decodeEntities(post.crosspost_parent_list[0].selftext);
                        snippet = decodedCrosspostText.length > 300
                            ? decodedCrosspostText.substring(0, 300) + '...'
                            : decodedCrosspostText;
                    }

                    // Clear the content area
                    resultContent.innerHTML = '';

                    if (isFromCrosspost) {
                        const quoteEl = document.createElement('div');
                        quoteEl.className = 'el-quote';
                        quoteEl.innerHTML = parseMarkdown(snippet);
                        resultContent.appendChild(quoteEl);
                    } else {
                        resultContent.innerHTML = parseMarkdown(snippet);
                    }

                    // After creating your snippet, clean up incomplete links
                    if (snippet.match(/\[[^\]]+\]\([^)]*$/)) {
                        // Remove the incomplete link syntax at the end
                        snippet = snippet.replace(/\[[^\]]+\]\([^)]*$/, '...');
                    }

                    // Result actions (comments, save, share)
                    const resultActions = document.createElement('div');
                    resultActions.className = 'result-actions';

                    const commentsAction = document.createElement('div');
                    commentsAction.className = 'result-action';
                    commentsAction.tabIndex = 0;
                    commentsAction.setAttribute('aria-label', 'Comments');
                    commentsAction.innerHTML = `
        <svg class="action-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
        </svg>
        ${post.num_comments || 0} Comments`;

                    commentsAction.style.cursor = 'pointer';

                    commentsAction.addEventListener('click', () => {
                        const url = 'https://www.reddit.com' + post.permalink;
                        window.open(url, '_blank');
                    });
                    commentsAction.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            const url = 'https://www.reddit.com' + post.permalink;
                            window.open(url, '_blank');
                        }
                    });

                    const saveAction = document.createElement('div');
                    saveAction.className = 'result-action';
                    saveAction.tabIndex = 0;
                    saveAction.setAttribute('aria-label', 'Reddit Save');
                    saveAction.innerHTML = `
        <svg class="action-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>
        </svg>
        Save`;
                    saveAction.addEventListener('click', () => {
                        const url = 'https://www.reddit.com' + post.permalink;
                        window.open(url, '_blank');
                    });
                    saveAction.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            const url = 'https://www.reddit.com' + post.permalink;
                            window.open(url, '_blank');
                        }
                    });

                    const shareAction = document.createElement('div');
                    shareAction.className = 'result-action';
                    shareAction.tabIndex = 0;
                    shareAction.setAttribute('aria-label', 'Share');
                    shareAction.innerHTML = `
        <svg class="action-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="18" cy="5" r="3"></circle>
            <circle cx="6" cy="12" r="3"></circle>
            <circle cx="18" cy="19" r="3"></circle>
            <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
            <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
        </svg>
        Share`;
                    shareAction.addEventListener('click', () => {
                        const url = 'https://www.reddit.com' + post.permalink;
                        window.open(url, '_blank');
                    });
                    shareAction.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            const url = 'https://www.reddit.com' + post.permalink;
                            window.open(url, '_blank');
                        }
                    });

                    resultActions.appendChild(commentsAction);
                    resultActions.appendChild(saveAction);
                    resultActions.appendChild(shareAction);

                    // Add all sections to content area
                    contentSection.appendChild(resultHeader);
                    contentSection.appendChild(resultTitle);

                    if (snippet) {
                        contentSection.appendChild(resultContent);
                    }

                    contentSection.appendChild(resultActions);

                    // Domain and thumbnail checks
                    const knownNewsDomains = new Set([
                        "nytimes.com", "apnews.com", "reuters.com", "cnn.com", "bbc.com",
                        "cnbc.com", "abcnews.go.com", "aljazeera.com", "nbcnews.com", "independent.co.uk",
                        "kstp.com", "nbcnews.to", "nzherald.co.nz", "cnet.com", "latimes.com", "cbsnews.com",
                        "spin.com", "xxlmag.com", "newschannel9.com", "kutv.com", "deadline.com",
                        "wbez.org", "rawstory.com", "abc15.com", "npr.org", "foxnews.com",
                        "washingtonpost.com", "theguardian.com", "wired.com", "bloomberg.com", "politico.com"
                    ]);

                    const badThumbs = new Set(['self', 'default', 'nsfw', 'spoiler', 'image', '']);
                    const normalizedThumb = (post.thumbnail || '').toLowerCase();
                    const isGarbageThumb = badThumbs.has(normalizedThumb);

                    // Determine whether to analyze the media type for if it's moving
                    let mediaUrlForAnalysis = null;

                    const url = post.url?.toLowerCase() || '';
                    const allowedExts = ['.mp4', '.webm', '.mov', '.mkv', '.avi', '.flv', '.wmv', '.gif'];

                    const hasValidExtension = allowedExts.some(ext => url.endsWith(ext));

                    if (hasValidExtension) {
                        mediaUrlForAnalysis = post.url;
                    } else if (post.preview?.images?.[0]?.variants?.gif?.source?.url?.toLowerCase().endsWith('.gif')) {
                        mediaUrlForAnalysis = post.preview.images[0].variants.gif.source.url;
                    }

                    // End of analyzing media type

                    const knownMediaDomains = [
                        "i.redd.it", "v.redd.it", "streamable.com", "imgur.com", "preview.redd.it", "reddit.com", "wikipedia.com",
                        "gfycat.com", "redgifs.com", "tenor.com", "youtube.com", "youtu.be"
                    ];

                    const isKnownMediaDomain = knownMediaDomains.includes(domain);
                    const isSelfPost = post.is_self || (post.domain || '').startsWith('self.');
                    const isLinkPost = !isSelfPost;
                    const isBareLink = post.selftext === "";
                    const isRedditMedia =
                        post.url?.includes('v.redd.it') ||
                        post.url?.includes('i.redd.it') ||
                        post.url?.includes('gfycat.com') ||
                        post.url?.includes('imgur.com') ||
                        post.url?.includes('redgifs.com') ||
                        post.url?.endsWith('.gif') ||
                        post.url?.endsWith('.mp4') ||
                        post.url?.endsWith('.webm');

                    const shouldSaveToBackend = (
                        isLinkPost &&
                        isBareLink &&
                        isGarbageThumb &&
                        !isRedditMedia && // ✅ filters out gif/video stuff
                        (!isKnownMediaDomain || domain === 'youtube.com')
                    );

                    let thumbnailURL = getThumbnailUrl(post);

                    // YOUTUBE THUMBNAIL LOGIC 
                    if ((domain === 'youtube.com' || domain === 'youtu.be')) {
                        const youtubeThumb = getYouTubeThumbnail(post.url);
                        if (youtubeThumb) {
                            thumbnailURL = youtubeThumb;
                        }
                    }

                    // Special handling for Reddit videos without preview
                    if (!thumbnailURL && post.url && post.url.includes('v.redd.it')) {
                        const videoId = post.url.split('/').pop();
                        const dashUrl = `https://v.redd.it/${videoId}/DASH_480.mp4`;
                        thumbnailURL = dashUrl; // Set the variable instead of returning
                    }

                    const hasPreviewImage = post.preview?.images?.[0]?.source?.url;
                    const isVideo = post.is_video ||
                        (post.domain && post.domain.includes('youtu')) ||
                        (post.url && post.url.includes('v.redd.it')) ||
                        (post.domain && post.domain.includes('streamable')) ||
                        (post.url && post.url.endsWith('.gifv'));
                    const isGalleryWithData = post.is_gallery && post.gallery_data && post.media_metadata;

                    const isGarbage = !thumbnailURL || ['self', 'default', 'nsfw', 'spoiler', 'image'].includes(thumbnailURL.toLowerCase());
                    const hasVisualMedia = (!isGarbage || isGalleryWithData || isVideo || shouldSaveToBackend ||
                        hasPreviewImage || !post.is_self || !domain.startsWith('self.'));

                    const imgContainer = document.createElement('div');
                    imgContainer.className = 'img-container';

                    // Append sections
                    resultCard.appendChild(voteSection);
                    resultCard.appendChild(contentSection);
                    resultCard.appendChild(commentsSection);

                    // Check database cache before patches
                    if (!window.imageHandler) {
                        window.imageHandler = new ImageHandler();
                    }

                    // Only handle images if there's actually visual media
                    if (hasVisualMedia) {
                        window.imageHandler.handleImageLoad(post, resultCard);
                    }

                    const mediaContainer = createMediaElement(post, thumbnailURL, domain, resultCard);
                    resultCard.appendChild(mediaContainer);
                    addPlayIconIfNeeded(post, resultCard);

                    // Classify content
                    if (selectedFilter !== 'all') {
                        postContentType = classifyContentType(post);
                        if (postContentType !== selectedFilter) {
                            continue;
                        }
                    }

                    setTimeout(() => PATCHES(post, resultCard), 0);

                    // Add resultCard to the main results container
                    resultsContainer.appendChild(resultCard);

                    // Bookmark click handler
                    bookmarkIcon.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const bookmarkId = bookmarkIcon.dataset.postId;
                        const isSaved = bookmarkIcon.classList.contains('saved');
                        const authToken = getAuthToken();

                        try {
                            // Get current bookmarks from sessionStorage
                            const savedBookmarks = JSON.parse(sessionStorage.getItem('bookmarks') || '{}');

                            if (isSaved) {
                                // Remove from database
                                await fetch(`${API_BASE}/api/bookmarks/${bookmarkId}`, {
                                    method: 'DELETE',
                                    headers: {
                                        'Authorization': authToken
                                    }
                                });

                                // Update UI
                                bookmarkIcon.classList.remove('saved');

                                // Update sessionStorage
                                delete savedBookmarks[bookmarkId];
                                sessionStorage.setItem('bookmarks', JSON.stringify(savedBookmarks));
                            } else {
                                // Add to database
                                await fetch(`${API_BASE}/api/bookmarks`, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'Authorization': authToken
                                    },
                                    body: JSON.stringify({
                                        postId: bookmarkId,
                                        title: post.title || '',
                                        url: post.url || '',
                                        permalink: post.permalink || '',
                                        subreddit: post.subreddit || '',
                                        score: post.score || 0,
                                        is_video: Boolean(post.is_video),
                                        domain: post.domain || '',
                                        author: post.author || '',
                                        created_utc: post.created_utc || 0,
                                        num_comments: post.num_comments || 0,
                                        over_18: Boolean(post.over_18),
                                        selftext: post.selftext || '',
                                        body: post.body || '',
                                        is_gallery: Boolean(post.is_gallery),
                                        gallery_data: post.gallery_data || null,
                                        media_metadata: post.media_metadata || null,
                                        crosspost_parent_list: post.crosspost_parent_list || [],
                                        content_type: post.content_type || '',
                                        icon_url: post.icon_url || null,
                                        locked: Boolean(post.locked),
                                        stickied: Boolean(post.stickied),
                                        preview: post.preview || null
                                    }),
                                });

                                // Update UI
                                bookmarkIcon.classList.add('saved');

                                // Update sessionStorage
                                savedBookmarks[bookmarkId] = true;
                                sessionStorage.setItem('bookmarks', JSON.stringify(savedBookmarks));

                                // Reorder to put new bookmark at top of user's section ID 
                                const sectionsResponse = await fetch(`${API_BASE}/api/sections`, {
                                    headers: {
                                        'Authorization': authToken
                                    }
                                });
                                const sectionsData = await sectionsResponse.json();
                                const firstSectionId = sectionsData.sections[0]?.id;

                                if (firstSectionId) {
                                    const sectionResponse = await fetch(`${API_BASE}/api/bookmarks/section/${firstSectionId}?offset=0&limit=100`, {
                                        headers: {
                                            'Authorization': authToken
                                        }
                                    });
                                    const sectionData = await sectionResponse.json();
                                    const existingIds = sectionData.bookmarks.map(b => b.reddit_post_id).filter(id => id !== bookmarkId);
                                    const orderedIds = [bookmarkId, ...existingIds];

                                    await fetch(`${API_BASE}/api/bookmarks/reorder`, {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json',
                                            'Authorization': authToken
                                        },
                                        body: JSON.stringify({
                                            orderedIds,
                                            sectionId: firstSectionId
                                        })
                                    });
                                }
                            }
                        } catch (err) {
                            console.error('Failed to toggle bookmark:', err);
                        }
                    });

                    // Filter NSFW
                    const safeSearchSelect = document.getElementById('safesearch-select');
                    if (safeSearchSelect?.value === 'on') {
                        document.body.classList.add('safe-search-enabled');
                    } else {
                        document.body.classList.remove('safe-search-enabled');
                    }
                }

                // Yield to event loop between batches
                await new Promise(resolve => setTimeout(resolve, 0));
            }
            // Initialize Plyr for all video players
            const players = document.querySelectorAll('.js-player');
            players.forEach(player => {
                if (!player.plyr) {
                    const plyrInstance = new Plyr(player, {
                        controls: ['play-large', 'play', 'progress', 'current-time', 'mute', 'volume', 'captions', 'settings', 'pip', 'airplay', 'fullscreen'],
                        volume: 1, // Full volume
                        muted: false, // Not muted
                        clickToPlay: true,
                        hideControls: false,
                        seekTime: 10,
                        displayDuration: true,
                        invertTime: false,
                        toggleInvert: true
                    });

                    // Force unmute after initialization
                    plyrInstance.muted = false;
                    plyrInstance.volume = 1;
                }
            });

            // Visibility code 
            applyStaggeredAnimation('.result-card', 'visible', 40);
            resultsContainer.style.opacity = 1;
            updatePagination();

            // After the loop, add these logs:
            const allCards = document.querySelectorAll('.result-card');
            const visibleCards = Array.from(allCards).filter(card =>
                window.getComputedStyle(card).display !== 'none'
            );

            if (visibleCards.length === 0) {
                showError("No results found. Try different search terms or filters.");
                noResultsMessage();
                paginationContainer.innerHTML = '';
                return;
            }

        }













        function PATCHES(post, resultCard) {
            // Patch media on timeout
            tryMediaPatch(post, resultCard);
            setTimeout(() => {
                addPlayIconIfNeeded(post, resultCard);
            }, 100);

            // Gallery post check, trigger gallery patch if needed
            if (post.is_gallery && post.gallery_data && post.media_metadata) {
                setTimeout(() => {
                    tryGalleryPatch(post, post.permalink, resultCard);
                }, 0);
            }
        }

        // Media handling
        function createMediaElement(post, thumbnailURL, domain, resultCard) {
            const imgContainer = document.createElement('div');
            const imageWrapper = document.createElement('div');

            imgContainer.className = 'img-container';
            imageWrapper.className = 'image-wrapper';
            imageWrapper.tabIndex = 0;

            imageWrapper.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    const existingModal = document.querySelector('.modal-overlay');
                    if (existingModal) {
                        existingModal.remove();
                    } else {
                        imageWrapper.click();
                    }
                }
            });

            imageWrapper.setAttribute('aria-label', `Image for post: ${post.title}`);

            // Determine media type and sources
            const mediaInfo = analyzeMediaType(post, thumbnailURL, domain);

            if (!mediaInfo.hasVisualMedia && domain && domain !== 'reddit.com' && domain.includes('.')) {
                const imagePlaceholder = document.createElement('div');
                const img = document.createElement('img');
                img.className = 'result-image';
                imagePlaceholder.className = 'image-placeholder shimmer';

                imageWrapper.appendChild(imagePlaceholder);
                imageWrapper.appendChild(img);
                imgContainer.appendChild(imageWrapper);
                window.imageHandler.handleBackendScrapedImage(post, resultCard);
                return imgContainer;
            }

            // Check if we have sources, if not return empty container
            if (!mediaInfo.sources || mediaInfo.sources.length === 0) {
                imgContainer.appendChild(imageWrapper);
                return imgContainer;
            }

            // Only create shimmer if we have sources
            const imagePlaceholder = document.createElement('div');
            imagePlaceholder.className = 'image-placeholder shimmer';

            const videoInfo = identifyVideoTypes(post);
            mediaInfo.videoInfo = videoInfo;
            mediaInfo.post = post;
            const mediaElement = createMediaElementByType(mediaInfo);
            mediaElement.style.opacity = '0';
            mediaElement.style.transition = 'opacity 0.3s ease-in-out';

            setupMediaErrorHandling(mediaElement, mediaInfo);
            setupMediaLoadHandling(mediaElement, imagePlaceholder);
            setupImageModal(imageWrapper);

            imageWrapper.appendChild(imagePlaceholder);
            imageWrapper.appendChild(mediaElement);
            imageWrapper.style.cursor = 'pointer';
            imgContainer.appendChild(imageWrapper);
            return imgContainer;
        }
        function analyzeMediaType(post, thumbnailURL, domain) {
            const originalPost = (post.crosspost_parent_list && post.crosspost_parent_list.length > 0)
                ? post.crosspost_parent_list[0]
                : post;

            // Get all possible image sources in priority order
            const previewImage = originalPost.preview?.images?.[0]?.source?.url?.replace(/&amp;/g, '&');
            const gifVariant = originalPost.preview?.images?.[0]?.variants?.gif?.source?.url;
            const cleanThumbnail = thumbnailURL?.replace(/&amp;/g, '&');

            // Media type detection
            const isVideo = originalPost.is_video || originalPost.url?.includes('v.redd.it');
            const isGif = originalPost.url?.endsWith('.gif') || gifVariant;
            const isMp4 = originalPost.url?.endsWith('.mp4');
            const isYouTube = domain === 'youtube.com' || domain === 'youtu.be';

            const isGallery = originalPost.is_gallery && originalPost.gallery_data && originalPost.media_metadata;

            // Determine if we should show visual media
            const isGarbageThumbnail = !thumbnailURL ||
                ['self', 'default', 'nsfw', 'spoiler', 'image'].includes(thumbnailURL.toLowerCase());

            const hasVisualMedia = (!isGarbageThumbnail ||
                isGallery ||
                isVideo ||
                previewImage) &&
                !(originalPost.domain || '').startsWith('self.');

            // Build source priority list
            const sources = [];

            // For Reddit videos, use the fallback URL as thumbnail
            if (originalPost.media?.reddit_video?.fallback_url) {
                const fallbackUrl = originalPost.media.reddit_video.fallback_url;
                sources.push({
                    url: fallbackUrl,
                    type: 'video',
                    priority: 1
                });
            }

            if (gifVariant) {
                sources.push({ url: gifVariant, type: 'gif', priority: 1 });
            }
            if (originalPost.url?.endsWith('.gif')) {
                sources.push({ url: originalPost.url, type: 'gif', priority: 2 });
            }
            if (isMp4) {
                sources.push({ url: originalPost.url, type: 'video', priority: 3 });
            }
            if (isVideo && cleanThumbnail?.includes('DASH_')) {
                sources.push({ url: cleanThumbnail, type: 'video', priority: 4 });
            }
            if (previewImage) {
                sources.push({
                    url: `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(previewImage)}`,
                    type: 'image',
                    priority: 3
                });
            }
            if (cleanThumbnail && !cleanThumbnail.includes('DASH_')) {
                sources.push({
                    url: `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(cleanThumbnail)}`,
                    type: 'image',
                    priority: 2
                });
            }
            // Add fallback for non-self posts (galleries need this)
            if (originalPost.url && !originalPost.is_self && !(originalPost.domain || '').startsWith('self.')) {
                sources.push({ url: originalPost.url, type: 'fallback', priority: 7 });
            }

            // Sort by priority
            sources.sort((a, b) => a.priority - b.priority);

            return {
                hasVisualMedia,
                sources,
                isVideo,
                isGif,
                isMp4,
                isYouTube,
                primarySource: sources[0] || null
            };
        }

        function identifyVideoTypes(post) {
            const originalPost = (post.crosspost_parent_list && post.crosspost_parent_list.length > 0)
                ? post.crosspost_parent_list[0]
                : post;

            const videoInfo = {
                hasVideo: false,
                videoType: null,
                videoSource: null
            };

            // Check media first (most common for cross-posts)
            if (originalPost.media?.reddit_video?.fallback_url) {
                videoInfo.hasVideo = true;
                videoInfo.videoType = 'reddit_native';
                videoInfo.videoSource = originalPost.media.reddit_video.fallback_url;

                const videoUrl = originalPost.media.reddit_video.fallback_url.split("?")[0];
                const videoId = videoUrl.split('/')[3];
                videoInfo.videoId = videoId;
                videoInfo.audioSource = `https://v.redd.it/${videoId}/DASH_AUDIO_128.mp4`;
            }
            // Check secure_media
            else if (originalPost.secure_media?.reddit_video?.fallback_url) {
                videoInfo.hasVideo = true;
                videoInfo.videoType = 'reddit_native';
                videoInfo.videoSource = originalPost.secure_media.reddit_video.fallback_url;

                const videoUrl = originalPost.secure_media.reddit_video.fallback_url.split("?")[0];
                const videoId = videoUrl.split('/')[3];
                videoInfo.videoId = videoId;
                videoInfo.audioSource = `https://v.redd.it/${videoId}/DASH_AUDIO_128.mp4`;
            }
            // Check preview for RedGifs
            else if (originalPost.preview?.reddit_video_preview?.fallback_url) {
                videoInfo.hasVideo = true;
                videoInfo.videoType = 'reddit_native';
                videoInfo.videoSource = originalPost.preview.reddit_video_preview.fallback_url;

                const videoUrl = originalPost.preview.reddit_video_preview.fallback_url.split("?")[0];
                const videoId = videoUrl.split('/')[3];
                videoInfo.videoId = videoId;
                videoInfo.audioSource = `https://v.redd.it/${videoId}/DASH_AUDIO_128.mp4`;
            }
            // Check v.redd.it URL
            else if (originalPost.url?.includes('v.redd.it')) {
                videoInfo.hasVideo = true;
                videoInfo.videoType = 'reddit_native';
                const videoId = originalPost.url.split('/').pop();
                videoInfo.videoId = videoId;
                videoInfo.videoSource = null;
            }

            // Streamable detection
            if (!videoInfo.hasVideo && originalPost.url?.includes('streamable.com')) {
                const match = originalPost.url.match(/streamable\.com\/([a-zA-Z0-9]+)/);
                if (match) {
                    videoInfo.hasVideo = true;
                    videoInfo.videoType = 'streamable';
                    videoInfo.embedId = match[1];
                    videoInfo.videoSource = `https://streamable.com/e/${match[1]}`;
                }
            }

            // YouTube detection
            if (!videoInfo.hasVideo && (originalPost.url?.includes('youtube.com') || originalPost.url?.includes('youtu.be'))) {
                videoInfo.hasVideo = true;
                videoInfo.videoType = 'youtube';
                videoInfo.videoSource = originalPost.url;

                let videoId = null;
                if (originalPost.url.includes('youtube.com/watch')) {
                    const urlParams = new URLSearchParams(originalPost.url.split('?')[1]);
                    videoId = urlParams.get('v');
                } else if (originalPost.url.includes('youtu.be/')) {
                    videoId = originalPost.url.split('youtu.be/')[1].split('?')[0];
                }

                videoInfo.embedId = videoId;
            }

            return videoInfo;
        }

        function createMediaElementByType(mediaInfo) {
            if (!mediaInfo.primarySource) {
                return document.createElement('img');
            }

            const source = mediaInfo.primarySource;
            let mediaElement;

            if (source.type === 'video' || mediaInfo.isMp4) {
                mediaElement = document.createElement('video');
                mediaElement.muted = true;
                mediaElement.playsInline = true;
                mediaElement.preload = 'metadata';

                if (mediaInfo.isMp4) {
                    mediaElement.autoplay = true;
                    mediaElement.loop = true;
                } else {
                    mediaElement.currentTime = 0.1; // For preview frame
                }
            } else {
                mediaElement = document.createElement('img');
            }

            // Set standard attributes
            mediaElement.className = 'result-image';
            mediaElement.alt = 'Post thumbnail';
            mediaElement.setAttribute('loading', 'eager');
            mediaElement.setAttribute('decoding', 'async');
            mediaElement.setAttribute('fetchpriority', 'low');
            mediaElement.setAttribute('crossorigin', 'anonymous');

            // Store video info for modal detection
            if (mediaInfo.videoInfo && mediaInfo.videoInfo.videoType === 'reddit_native') {
                mediaElement.dataset.isRedditVideo = 'true';
                mediaElement.dataset.videoType = 'reddit_native';
                mediaElement.classList.add('reddit-video-thumbnail');

                // Extract and store video ID
                const post = mediaInfo.post;
                let videoId = null;
                if (post?.url?.includes('v.redd.it')) {
                    videoId = post.url.split('/').pop();
                } else if (mediaInfo.videoInfo.videoSource) {
                    const match = mediaInfo.videoInfo.videoSource.match(/v\.redd\.it\/([^\/]+)/);
                    if (match) videoId = match[1];
                }

                if (videoId) {
                    mediaElement.dataset.videoId = videoId;
                }
            }

            // Set initial source
            mediaElement.src = source.url;

            return mediaElement;
        }

        async function getCombinedRedditVideo(videoId) {
            try {

                // Call the backend API
                const response = await fetch(`${API_BASE}/api/reddit-video/${videoId}`);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();

                if (data.success && data.videoUrl) {
                    // Backend has the video ready
                    return `${API_BASE}${data.videoUrl}`;
                } else {
                    console.error('❌ Backend error:', data.error);
                    return null;
                }

            } catch (error) {
                console.error('❌ Error getting combined video:', error);
                return null;
            }
        }

        function setupMediaErrorHandling(mediaElement, mediaInfo) {
            let currentSourceIndex = 0;
            let hasTriedRetry = false;

            function tryNextSource() {
                currentSourceIndex++;

                if (currentSourceIndex >= mediaInfo.sources.length) {
                    // All sources failed - try once more if we haven't already
                    if (!hasTriedRetry) {
                        hasTriedRetry = true;
                        setTimeout(() => {
                            currentSourceIndex = 0;
                            mediaElement.src = mediaInfo.sources[0].url;
                        }, 1000);
                        return;
                    }

                    // All sources failed including retry
                    // console.error('🚫 All media sources failed for:', mediaInfo.sources);
                    setTimeout(() => {
                        const resultCard = mediaElement.closest('.result-card');
                        const shimmer = resultCard?.querySelector('.image-placeholder');
                        if (shimmer) shimmer.style.display = 'none';

                        const imageWrapper = mediaElement.closest('.image-wrapper');
                        if (imageWrapper) {
                            showNewsIcon(imageWrapper, shimmer);
                        }
                    }, 1000);
                    return;
                }

                const nextSource = mediaInfo.sources[currentSourceIndex];

                // Update element type if needed
                if (nextSource.type === 'video' && mediaElement.tagName !== 'VIDEO') {
                    // Need to replace with video element
                    const newElement = document.createElement('video');
                    newElement.className = mediaElement.className;
                    newElement.alt = mediaElement.alt;

                    // Copy attributes
                    ['loading', 'decoding', 'fetchpriority', 'crossorigin'].forEach(attr => {
                        newElement.setAttribute(attr, mediaElement.getAttribute(attr));
                    });

                    newElement.muted = true;
                    newElement.playsInline = true;
                    newElement.preload = 'metadata';

                    mediaElement.parentNode.replaceChild(newElement, mediaElement);
                    mediaElement = newElement;

                }

                mediaElement.src = nextSource.url;
            }

            mediaElement.addEventListener('error', (e) => {
                // Skip retry for DASH URLs that should work as videos
                if (mediaElement.src.includes('DASH_') && mediaElement.tagName === 'VIDEO') {
                    return;
                }
                tryNextSource();
            });
        }

        function setupMediaLoadHandling(mediaElement, imagePlaceholder) {
            const handleSuccess = () => {

                imagePlaceholder.style.opacity = '0';
                imagePlaceholder.style.transition = 'opacity 0.3s ease-in-out';

                // Fade in media
                mediaElement.style.opacity = '1';

                // Remove shimmer after fade completes
                setTimeout(() => {
                    imagePlaceholder.style.display = 'none';
                    // or imagePlaceholder.remove(); if you want to completely remove it
                }, 300);
            };

            if (mediaElement.tagName === 'VIDEO') {
                mediaElement.addEventListener('loadeddata', handleSuccess);
                mediaElement.addEventListener('canplay', handleSuccess);
            } else {
                mediaElement.addEventListener('load', () => {
                    if (mediaElement.naturalWidth > 0 && mediaElement.naturalHeight > 0) {
                        handleSuccess();
                    }
                });
            }
        }

        function setupImageModal(imageWrapper, galleryData = null, mediaMetadata = null, currentIndex = 0) {
            imageWrapper.addEventListener('click', async function (event) {
                // Prevent any default behaviors that might cause navigation
                event.preventDefault();
                event.stopPropagation();

                // Remove any existing modals first
                const existingModal = document.querySelector('.modal-overlay');
                if (existingModal) {
                    existingModal.remove();
                }

                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'modal-overlay';
                modalOverlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s ease;
        `;

                // Create modal container that will hold both content and arrows
                const modalContainer = document.createElement('div');
                modalContainer.style.cssText = `
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            max-width: 90vw;
            max-height: 90vh;
        `;

                // Check if this is a Reddit video thumbnail
                const imageElement = imageWrapper.querySelector('img') || imageWrapper.querySelector('video');
                const videoElement = imageWrapper.querySelector('video');

                // Check for cross-posted videos specifically
                const isCrosspostVideo = videoElement && videoElement.dataset.isRedditVideo === 'true' && videoElement.dataset.videoId;

                const isRedditVideo = (imageElement && (imageElement.dataset.isRedditVideo === 'true' || imageElement.dataset.videoType === 'redgifs')) || isCrosspostVideo;
                const originalVideo = imageWrapper.querySelector('.js-player');
                let modalContent;
                let videoProcessingAborted = false;

                if (isRedditVideo) {
                    // Create video with poster immediately - NO BLACK SCREEN
                    modalContent = document.createElement('div');
                    modalContent.style.cssText = `
                width: auto !important;
                height: auto !important;
                max-width: 90vw;
                max-height: 90vh;
                opacity: 0;
                transform: scale(0.8);
                transition: all 0.1s ease;
                border-radius: 25px;
                padding: 0;
                background: transparent;
                overflow: hidden;
                position: relative;
            `;

                    // Create video element with poster IMMEDIATELY
                    const newVideo = document.createElement('video');
                    newVideo.className = 'js-player';
                    newVideo.setAttribute('controls', '');
                    newVideo.setAttribute('playsinline', '');
                    newVideo.setAttribute('poster', imageElement.src);
                    newVideo.muted = false;
                    newVideo.style.cssText = `
                width: 100% !important;
                height: auto !important;
                max-width: 90vw;
                max-height: 90vh;
                border-radius: 25px;
            `;

                    modalContent.appendChild(newVideo);

                    // Initialize Plyr immediately
                    try {
                        const modalPlyrInstance = new Plyr(newVideo, {
                            controls: ['play-large', 'play', 'progress', 'current-time', 'mute', 'volume', 'captions', 'settings', 'pip', 'airplay', 'fullscreen'],
                            volume: 1,
                            muted: false,
                            clickToPlay: true,
                            autoplay: true,
                            disableContextMenu: false,
                            fullscreen: {
                                enabled: true,
                                fallback: true,
                                iosNative: false
                            }
                        });

                        modalPlyrInstance.on('enterfullscreen', () => {
                            const video = newVideo;
                            video.style.marginLeft = 'auto';
                            video.style.marginRight = '0';
                            video.style.transform = 'translateX(-5vw) translateY(5vh) scale(1.2)';
                        });

                        modalPlyrInstance.on('exitfullscreen', () => {
                            const video = newVideo;
                            video.style.marginLeft = '';
                            video.style.marginRight = '';
                            video.style.transform = '';
                            video.style.width = '';
                        });

                        modalPlyrInstance.muted = false;
                        modalPlyrInstance.volume = 1;

                    } catch (error) {
                        console.log('❌ Error initializing Plyr:', error);
                    }

                    // Hide the Plyr play button during loading
                    const plyrPlayButton = modalContent.querySelector('.plyr__control--overlaid');
                    if (plyrPlayButton) {
                        plyrPlayButton.style.display = 'none';
                    }

                    // Add spinner overlay (positioned to not block close button)
                    const loadingOverlay = document.createElement('div');
                    loadingOverlay.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10;
                pointer-events: none;
            `;

                    const spinnerWrapper = createCanvasSpinner('#ffffff')
                    spinnerWrapper.style.cssText = `
                display: flex;
                align-items: center;
                justify-content: center;
                transform: scale(1.5);
            `;

                    loadingOverlay.appendChild(spinnerWrapper);
                    modalContent.appendChild(loadingOverlay);

                    // Get the stored video ID and process in background
                    const videoId = videoElement?.dataset?.videoId || imageElement?.dataset?.videoId;
                    if (videoId) {
                        // Start video processing in background
                        (async () => {
                            try {
                                const combinedVideoUrl = await getCombinedRedditVideo(videoId);

                                // Check if modal was closed during processing
                                if (videoProcessingAborted || !document.body.contains(modalOverlay)) {
                                    return;
                                }

                                if (combinedVideoUrl) {
                                    newVideo.src = combinedVideoUrl;
                                    loadingOverlay.remove();
                                    // Show the play button again
                                    if (plyrPlayButton) {
                                        plyrPlayButton.style.display = '';
                                    }
                                } else {
                                    // Keep spinner, retry after delay
                                    setTimeout(async () => {
                                        // Check again if modal still exists
                                        if (videoProcessingAborted || !document.body.contains(modalOverlay)) {
                                            return;
                                        }

                                        const retryUrl = await getCombinedRedditVideo(videoId);
                                        if (retryUrl && !videoProcessingAborted && document.body.contains(modalOverlay)) {
                                            newVideo.src = retryUrl;
                                            loadingOverlay.remove();
                                            if (plyrPlayButton) {
                                                plyrPlayButton.style.display = '';
                                            }
                                        }
                                    }, 2000);
                                }
                            } catch (error) {
                                console.error('❌ Error in video processing:', error);
                                if (document.body.contains(modalOverlay)) {
                                    loadingOverlay.remove();
                                }
                            }
                        })();
                    }

                } else if (originalVideo) {
                    // Handle non-Reddit videos (existing logic)
                    modalContent = document.createElement('div');
                    modalContent.style.cssText = `
                width: auto !important;
                height: auto !important;
                max-width: 90vw;
                max-height: 90vh;
                opacity: 0;
                transform: scale(0.8);
                transition: all 0.1s ease;
                border-radius: 25px;
                overflow: hidden;
            `;

                    const newVideo = document.createElement('video');
                    newVideo.className = 'js-player';
                    newVideo.setAttribute('controls', '');
                    newVideo.setAttribute('playsinline', '');
                    newVideo.src = originalVideo.src || originalVideo.querySelector('source')?.src;
                    newVideo.style.cssText = `
                width: 100% !important;
                height: auto !important;
                max-width: 90vw;
                max-height: 90vh;
                border-radius: 25px;
                object-fit: cover;
            `;

                    modalContent.appendChild(newVideo);

                } else {
                    // Handle regular images (existing logic)
                    modalContent = imageWrapper.cloneNode(true);
                    // Remove the small thumbnail arrows from modal 
                    const thumbnailArrows = modalContent.querySelectorAll('.gallery-arrow');
                    thumbnailArrows.forEach(arrow => arrow.remove());

                    // Make the counter bigger for modal view
                    const galleryCounter = modalContent.querySelector('.gallery-counter');
                    if (galleryCounter) {
                        galleryCounter.style.cssText = `
                        position: absolute;
                        top: 10px;
                        right: 10px;
                        background: rgba(0, 0, 0, 0.7);
                        color: white;
                        padding: 7px 12px;
                        border-radius: 15px;
                        font-size: 15px;
                        font-weight: bold;
                        z-index: 10;
                    `;
                    }

                    modalContent.style.cssText = `
                width: auto !important;
                height: auto !important;
                cursor: pointer;
                max-width: 90vw;
                max-height: 90vh;
                display: block !important;
                opacity: 0;
                transform: scale(0.8);
                transition: all 0.1s ease;
                border-radius: 25px;
            `;

                    const imageInside = modalContent.querySelector('img');
                    const shimmerPlaceholder = modalContent.querySelector('.image-placeholder');

                    if (imageInside) {
                        imageInside.style.cssText = `
                    width: 100% !important;
                    height: auto !important;
                    max-width: 90vw;
                    max-height: 90vh;
                    opacity: 1 !important;
                `;
                    }

                    if (shimmerPlaceholder) {
                        shimmerPlaceholder.remove();
                    }
                }

                // Add modal content to container
                modalContainer.appendChild(modalContent);

                // Enter on focused image closes modal view
                modalContent.tabIndex = 0;
                modalContent.setAttribute('role', 'button');
                modalContent.setAttribute('aria-label', 'Press Enter to close modal');

                modalContent.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        e.stopPropagation();
                        closeModal();
                    }
                });

                // Create left navigation arrow (positioned outside the content)
                const leftArrow = document.createElement('div');
                leftArrow.className = 'modal-nav-arrow modal-nav-left';
                leftArrow.tabIndex = 0;
                leftArrow.setAttribute('role', 'button');
                leftArrow.setAttribute('aria-label', 'Previous image');
                leftArrow.innerHTML = `
    <svg xmlns="http://www.w3.org/2000/svg" width="29" height="29" viewBox="0 0 24 24" fill="none" style="transform: translateX(-1px);" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-left-icon lucide-chevron-left"><path d="m15 18-6-6 6-6"/></svg>
`;

                leftArrow.style.cssText = `
            position: absolute;
            left: 320px;
            top: 50%;
            transform: translateY(-50%);
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10001;
            user-select: none;
        `;

                // Create right navigation arrow (positioned outside the content)
                const rightArrow = document.createElement('div');
                rightArrow.className = 'modal-nav-arrow modal-nav-right';
                rightArrow.tabIndex = 0;
                rightArrow.setAttribute('role', 'button');
                rightArrow.setAttribute('aria-label', 'Next image');
                rightArrow.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="29" height="29" viewBox="0 0 24 24" fill="none" style="transform: translateX(1px);" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-right-icon lucide-chevron-right"><path d="m9 18 6-6-6-6"/></svg>
                `;
                rightArrow.style.cssText = `
                    position: absolute;
                    right: 320px;
                    top: 50%;
                    transform: translateY(-50%);
                    width: 60px;
                    height: 60px;
                    background: rgba(0, 0, 0, 0.5);
                    color: white;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    cursor: pointer;
                    z-index: 10001;
                    user-select: none;
                `;

                // Get gallery data from the original image wrapper
                const galleryData = imageWrapper.galleryData;
                const mediaMetadata = imageWrapper.mediaMetadata;
                // Get current index - fallback chain
                let currentIndex = 0;
                const galleryCounter = imageWrapper.querySelector('.gallery-counter');

                if (galleryCounter) {
                    const counterText = galleryCounter.textContent;
                    currentIndex = parseInt(counterText.split('/')[0]) - 1;
                } else if (imageWrapper.currentIndex !== undefined) {
                    currentIndex = imageWrapper.currentIndex;
                } else {
                }

                const useSameSize = imageWrapper.useSameSize;

                // Add preloaded images storage for modal, share preloaded images from main gallery if available
                const modalPreloadedImages = imageWrapper.preloadedImages || {};

                let lastModalNavigationTime = 0;
                const MODAL_THROTTLE_DELAY = 70;

                const navigateModalGallery = (direction) => {
                    // Throttle rapid clicks
                    const now = Date.now();
                    if (now - lastModalNavigationTime < MODAL_THROTTLE_DELAY) {
                        return;
                    }
                    lastModalNavigationTime = now;

                    if (!galleryData || !mediaMetadata) return;

                    const totalImages = galleryData.length;
                    let currentImgElement = modalContent.querySelector('img');

                    // Calculate target index
                    const targetIndex = direction === 'prev'
                        ? (currentIndex > 0 ? currentIndex - 1 : totalImages - 1)
                        : (currentIndex < totalImages - 1 ? currentIndex + 1 : 0);

                    // Get new image URL using targetIndex
                    const mediaId = galleryData[targetIndex].media_id;
                    const media = mediaMetadata[mediaId];
                    const original = media?.s?.u?.replace(/&amp;/g, '&');
                    const resolutionFallback = media?.p?.[media.p.length - 1]?.u?.replace(/&amp;/g, '&');
                    const imageUrl = original || resolutionFallback;

                    if (!imageUrl) return;

                    // Create new image element for the incoming image
                    const newImg = document.createElement('img');
                    newImg.style.borderRadius = '25px';

                    // Apply sizing styles and initial off-screen position for slide-in
                    if (useSameSize && imageWrapper.modalFirstImageWidth && imageWrapper.modalFirstImageHeight) {
                        newImg.style.cssText = `
                            width: ${imageWrapper.modalFirstImageWidth}px !important;
                            height: ${imageWrapper.modalFirstImageHeight}px !important;
                            object-fit: cover;
                            opacity: 1; 
                            transform: ${direction === 'prev' ? 'translateX(-100%)' : 'translateX(100%)'}; /* Off-screen */
                            transition: transform 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.2s ease-in; /* Slide and fade */
                        `;
                    } else {
                        newImg.style.cssText = `
                            width: 100% !important;
                            height: auto !important;
                            max-width: 90vw;
                            max-height: 90vh;
                            opacity: 1; 
                            transform: ${direction === 'prev' ? 'translateX(-100%)' : 'translateX(100%)'}; /* Off-screen */
                            transition: transform 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.2s ease-in; /* Slide and fade */
                        `;
                    }

                    // This function finalizes the image swap and starts the slide-in animation
                    const performImageSwapAndAnimate = () => {
                        // Update currentIndex and gallery counter NOW that we're about to show the new image
                        currentIndex = targetIndex;
                        const galleryCounter = modalContent.querySelector('.gallery-counter');
                        if (galleryCounter) {
                            galleryCounter.textContent = `${currentIndex + 1}/${totalImages}`;
                        }

                        // Cleanly replace the old image with the new one
                        if (currentImgElement && currentImgElement.parentNode) {
                            currentImgElement.parentNode.replaceChild(newImg, currentImgElement);
                        } else {
                            // If there's no current image (e.g., first load), just append
                            modalContent.appendChild(newImg);
                        }
                        setTimeout(() => {
                            newImg.style.transform = 'translateX(0)';
                        }, 10);

                        // Sync back to main gallery wrapper
                        imageWrapper.currentIndex = currentIndex;
                    };

                    // Check if we have a preloaded image
                    if (modalPreloadedImages[targetIndex] && modalPreloadedImages[targetIndex].complete) {
                        // Force decode the preloaded image before using it
                        modalPreloadedImages[targetIndex].decode().then(() => {
                            newImg.src = modalPreloadedImages[targetIndex].src;
                            performImageSwapAndAnimate();
                        }).catch(() => {
                            // Fallback if decode fails
                            const proxyUrl = `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(imageUrl)}&t=${Date.now()}`;
                            newImg.onload = () => performImageSwapAndAnimate();
                            newImg.src = proxyUrl;
                        });
                    } else {
                        const proxyUrl = `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(imageUrl)}&t=${Date.now()}`;
                        newImg.onload = () => performImageSwapAndAnimate();
                        newImg.onerror = () => {
                            console.error(`❌ Failed to load modal image ${targetIndex + 1}`);
                            performImageSwapAndAnimate();
                        };
                        newImg.src = proxyUrl;
                    }

                    // Let tryGalleryPatch handle preloading by updating its current index
                    imageWrapper.currentIndex = targetIndex;
                };

                // Click handlers for navigation arrows
                leftArrow.addEventListener('click', (e) => {
                    e.stopPropagation();
                    navigateModalGallery('prev');
                });

                leftArrow.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        e.stopPropagation();
                        navigateModalGallery('prev');
                    }
                });

                rightArrow.addEventListener('click', (e) => {
                    e.stopPropagation();
                    navigateModalGallery('next');
                });

                rightArrow.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        e.stopPropagation();
                        navigateModalGallery('next');
                    }
                });

                const hasGallery = galleryData && galleryData.length > 1;

                if (hasGallery) {
                    // Add arrows to container
                    modalContainer.appendChild(leftArrow);
                    modalContainer.appendChild(rightArrow);

                    // Animate in arrows
                    leftArrow.style.opacity = '0';
                    rightArrow.style.opacity = '0';
                    leftArrow.style.transition = 'opacity 0.1s ease';
                    rightArrow.style.transition = 'opacity 0.1s ease';
                }

                // Add container to overlay
                modalOverlay.appendChild(modalContainer);

                document.body.appendChild(modalOverlay);

                trapFocus(modalOverlay);

                // Save global ref
                window.currentModalOverlay = modalOverlay;

                // Trigger opening animation
                setTimeout(() => {
                    modalOverlay.style.backgroundColor = 'rgba(0,0,0,0.8)';
                    modalContent.style.opacity = '1';
                    modalContent.style.transform = 'scale(1)';

                    // Show arrows with same timing
                    leftArrow.style.opacity = '1';
                    rightArrow.style.opacity = '1';
                }, 10);

                // Capture modal image dimensions after animation
                setTimeout(() => {
                    const modalImg = modalContent.querySelector('img');
                    if (modalImg) {
                        imageWrapper.modalFirstImageWidth = modalImg.offsetWidth;
                        imageWrapper.modalFirstImageHeight = modalImg.offsetHeight;
                    }
                }, 50);

                // Close modal function
                function closeModal() {
                    videoProcessingAborted = true; // Stop any ongoing video processing

                    // Hard reset to index 0 when modal closes
                    imageWrapper.currentIndex = 0;

                    // Immediately hide the navigation arrows
                    const leftArrow = modalOverlay.querySelector('.modal-nav-left');
                    const rightArrow = modalOverlay.querySelector('.modal-nav-right');
                    if (leftArrow) leftArrow.style.display = 'none';
                    if (rightArrow) rightArrow.style.display = 'none';

                    modalOverlay.style.backgroundColor = 'rgba(0,0,0,0)';
                    modalContent.style.opacity = '0';
                    modalContent.style.transform = 'scale(0.8)';
                    setTimeout(() => {
                        if (document.body.contains(modalOverlay)) {
                            document.body.removeChild(modalOverlay);
                        }
                    }, 300);
                }

                // ESC key handler
                function handleEscKey(event) {
                    if (event.key === 'Escape') {
                        closeModal();
                        document.removeEventListener('keydown', handleEscKey);
                    }
                }
                document.addEventListener('keydown', handleEscKey);

                // Background click handler - updated to not close when clicking arrows
                modalOverlay.addEventListener('click', function (event) {
                    // Don't close if clicking on video controls, video itself, or navigation arrows
                    if (event.target.closest('video, .plyr, .plyr__controls, .js-player, .modal-nav-arrow')) {
                        return;
                    }

                    // Don't close if clicking on the modal content itself
                    if (event.target.closest('.modal-container') && !event.target.classList.contains('modal-overlay')) {
                        return;
                    }

                    closeModal();
                });
            });
        }

        class ImageHandler {
            constructor() {
                this.knownNewsDomains = new Set([
                    "nytimes.com", "apnews.com", "reuters.com", "cnn.com", "bbc.com",
                    "cnbc.com", "abcnews.go.com", "aljazeera.com", "nbcnews.com", "independent.co.uk",
                    "kstp.com", "nbcnews.to", "nzherald.co.nz", "cnet.com", "latimes.com", "cbsnews.com",
                    "spin.com", "xxlmag.com", "newschannel9.com", "kutv.com", "deadline.com",
                    "wbez.org", "rawstory.com", "abc15.com", "npr.org", "foxnews.com",
                    "washingtonpost.com", "theguardian.com", "wired.com", "bloomberg.com", "politico.com"
                ]);

                this.knownMediaDomains = [
                    "i.redd.it", "v.redd.it", "streamable.com", "imgur.com", "preview.redd.it",
                    "reddit.com", "wikipedia.com", "gfycat.com", "redgifs.com", "tenor.com",
                    "youtube.com", "youtu.be"
                ];

                this.badThumbs = new Set(['self', 'default', 'nsfw', 'spoiler', 'image', '']);
                this.failureCount = new Map(); // Track failures per post
            }

            // Determine if post needs backend scraping
            shouldUseBackendScraper(post) {
                const domain = post.domain || this.getDomainFromUrl(post.url);
                const isGarbageThumb = this.badThumbs.has((post.thumbnail || '').toLowerCase());
                const isSelfPost = post.is_self || (post.domain || '').startsWith('self.');
                const isLinkPost = !isSelfPost;
                const isBareLink = post.selftext === "";
                const isRedditMedia = this.isRedditMediaUrl(post.url);
                const isKnownMediaDomain = this.knownMediaDomains.includes(domain);

                return (
                    isLinkPost &&
                    isBareLink &&
                    isGarbageThumb &&
                    !isRedditMedia &&
                    (!isKnownMediaDomain || domain === 'youtube.com')
                );
            }

            // Check if URL is Reddit media
            isRedditMediaUrl(url) {
                if (!url) return false;
                return url.includes('v.redd.it') ||
                    url.includes('i.redd.it') ||
                    url.includes('gfycat.com') ||
                    url.includes('imgur.com') ||
                    url.includes('/comments/') ||
                    url.includes('redgifs.com') ||
                    url.endsWith('.gif') ||
                    url.endsWith('.mp4') ||
                    url.endsWith('.webm');
            }

            // Extract domain from URL
            getDomainFromUrl(url) {
                try {
                    return new URL(url).hostname.replace('www.', '');
                } catch {
                    return '';
                }
            }

            // Helper function to check if URL is a Reddit domain
            isRedditDomain(url) {
                if (!url) return false;
                const redditDomains = ['i.redd.it', 'v.redd.it', 'reddit.com', 'preview.redd.it', 'external-preview.redd.it'];
                return redditDomains.some(domain => url.includes(domain));
            }

            // Handle image loading with retry logic
            async handleImageLoad(post, resultCard) {
                const postId = post.id;

                // Don't handle images for text posts UNLESS they have extracted media
                if ((post.is_self || (post.domain || '').startsWith('self.')) && !post.url.includes('i.redd.it')) {
                    return;
                }

                // Skip Reddit image domains entirely
                if (this.isRedditDomain(post.url)) {
                    return;
                }

                const shouldScrape = this.shouldUseBackendScraper(post);

                if (shouldScrape) {
                    await this.handleBackendScrapedImage(post, resultCard);
                } else {
                    await this.handleDirectImage(post, resultCard);
                }
            }

            // Handle backend-scraped images
            async handleBackendScrapedImage(post, resultCard) {
                const postId = post.id;

                try {
                    // Try cached first
                    const cached = await this.getCachedImage(postId);
                    if (cached.success && cached.data.thumbnail) {
                        this.updateImageSuccess(resultCard, cached.data.thumbnail);
                        this.createLinkPreview(post, resultCard);
                        return;
                    }

                    // Try scraping
                    const scraped = await this.scrapeImage(post);
                    if (scraped.success && scraped.data?.thumbnail) {
                        this.updateImageSuccess(resultCard, scraped.data.thumbnail);
                        this.updateCache(postId, scraped);
                        this.createLinkPreview(post, resultCard);
                        return;
                    }

                    // Failed - increment counter and maybe show news icon
                    this.handleImageFailure(postId, resultCard);

                } catch (error) {
                    console.error('❌ Backend image handling failed:', error);
                    this.handleImageFailure(postId, resultCard);
                }
            }

            // Handle direct images (non-scraped)
            async handleDirectImage(post, resultCard) {
                // Skip Reddit domains
                if (this.isRedditDomain(post.url)) {
                    return;
                }

                // Save to backend for analytics/caching WITHOUT scraping
                try {
                    await fetch(`${API_BASE}/api/save-image`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            reddit_post_id: post.id,
                            subreddit: post.subreddit,
                            title: post.title,
                            url: post.url,
                            thumbnail: post.thumbnail
                        })
                    });
                } catch (error) {
                    console.log('⚠️ Backend save failed (non-critical):', error);
                }
            }

            // Handle image failure with retry logic
            handleImageFailure(postId, resultCard) {
                const failures = this.failureCount.get(postId) || 0;
                this.failureCount.set(postId, failures + 1);

                // Show news icon immediately for backend scraping failures
                if (failures >= 2) {
                    this.showNewsIcon(resultCard);
                } else {
                    this.hideShimmer(resultCard);
                }
            }

            // Update image on success
            updateImageSuccess(resultCard, thumbnailUrl) {
                const image = resultCard.querySelector('img.result-image');
                image.style.opacity = '0';
                image.style.transition = 'opacity 0.3s ease-in-out';
                if (!image) return;

                const proxyUrl = `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(thumbnailUrl)}&t=${Date.now()}`;
                let hasRetried = false;

                const handleLoad = () => {
                    // Get shimmer element
                    const shimmer = resultCard.querySelector('.image-placeholder');

                    // Add styling class
                    image.classList.add('show');

                    // Make image visible but still transparent
                    image.style.display = 'block';

                    // Handle fade transitions simultaneously
                    if (shimmer) {
                        shimmer.style.opacity = '0';
                        shimmer.style.transition = 'opacity 0.3s ease-in-out';

                        setTimeout(() => {
                            shimmer.style.display = 'none';
                        }, 300);
                    }

                    // Small delay to ensure display:block is applied, then fade in
                    setTimeout(() => {
                        image.style.opacity = '1';
                    }, 10);

                    // Make container visible
                    const container = resultCard.querySelector('.img-container');
                    if (container) container.style.visibility = 'visible';

                    // Set up modal for scraped images  
                    const imgWrapper = resultCard.querySelector('.image-wrapper');
                    if (imgWrapper && !imgWrapper._hasModalSetup) {
                        setupImageModal(imgWrapper);
                        imgWrapper._hasModalSetup = true;
                    }
                };

                const handleError = () => {
                    if (!hasRetried) {
                        hasRetried = true;
                        image.src = thumbnailUrl; // Try raw URL without proxy
                    } else {
                        this.handleImageFailure(resultCard.dataset.postId, resultCard);
                    }
                };

                // Check if image is already cached/loaded
                if (image.complete && image.naturalWidth > 0) {
                    handleLoad();
                } else {
                    image.addEventListener('load', handleLoad);
                    image.addEventListener('error', handleError);
                }

                image.src = proxyUrl; // Start with proxy
            }

            // Show news icon
            showNewsIcon(resultCard) {
                const imgContainer = resultCard.querySelector('.img-container');
                const shimmer = resultCard.querySelector('.image-placeholder');

                if (shimmer) {
                    shimmer.classList.add('hide');
                    setTimeout(() => shimmer.style.display = 'none', 300);
                }

                if (imgContainer && !imgContainer.querySelector('.news-icon')) {
                    showNewsIcon(imgContainer, shimmer); // Your existing function
                }
            }

            // Hide shimmer animation
            hideShimmer(resultCard) {
                const shimmer = resultCard.querySelector('.image-placeholder');
                if (shimmer) {
                    shimmer.classList.add('hide');
                    setTimeout(() => shimmer.style.display = 'none', 300);
                }
            }

            // API calls
            async getCachedImage(postId) {
                const response = await fetch(`${API_BASE}/api/get-cached-image/${postId}`);
                return await response.json();
            }

            // Updated scrapeImage function
            async scrapeImage(post) {
                // Skip Reddit domains
                if (this.isRedditDomain(post.url)) {
                    return { success: false, message: 'Skipped Reddit domain' };
                }

                const response = await fetch(`${API_BASE}/api/save-image`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        reddit_post_id: post.id,
                        subreddit: post.subreddit,
                        title: post.title,
                        url: post.url,
                        thumbnail: post.thumbnail
                    })
                });
                const text = await response.text();
                if (response.ok) {
                    return JSON.parse(text);
                } else {
                    console.error('Error:', text);
                    return { success: false, message: 'Failed' };
                }
            }

            // Update cache
            updateCache(postId, data) {
                window.cachedPostsById = window.cachedPostsById || {};
                window.cachedPostsById[postId] = data;
            }

            // Create link preview for scraped posts
            createLinkPreview(post, resultCard) {
                if (resultCard.querySelector('.link-preview-card')) return;

                const domain = this.getDomainFromUrl(post.url);
                const linkPreview = document.createElement('div');
                linkPreview.className = 'link-preview-card';
                linkPreview.style.position = 'absolute';
                linkPreview.style.opacity = '0';
                linkPreview.style.transition = 'opacity 0.2s ease-in-out';
                linkPreview.innerHTML = `
        <div class="link-preview-container">
            <span class="link-domain">${domain}</span>
            <a href="${post.url}" target="_blank" rel="noopener noreferrer" class="link-preview-btn">
                Open
            </a>
        </div>
    `;

                const resultAction = resultCard.querySelector('.result-actions');
                if (resultAction) {
                    resultAction.after(linkPreview);

                    setTimeout(() => {
                        linkPreview.style.opacity = '1';
                    }, 10);
                }
            }
        }

        function createAuthorLink(author) {
            const authorLink = document.createElement('a');
            authorLink.className = 'author-link';
            authorLink.href = `https://www.reddit.com/user/${author}`;
            authorLink.target = '_blank';
            authorLink.textContent = `${author}`;
            return authorLink;
        }

        function applyStaggeredAnimation(selector, classToAdd, delayBetween = 30) {
            const elements = document.querySelectorAll(selector);
            elements.forEach((element, index) => {
                setTimeout(() => {
                    requestAnimationFrame(() => {
                        element.classList.add(classToAdd);
                    });
                }, index * delayBetween);
            });
        }

        function showLoading() {

            isLoading = true;
            resultsContainer.innerHTML = '';
            resultsContainer.innerHTML = `
    <div class='results-error' id='spinner-box' style="opacity: 0; transition: opacity 0.25s ease;"></div>
`;
            const spinnerWrapper = createCanvasSpinner();
            const spinnerBox = document.getElementById('spinner-box');
            spinnerBox.appendChild(spinnerWrapper);

            // Trigger the fade-in animation
            setTimeout(() => {
                requestAnimationFrame(() => {
                    spinnerBox.style.opacity = '1';
                });
            }, 10);

            paginationContainer.innerHTML = '';
            resultsContainer.style.opacity = 1;
        }

        // Function to fetch and cache comments for a post
        async function fetchComments(permalink, commentsContainer, post) {
            const postId = permalink;
            const now = Date.now();

            // Validate permalink first
            if (!permalink || typeof permalink !== 'string' || !permalink.startsWith('/r/')) {
                console.error('❌ Invalid permalink provided to fetchComments:', permalink);
                return;
            }

            // Check database for cached comments
            try {
                const cacheResponse = await fetch(`${API_BASE}/api/get-comments${permalink}`);
                const cacheData = await cacheResponse.json();

                if (cacheData.success && cacheData.cached && cacheData.comments.length > 0) {

                    // Keep first 15
                    const dbComments = cacheData.comments.slice(0, 8).map(comment => ({
                        author: comment.author,
                        body: comment.body,
                        score: comment.score,
                        created_utc: comment.created_utc
                    }));


                    renderComments({
                        data: {
                            children: dbComments,
                            totalCount: cacheData.comments.length,
                        }
                    }, commentsContainer, permalink, false, post, cacheData.post_total_comments);

                    // Apply the stagger animation
                    requestAnimationFrame(() => {
                        const comments = commentsContainer.querySelectorAll('.comment');
                        comments.forEach((el, i) => {
                            el.classList.remove('visible');
                            setTimeout(() => {
                                el.classList.add('visible');
                            }, i * 60);
                        });
                    });

                    return;
                }
            } catch (error) {
                console.error('Error checking database cache:', error);
            }

            // If no cache, fetch from Reddit
            const fixedPermalink = permalink.endsWith('.json') ? permalink : `${permalink}.json`;
            const commentsUrl = `${API_BASE}/reddit?url=https://www.reddit.com${fixedPermalink}%3Flimit%3D15`;

            try {
                const response = await fetch(commentsUrl);
                if (!response.ok) {
                    console.warn('Failed to fetch comments.');
                    return;
                }

                const data = await response.json();

                // Grab gallery posts while you're at it
                const fullPost = data?.[0]?.data?.children?.[0]?.data;
                // Only patch if it's actually a gallery post with the required data
                if (fullPost && fullPost.is_gallery && fullPost.gallery_data && fullPost.media_metadata) {
                    const resultCard = document.querySelector(`[data-permalink="${permalink}"]`);
                    if (resultCard) {
                        tryGalleryPatch(fullPost, permalink, resultCard);
                    }
                }

                if (!Array.isArray(data) || !data[1]?.data?.children) {
                    console.warn('⚠️ No comments found in response for permalink:', permalink);
                    return;
                }

                const commentsData = data[1].data.children;

                function flattenComments(items) {
                    let allComments = [];
                    items.forEach(item => {
                        if (item.kind === 't1' && item.data && item.data.author && item.data.body) {
                            allComments.push(item);
                        }
                        if (item.data && item.data.replies && item.data.replies.data && item.data.replies.data.children) {
                            const nestedComments = flattenComments(item.data.replies.data.children);
                            allComments = allComments.concat(nestedComments);
                        }
                    });
                    return allComments;
                }

                const flattenedComments = flattenComments(commentsData);
                const allComments = flattenedComments
                    .slice(0, 8)  // 8 comments for THIS post
                    .map(c => ({
                        id: c.data.id,
                        author: c.data.author,
                        body: c.data.body,
                        score: c.data.score,
                        created_utc: c.data.created_utc
                    }));
                const reduced = allComments.slice(0, 8);

                // Validate post id to avoid empty strings
                if (!postId || postId.trim() === '') {
                    console.error('Invalid postId for comment cache:', postId);
                    return;
                }

                renderComments({
                    data: {
                        children: reduced,
                        totalCount: commentsData.length
                    }
                }, commentsContainer, permalink, fullPost?.locked || false, fullPost, null);

                // Save comments to database
                if (allComments.length > 0) {
                    saveCommentsToDatabase(permalink, allComments, fullPost?.num_comments, fullPost?.stickied);
                }

                // Force a paint first — delay after .comment elements exist
                requestAnimationFrame(() => {
                    const comments = commentsContainer.querySelectorAll('.comment');
                    comments.forEach((el, i) => {
                        // Just to be safe, reset first
                        el.classList.remove('visible');
                        setTimeout(() => {
                            el.classList.add('visible');
                        }, i * 60); // stagger
                    });
                });

            } catch (error) {
                console.error('❌ Fetch error for', permalink, error);
            }
        }

        function saveCommentsToDatabase(permalink, comments, totalComments, isStickied) {
            fetch(`${API_BASE}/api/save-comments`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    permalink: permalink,
                    comments: comments,
                    total_comments: totalComments,
                    is_stickied: isStickied
                })
            })
                .then(res => res.json())
                .catch(err => console.error('Save comments failed:', err));
        }

        function showError(message) {
            resultsContainer.innerHTML = `
        <div class='results-error'>
            <p>${message}</p>
        </div>
        `;
            resultsContainer.style.opacity = 0;
            applyStaggeredAnimation('.results-error', 'visible', 60);
            paginationContainer.innerHTML = '';

            // Fade in the results container
            setTimeout(() => {
                resultsContainer.style.transition = 'opacity 0.3s ease';
                resultsContainer.style.opacity = 1;
            }, 10);
        }

        function renderComments(data, commentsContainer, permalink, isPostLocked, post, cachedCommentCount) {

            // Only try gallery patches when we have the actual post data
            if (data?.kind === 'Listing' && data?.data?.children?.[0]?.kind === 't3') {
                // 't3' is the prefix for posts (not comments)
                const fullPost = data?.data?.children?.[0]?.data;
                if (fullPost?.is_gallery && fullPost?.gallery_data && fullPost?.media_metadata) {
                    const resultCard = document.querySelector(`[data-permalink="${permalink}"]`);
                    tryGalleryPatch(fullPost, permalink, resultCard);

                }
            }

            // Parsing data to show if comments locked or no comments found
            const commentsData = data?.data?.children || [];
            const totalCommentsCount = data?.data?.totalCount

            const isLocked = isPostLocked;

            if (commentsData.length === 0) {
                commentsContainer.innerHTML = `
        <div class="no-comments">
            ${isLocked ? 'Comments have been locked.' : 'No comments found.'}
            ${isLocked ? '<div class="lock-icon"></div>' : ''}
        </div>
        `;
                return;
            }

            // Sort comments by score (highest first)
            commentsData.sort((a, b) => (b.score || 0) - (a.score || 0));
            commentsContainer.innerHTML = '';

            const topComments = commentsData.slice(0, 8);
            topComments.forEach(comment => {
                const c = comment;

                const commentEl = document.createElement('div');
                commentEl.className = 'comment';

                const authorEl = document.createElement('div');
                authorEl.className = 'comment-author';
                const authorIconEl = document.createElement('div');
                authorIconEl.className = 'comment-author-icon';
                authorIconEl.textContent = c.author.charAt(0).toUpperCase();
                authorEl.appendChild(authorIconEl);
                authorEl.appendChild(createAuthorLink(c.author));

                const textEl = document.createElement('div');
                textEl.className = 'comment-text';

                textEl.appendChild(renderCommentBody(c.body));

                const metaEl = document.createElement('div');
                metaEl.className = 'comment-meta';
                const scoreEl = document.createElement('span');
                scoreEl.className = 'comment-score';
                scoreEl.textContent = formatNumber(c.score) + ' points';
                const timeEl = document.createElement('span');
                timeEl.className = 'comment-time';
                timeEl.textContent = formatTimestamp(c.created_utc);
                metaEl.appendChild(scoreEl);
                metaEl.appendChild(timeEl);

                commentEl.appendChild(authorEl);
                commentEl.appendChild(textEl);
                commentEl.appendChild(metaEl);
                commentsContainer.appendChild(commentEl);
            });
            // Use comments count from one source
            const actualCommentCount = cachedCommentCount || post?.num_comments || totalCommentsCount;

            // Then change the if statement:
            if (actualCommentCount > 0) {
                const seeMoreEl = document.createElement('div');
                seeMoreEl.className = 'see-more-comments';
                seeMoreEl.textContent = `See all ${actualCommentCount} comments`;
                seeMoreEl.tabIndex = 0;

                const openLink = () => window.open(`https://www.reddit.com${permalink}`, '_blank');

                seeMoreEl.addEventListener('click', openLink);
                seeMoreEl.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        openLink();
                    }
                });

                commentsContainer.appendChild(seeMoreEl);

            } else {
                const seeMoreE2 = document.createElement('div');
                seeMoreE2.className = 'see-more-comments';
                seeMoreE2.textContent = `View on Reddit`;
                seeMoreE2.tabIndex = 0;

                const openLink = () => window.open(`https://www.reddit.com${permalink}`, '_blank');

                seeMoreE2.addEventListener('click', openLink);
                seeMoreE2.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        openLink();
                    }
                });

                commentsContainer.appendChild(seeMoreE2);
            }
        }

        function trapFocus(modalOverlay) {
            // Get all focusable elements in the modal
            const focusableElements = modalOverlay.querySelectorAll(
                'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"]), .modal-nav-arrow, .image-wrapper, video, img'
            );

            const firstElement = focusableElements[0];
            const lastElement = focusableElements[focusableElements.length - 1];

            // Focus the first element when modal opens
            setTimeout(() => firstElement?.focus(), 100);

            // Trap focus within modal
            modalOverlay.addEventListener('keydown', (e) => {
                if (e.key === 'Tab') {
                    if (e.shiftKey) {
                        // Shift + Tab (backwards)
                        if (document.activeElement === firstElement) {
                            e.preventDefault();
                            lastElement.focus();
                        }
                    } else {
                        // Tab (forwards)
                        if (document.activeElement === lastElement) {
                            e.preventDefault();
                            firstElement.focus();
                        }
                    }
                }

                // Close modal on Escape
                if (e.key === 'Escape') {
                    closeModal();
                }
            });
        }

        function extractPreviewFromSelftext(selftext) {
            if (!selftext) return null;

            // Look for direct i.redd.it or preview.redd.it URLs
            const mediaRegex = /(https?:\/\/(?:i\.redd\.it|preview\.redd\.it)\/[^\s]+\.(?:gif|jpg|jpeg|png|webp))/i;
            const match = selftext.match(mediaRegex);

            if (match && match[1]) {
                return match[1];
            }
            return null;
        }
        
        function updatePagination() {
            const visibleCards = document.querySelectorAll('.result-card:not([style*="display: none"])');
            paginationContainer.innerHTML = '';

            // ← Previous button
            if (currentPageIndex > 0) {
                const prevButton = document.createElement('button');
                prevButton.className = 'pagination-button';
                prevButton.textContent = '← Previous';
                prevButton.addEventListener('click', () => {
                    const prevPageData = loadPageDataFromSession(currentPageIndex - 1);

                    if (prevPageData) {
                        currentPageIndex--;
                        currentAfter = prevPageData.after || null;
                        currentBefore = prevPageData.before || null;

                        handleSearchRequest(prevPageData.results, false, true); // args: results, navigateBack, isPopstate
                    } else {
                        console.warn('No session data found for previous page');
                    }
                });
                paginationContainer.appendChild(prevButton);
            }


            // → Next button
            if (visibleCards.length >= 10 && currentAfter) {
                const nextButton = document.createElement('button');
                nextButton.className = 'pagination-button';
                nextButton.textContent = 'Next →';
                nextButton.addEventListener('click', () => {
                    currentPageIndex++;
                    handleSearchRequest(currentAfter, null, false, false);
                });
                paginationContainer.appendChild(nextButton);
            }
        }


        function getCacheKey(index, filters) {
            return `kf_page_${index}__${buildCacheKey('base', filters)}`;
        }

        function savePageDataToSession(index, data) {
            const filters = currentFilters || getCurrentFiltersFromUI();
            const token = `kf_page_${index}__base__${buildCacheKey('', filters)}`;
            sessionStorage.setItem(token, JSON.stringify(data));
        }

        function loadPageDataFromSession(index) {
            const params = new URLSearchParams(window.location.search);

            const filters = {
                query: params.get('q') || '',
                subreddit: params.get('sub') || '',
                sort: params.get('sort') || 'hot',
                time: params.get('time') || 'all',
                contentType: params.get('type') || 'all',
            };

            const token = `kf_page_${index}__base__${buildCacheKey('', filters)}`;
            const raw = sessionStorage.getItem(token);
            return raw ? JSON.parse(raw) : null;
        }

        function savePaginationState(results = []) {
            // Save full page data
            savePageDataToSession(currentPageIndex, {
                query: currentFilters.query,
                subreddit: currentFilters.subreddit,
                sort: currentFilters.sort,
                time: currentFilters.time,
                contentType: currentFilters.contentType,
                after: currentAfter,
                before: currentBefore,
                nextBefore: results.length > 0 ? `t3_${results[0].id}` : null,
                results,
                toggle1: document.getElementById('toggle1')?.checked || false,
                toggle2: document.getElementById('toggle2')?.checked || false
            });

            // Save tokens for prev button
            const state = JSON.parse(sessionStorage.getItem('paginationState') || '{}');
            state[currentPageIndex] = { after: currentAfter, before: currentBefore };
            sessionStorage.setItem('paginationState', JSON.stringify(state));

            // Save global state
            sessionStorage.setItem('kf_current_page_index', currentPageIndex.toString());
            sessionStorage.setItem('kf_current_filters', JSON.stringify(currentFilters));
        }



        function getPaginationToken(index) {
            const state = JSON.parse(sessionStorage.getItem('paginationState') || '{}');
            return state[index] || {};
        }

        function formatTimestamp(timestamp) {
            const date = new Date(timestamp * 1000);
            const now = new Date();
            const diffSeconds = Math.floor((now - date) / 1000);

            if (diffSeconds < 60) {
                return `${diffSeconds} second${diffSeconds !== 1 ? 's' : ''} ago`;
            }

            const diffMinutes = Math.floor(diffSeconds / 60);
            if (diffMinutes < 60) {
                return `${diffMinutes} minute${diffMinutes !== 1 ? 's' : ''} ago`;
            }

            const diffHours = Math.floor(diffMinutes / 60);
            if (diffHours < 24) {
                return `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
            }

            const diffDays = Math.floor(diffHours / 24);
            if (diffDays < 30) {
                return `${diffDays} day${diffDays !== 1 ? 's' : ''} ago`;
            }

            const diffMonths = Math.floor(diffDays / 30);
            if (diffMonths < 12) {
                return `${diffMonths} month${diffMonths !== 1 ? 's' : ''} ago`;
            }

            const diffYears = Math.floor(diffMonths / 12);
            return `${diffYears} year${diffYears !== 1 ? 's' : ''} ago`;
        }

        function toggleThemeMenu() {
            const dropdown = document.getElementById('themeDropdown');
            dropdown.classList.toggle('show');

            // Update active theme when menu opens
            updateActiveTheme();
        }

        function selectTheme(themeName) {
            // If choosing a light theme, save it as the previous theme
            if (themeName !== 'dark') {
                localStorage.setItem('previousTheme', themeName);
            }

            applyTheme(themeName);
            document.getElementById('themeDropdown').classList.remove('show');
        }


        function handleThemeKeydown(event, themeName) {
            if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                selectTheme(themeName);
            }
        }

        function updateActiveTheme() {
            // Get current theme from localStorage
            const currentTheme = localStorage.getItem('selectedTheme') || 'default';

            // Remove active class from all options
            const options = document.querySelectorAll('.theme-option');
            options.forEach(option => option.classList.remove('active'));

            // Add active class to current theme
            const activeOption = document.querySelector(`[onclick="selectTheme('${currentTheme}')"]`);
            if (activeOption) {
                activeOption.classList.add('active');
            }
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function (event) {
            const dropdown = document.getElementById('themeDropdown');
            const themeButton = document.querySelector('.theme-arrow');

            if (dropdown.classList.contains('show') &&
                !dropdown.contains(event.target) &&
                !themeButton.contains(event.target)) {
                dropdown.classList.remove('show');
            }
        });

        // Close on right-click anywhere
        document.addEventListener('contextmenu', function (event) {
            const dropdown = document.getElementById('themeDropdown');
            if (dropdown.classList.contains('show')) {
                dropdown.classList.remove('show');
            }
        });

        function formatNumber(num) {
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'm';
            }
            if (num >= 1000) {
                return (num / 1000).toFixed(1) + 'k';
            }
            return num.toString();
        }

        function getDomainFromUrl(url) {
            try {
                return new URL(url).hostname.replace('www.', '');
            } catch {
                return null;
            }
        }

        // Verification handler
        document.addEventListener('DOMContentLoaded', function () {
            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('token');
            if (token) {
                // This is a magic link verification
                verifyMagicLink(token);
            }

            // Check for payment success
            if (urlParams.get('success') === 'true') {
                const sessionId = urlParams.get('session_id');
                // Auto-login after successful payment
                fetch(`${API_BASE}/api/auto-login-after-payment`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: sessionId })
                })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // Set login state
                            isLoggedIn = true;
                            window.authToken = data.authToken;
                            localStorage.setItem('isLoggedIn', 'true');
                            localStorage.setItem('userEmail', data.email);
                            localStorage.setItem('hasSubscription', data.hasSubscription);
                            localStorage.setItem('planType', data.planType);
                            localStorage.setItem('authToken', data.authToken);
                            // Show correct message
                            if (data.planType === 'premium') {
                                Swal.fire({
                                    title: 'Account Created!',
                                    text: 'Your account has been created. Thank you for unlocking Premium!',
                                    confirmButtonText: 'Great!'
                                });
                            } else if (data.planType === 'pro') {
                                Swal.fire({
                                    title: 'Account Created!',
                                    text: 'Your account has been created. Thank you for unlocking Pro!',
                                    confirmButtonText: 'Great!'
                                });
                            }
                            // FETTI TIME!
                            moneyShot();
                            updateLoginButton();
                            showSpeechBubble("It's great value, honest.");
                        }
                    });
            }
            updatePlanDisplay();
        });

        function moneyShot() {
            // First burst from center
            confetti({
                particleCount: 200,
                spread: 180,
                origin: { x: 0.5, y: 0.5 }
            });

            // Left side burst
            setTimeout(() => {
                confetti({
                    particleCount: 150,
                    spread: 120,
                    origin: { x: 0.1, y: 0.3 }
                });
            }, 200);

            // Right side burst
            setTimeout(() => {
                confetti({
                    particleCount: 150,
                    spread: 120,
                    origin: { x: 0.9, y: 0.3 }
                });
            }, 400);

            // Top corners
            setTimeout(() => {
                confetti({
                    particleCount: 100,
                    spread: 90,
                    origin: { x: 0.2, y: 0.1 }
                });
                confetti({
                    particleCount: 100,
                    spread: 90,
                    origin: { x: 0.8, y: 0.1 }
                });
            }, 600);

            // Final center blast
            setTimeout(() => {
                confetti({
                    particleCount: 300,
                    spread: 200,
                    origin: { x: 0.5, y: 0.6 },
                    colors: ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff']
                });
            }, 800);
        }

        // Boolean that gets updated
        let isLoggedIn = localStorage.getItem('isLoggedIn') === 'true';

        function updateLoginButton() {
            const btnText = document.getElementById('loginBtnText');
            const btn = document.getElementById('loginLogoutBtn');
            if (isLoggedIn) {
                btnText.textContent = 'Log Out';
                btn.onclick = async () => {
                    const result = await Swal.fire({
                        title: 'Are you sure you want to log out?',
                        showCancelButton: true,
                        confirmButtonText: 'Yes',
                        cancelButtonText: 'No',
                        icon: 'question'
                    });

                    if (result.isConfirmed) {
                        isLoggedIn = false;
                        localStorage.setItem('isLoggedIn', 'false');
                        // Clear all user data
                        clearUserDataOnLogout();
                        // Clear bookmarks
                        sessionStorage.removeItem('bookmarks');
                        document.querySelectorAll('.bookmark-icon').forEach(icon => {
                            icon.classList.remove('saved');
                        });
                        // Reset theme to default when logging out
                        localStorage.setItem('theme', 'default');
                        applyTheme('default')
                        updateLoginButton();
                        // Always redirect to main page on logout
                        window.location.href = 'karmafinder.html';
                    }
                };
            } else {
                btnText.textContent = 'Log In';
                btn.onclick = () => {
                    window.location.href = 'login.html';
                };
            }
            updateThemeToggleVisibility();
            updatePlanDisplay();
        }

        function updateThemeToggleVisibility() {
            const themeContainer = document.querySelector('.theme-toggle-container');
            if (isLoggedIn) {
                themeContainer.classList.add('visible');
            } else {
                themeContainer.classList.remove('visible');
            }
        }

        function clearUserDataOnLogout() {
            localStorage.removeItem('userEmail');
            localStorage.removeItem('authToken');
            localStorage.removeItem('hasSubscription');
            localStorage.removeItem('planType');
            window.authToken = null;
        }

        async function verifyMagicLink(token) {
            try {
                const response = await fetch(`${API_BASE}/api/auth/verify/${token}`, {
                    method: 'POST'
                });
                const data = await response.json();
                if (response.ok) {
                    isLoggedIn = true;
                    window.authToken = data.authToken;
                    localStorage.setItem('isLoggedIn', 'true');
                    localStorage.setItem('userEmail', data.email);
                    localStorage.setItem('hasSubscription', data.hasSubscription);
                    localStorage.setItem('planType', data.planType);
                    localStorage.setItem('authToken', data.authToken);
                    updateLoginButton();
                    const urlParams = new URLSearchParams(window.location.search);
                    const redirect = urlParams.get('redirect');
                    if (redirect === 'bookmarks') {
                        window.location.href = 'karmafinder.html?page=bookmarks';
                        return;
                    }
                    window.history.replaceState({}, document.title, window.location.pathname);
                    Swal.fire('Success!', 'Successfully logged in!');
                } else {
                    Swal.fire('Error', 'Invalid or expired magic link');
                }
            } catch (error) {
                Swal.fire('Error', 'Verification failed. Please try again.');
            }
        }

        document.querySelector('.bookmark-link').addEventListener('click', function (e) {
            if (!isLoggedIn) {
                e.preventDefault();
                window.location.href = 'login.html?redirect=bookmarks';
            }
        });

        document.getElementById('getPremiumContainer').onclick = () => {
            window.open('features.html', '_blank');
        };

        const toggleManager = new ToggleManager();

        // Set initial toggle states immediately based on actual requirements
        if (typeof isLoggedIn !== 'undefined' && !isLoggedIn) {
            // Logged out: always reddit search
            document.getElementById('toggle1').checked = false;
            document.getElementById('toggle2').checked = true;
        } else if (typeof isLoggedIn !== 'undefined' && isLoggedIn) {
            // Logged in: check sessionStorage
            const savedToggle1 = sessionStorage.getItem('toggle1State') === 'true';
            if (savedToggle1) {
                document.getElementById('toggle1').checked = true;
                document.getElementById('toggle2').checked = false;
            } else {
                document.getElementById('toggle1').checked = false;
                document.getElementById('toggle2').checked = true;
            }
        } else {
            // Default fallback if isLoggedIn not defined yet
            document.getElementById('toggle1').checked = false;
            document.getElementById('toggle2').checked = true;
        }
            toggleManager.updateSortDropdown();

        function updatePlanDisplay() {
            const isLoggedIn = localStorage.getItem('isLoggedIn') === 'true';
            const getPremiumContainer = document.getElementById('getPremiumContainer');

            if (isLoggedIn) {
                const userEmail = localStorage.getItem('userEmail');

                // Create a simpler endpoint that just takes email as a parameter
                fetch(`${API_BASE}/api/subscription/${userEmail}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            localStorage.setItem('hasSubscription', data.hasSubscription);
                            localStorage.setItem('planType', data.planType);
                            getPremiumContainer.style.display = 'none';

                            const planDisplayElement = document.getElementById('plan-display');
                            if (data.hasSubscription && data.planType) {
                                const planName = data.planType.charAt(0).toUpperCase() + data.planType.slice(1);
                                planDisplayElement.textContent = `Current Plan: ${planName}`;

                                // Add plan-specific class
                                planDisplayElement.className = `plan-display plan-${data.planType}`;
                                planDisplayElement.parentElement.classList.add('visible');
                            }
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching subscription:', error);
                        // Fallback to showing what's in localStorage
                        showFromLocalStorage();
                        getPremiumContainer.style.display = 'none';
                    });
            } else {
                const planDisplayElement = document.getElementById('plan-display');
                planDisplayElement.parentElement.classList.remove('visible');
                getPremiumContainer.style.display = 'flex';
            }
        }

        function analyzeGalleryAspectRatios(galleryData, mediaMetadata) {
            const aspectRatios = [];

            for (const item of galleryData) {
                const media = mediaMetadata[item.media_id];
                if (media?.s?.x && media?.s?.y) {
                    aspectRatios.push(media.s.x / media.s.y);
                }
            }

            if (aspectRatios.length < 2) return { useSameSize: false };

            const maxRatio = Math.max(...aspectRatios);
            const minRatio = Math.min(...aspectRatios);
            const variance = (maxRatio - minRatio) / minRatio;

            const useSameSize = variance <= 0.2; // Within 15%

            return { useSameSize };
        }

        function showFromLocalStorage() {
            const hasSubscription = localStorage.getItem('hasSubscription') === 'true';
            const planType = localStorage.getItem('planType');
            const planDisplayElement = document.getElementById('plan-display');

            if (hasSubscription && planType) {
                const planName = planType.charAt(0).toUpperCase() + planType.slice(1);
                planDisplayElement.textContent = `Current Plan: ${planName}`;
                planDisplayElement.parentElement.classList.add('visible');
            } else {
                planDisplayElement.parentElement.classList.remove('visible');
            }
        }

        // Security function to prevent XSS
        function sanitizeHTML(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function getSubredditIcon(subreddit) {

            // Validate subreddit parameter
            if (!subreddit || subreddit === 'undefined' || subreddit === 'null' || typeof subreddit !== 'string') {
                console.warn('⚠️ getSubredditIcon called with invalid subreddit:', subreddit);
                return '/api/placeholder/20/20';
            }

            // Clean and validate subreddit name
            const cleanSubreddit = subreddit.trim();
            if (cleanSubreddit.length === 0) {
                console.warn('⚠️ getSubredditIcon called with empty subreddit');
                return '/api/placeholder/20/20';
            }

            const storageKey = `subreddit_icon_${cleanSubreddit}`;

            // Check if icon is in sessionStorage
            const cachedIcon = sessionStorage.getItem(storageKey);
            if (cachedIcon !== null) {
                if (cachedIcon === 'null') {
                    return '/api/placeholder/20/20';
                }
                return cachedIcon;
            }

            try {
                const response = await fetch(`${API_BASE}/reddit/icons?subreddits=${encodeURIComponent(cleanSubreddit)}`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();
                const iconUrl = data[cleanSubreddit];
                if (!iconUrl) {
                    sessionStorage.setItem(storageKey, 'null');
                    return '/api/placeholder/20/20';
                }
                // Save to sessionStorage
                sessionStorage.setItem(storageKey, iconUrl);
                return iconUrl;
            } catch (err) {
                console.error(`❌ Failed to fetch icon for r/${cleanSubreddit}:`, err.message);
                sessionStorage.setItem(storageKey, 'null');
                return '/api/placeholder/20/20';
            }
        }

        function tryMediaPatch(fPost, resultCard, attempt = 1) {
            const cacheKey = fPost.url;
            const cached = window.cachedMediaByUrl[cacheKey];

            // 🕗 If cache isn't ready yet, wait for it
            if (!window.cachedMediaByUrl) {
                document.addEventListener('cachedPostsReady', () => {
                    tryMediaPatch(fPost, resultCard, attempt);
                }, { once: true });
                return;
            }

            if (!cached) {
                if (attempt < 10) { // Increased retry attempts
                    setTimeout(() => tryMediaPatch(fPost, resultCard, attempt + 1), 200); // Longer wait
                } else {
                    // console.warn(`⚠️ No cached media found after ${attempt} tries for ${cacheKey}`);
                }
                return;
            }

            // Preserve original URL before overwriting
            if (!fPost.originalUrl) {
                fPost.originalUrl = fPost.url;
            }

            // Patch media fields from cache with safety checks
            fPost.animated = cached.animated !== undefined ? cached.animated : fPost.animated;
            fPost.frame_count = cached.frame_count !== undefined ? cached.frame_count : fPost.frame_count;
            fPost.duration = cached.duration !== undefined ? cached.duration : fPost.duration;
            fPost.url = cached.url || fPost.url;

            const imgContainer = resultCard.querySelector('.img-container');
            const imgWrapper = resultCard.querySelector('.image-wrapper');
            if (!imgContainer || !imgWrapper) return;

            if (imgContainer.style.visibility === 'hidden') {
                imgContainer.style.visibility = 'visible';
            }

            let shimmer = resultCard.querySelector('.image-placeholder');
            if (!shimmer) {
                shimmer = document.createElement('div');
                shimmer.className = 'image-placeholder shimmer';
                imgWrapper.prepend(shimmer);
            } else {
                shimmer.style.display = 'block';
            }

            const fallbackURL = `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(cached.url)}&t=${Date.now()}`;
            const mediaElement = resultCard.querySelector('.result-image');
            if (!mediaElement) {
                console.warn(`❌ No media element found for URL key: ${cacheKey}`);
                return;
            }

            // Check if image-wrapper exists, create if missing
            if (!imgWrapper) {
                // Create the missing wrapper structure
                imgWrapper = document.createElement('div');
                imgWrapper.className = 'image-wrapper';
                imgWrapper.style.cursor = 'pointer';

                // Move the image inside the wrapper
                const parent = mediaElement.parentNode;
                parent.insertBefore(imgWrapper, mediaElement);
                imgWrapper.appendChild(mediaElement);
            }

            mediaElement.onerror = () => {
                mediaElement.src = cached.url;
            };

            mediaElement.onload = () => {
                shimmer.style.display = 'none';
                mediaElement.classList.add('show');
            };

            mediaElement.src = fallbackURL;

            // Detect media types
            const isGif = mediaElement.src?.toLowerCase().includes('gif');
            const isActuallyAnimated = fPost.animated === true;
            const isVideo = fPost.is_video ||
                (fPost.domain && fPost.domain.includes('youtu')) ||
                (fPost.url && fPost.url.includes('v.redd.it')) ||
                (fPost.domain && fPost.domain.includes('streamable')) ||
                (fPost.url && fPost.url.endsWith('.gifv'));
        }

        function classifyContentType(post) {
            // Text detection first 
            if (post.is_self === true) return 'text';
            if (post.domain && post.domain.startsWith('self.')) return 'text';
            if (post.url && post.url.includes('/comments/')) return 'text';

            // Video detection
            if (post.is_video === true) return 'video';
            const videoDomains = ['youtube.com', 'youtu.be', 'streamable.com', 'twitch.tv', 'vimeo.com', 'gfycat.com', 'v.redd.it', 'redgifs.com'];
            if (post.domain && videoDomains.some(domain => post.domain.includes(domain))) {
                return 'video';
            }

            // Playable/static GIF detection
            const isActuallyAnimated = post.animated === true;
            const isGalleryGif = (
                post.media_metadata &&
                typeof post.media_metadata === 'object' &&
                Object.values(post.media_metadata).some(item => item.e === 'AnimatedImage')
            );
            const isVideo = post.is_video ||
                (post.domain && post.domain.includes('youtu')) ||
                (post.url && post.url.includes('v.redd.it')) ||
                (post.domain && post.domain.includes('streamable')) ||
                (post.domain && post.domain.includes('redgifs.com')) ||
                (post.url && post.url.endsWith('.gifv'));

            // Same condition as play icon: if it would get a play icon, it's "video"
            if (isGalleryGif || (isVideo && !isActuallyAnimated)) {
                return 'video';
            }

            // Picture detection
            if (post.is_gallery === true) return 'image';
            if (post.preview && post.preview.images && post.preview.images.length > 0) return 'image';
            if (post.media_metadata && Object.keys(post.media_metadata).length > 0) return 'image';

            // First check actual image domains
            const imageDomains = ['i.redd.it', 'imgur.com', 'preview.redd.it'];
            if (post.domain && imageDomains.includes(post.domain)) {
                return 'image';
            }

            // URL extension check for direct image links
            if (post.url && /\.(jpg|jpeg|png|gif|webp)$/i.test(post.url)) {
                return 'image';
            }

            // If it's not i.redd.it and not a video domain, it's probably external/news = image
            if (post.domain && post.domain !== 'i.redd.it' && !videoDomains.some(domain => post.domain.includes(domain))) {
                return 'image';
            }

            return 'text';
        }

        function loadCachedPosts() {
            // Initialize global cache objects if they don't exist
            if (typeof window !== 'undefined') {
                if (!window.cachedPostsById) window.cachedPostsById = {};
                if (!window.cachedMediaByUrl) window.cachedMediaByUrl = {};
            }

            return Promise.resolve();
        }

        function addPlayIconIfNeeded(fPost, resultCard) {
            const imgContainer = resultCard.querySelector('.img-container');
            const mediaElement = resultCard.querySelector('.result-image');
            if (!imgContainer || !mediaElement) return;
            if (imgContainer.querySelector('.play-icon')) return;
            const isGif = fPost.url?.toLowerCase().includes('gif');
            const isActuallyAnimated = fPost.animated === true;
            const isGalleryGif = (
                fPost.media_metadata &&
                typeof fPost.media_metadata === 'object' &&
                Object.values(fPost.media_metadata).some(item => item.e === 'AnimatedImage')
            );
            const isVideo = fPost.is_video ||
                (fPost.domain && fPost.domain.includes('youtu')) ||
                (fPost.url && fPost.url.includes('v.redd.it')) ||
                (fPost.domain && fPost.domain.includes('streamable')) ||
                (fPost.domain && fPost.domain.includes('redgifs.com')) ||
                (fPost.url && fPost.url.endsWith('.gifv'));

            const isImgur = (fPost.url && fPost.url.includes('imgur')) && (fPost.url && fPost.url.endsWith('.gifv')) && isActuallyAnimated;
            // Show play icon if it's a gallery gif, or if it's a video and not actually animated
            const shouldShowPlayIcon = isGalleryGif || (isVideo && !isActuallyAnimated);
            if (shouldShowPlayIcon && !isImgur) {
                const playIcon = document.createElement('div');
                playIcon.className = 'play-icon';
                playIcon.innerHTML = '▶';
                imgContainer.appendChild(playIcon);
            }
        }

        let isPopstateEvent = false;

        function updateURL() {
        if (isPopstateEvent) return;
            const urlParams = new URLSearchParams(window.location.search);
            const isBookmarksPage = urlParams.get('page') === 'bookmarks';
            if (isBookmarksPage) return;

            const subredditTyped = document.getElementById('subreddit-input').value.trim();
            const chipVisible = subredditChipContainer.style.display === 'flex';
            const chipText = chipVisible && subredditChipContainer.querySelector('.chip-text')
                ? subredditChipContainer.querySelector('.chip-text').textContent.replace('r/', '')
                : '';
            const subreddit = chipText || subredditTyped;

            const filters = getCurrentFiltersFromUI();
            filters.subreddit = subreddit;

            const params = new URLSearchParams(window.location.search);

            params.set('page', currentPageIndex);

            if (currentPageIndex === 0) {
                params.delete('after');
                params.delete('before');
            } else {
                if (currentAfter) params.set('after', currentAfter);
                else params.delete('after');

                if (currentBefore) params.set('before', currentBefore);
                else params.delete('before');
            }

            if (filters.query) params.set('q', filters.query); else params.delete('q');
            params.set('sub', filters.subreddit || 'all');
            if (filters.contentType && filters.contentType !== 'all') params.set('type', filters.contentType); else params.delete('type');
            if (filters.sort && filters.sort !== 'hot') params.set('sort', filters.sort); else params.delete('sort');
            if (filters.time && filters.time !== 'all') params.set('time', filters.time); else params.delete('time');

            const newURL = `${window.location.pathname}?${params.toString()}`;
            if (!isPopstateEvent) {
                history.pushState({}, '', newURL);
            }
        }

        function initBookmarksFromURL() {
            const authToken = window.authToken;
            const urlParams = new URLSearchParams(window.location.search);
            const sectionParam = urlParams.get('section');
            const urlSectionId = sectionParam ? parseInt(sectionParam) : null;

            initializeTabs().then(() => {
                return fetch(`${API_BASE}/api/sections`, {
                    headers: {
                        'Authorization': authToken
                    }
                });
            })
                .then(response => response.json())
                .then(data => {
                    let targetSectionId;
                    if (urlSectionId && data.sections.find(section => section.id === urlSectionId)) {
                        targetSectionId = urlSectionId;
                    } else {
                        targetSectionId = data.sections[0]?.id;
                    }
                    loadSectionContent(targetSectionId, false, true);
                });
        }


        function initPage() {
            updateLoginButton();

            // Set currentPageIndex, currentAfter, currentBefore immediately
            loadPaginationState();

            const isBookmarksPage = window.location.search.includes('page=bookmarks');

            if (!isBookmarksPage) {
                loadCachedPosts();
            }

            const input = document.querySelector('#subreddit-input');
            const dropdown = document.querySelector('.subreddit-suggestions');
            if (input && dropdown) {
                document.addEventListener('mousedown', (e) => {
                    if (!input.contains(e.target) && !dropdown.contains(e.target) && !e.target.classList.contains('delete-recent-btn')) {
                        dropdown.classList.remove('active');
                    }
                });
                dropdown.addEventListener('click', (e) => {
                    const clickedItem = e.target.closest('.subreddit-suggestion');
                    if (clickedItem) {
                        input.value = clickedItem.dataset.name || clickedItem.innerText;
                        dropdown.classList.remove('active');
                    }
                });
            }

            if (isBookmarksPage) {
                initBookmarksFromURL();
                return;
            }

            const urlParams = new URLSearchParams(window.location.search);
            const isHomepageFromURL = currentPageIndex === 0 &&
                !urlParams.has('q') &&
                !urlParams.has('sub') &&
                !urlParams.has('sort') &&
                !urlParams.has('time') &&
                !urlParams.has('type');

            if (isHomepageFromURL) {
                currentPageIndex = 0;
                currentAfter = null;
                currentBefore = null;
            }

            let initialAfterToken = null;
            let initialBeforeToken = null;

            if (currentPageIndex > 0) {
                const prevPageData = loadPageDataFromSession(currentPageIndex - 1);

                if (prevPageData) {
                    initialAfterToken = prevPageData.after || null;
                    initialBeforeToken = prevPageData.before || null;
                } else {
                    currentPageIndex = 0;
                    initialAfterToken = null;
                    initialBeforeToken = null;
                }

            } else {
            }

            if (window.authToken) {
                preloadBookmarks(() => {
                    handleSearchRequest(initialAfterToken, initialBeforeToken, false, true);
                });
            } else {
                handleSearchRequest(initialAfterToken, initialBeforeToken, false, true);
            }
        }

        // DOM load wrapper
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                initPage();
                loadBlocklist();
            });
        } else {
            initPage();
            loadBlocklist();
        }

        function getYouTubeThumbnail(url) {
            // Extract video ID from various YouTube URL formats
            const match = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/);

            if (match && match[1]) {
                const videoId = match[1];
                return `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;
            }

            return null;
        }

        function savePostsToDatabase(posts, pageGroupParam) {
            // Only save if there are 10 or more posts
            if (posts.length < 10) {
                //console.log(`⛔ Skipping save — only ${posts.length} posts`);
                return;
            }

            const pageGroup = pageGroupParam;

            // ✅ Filter out posts with missing or invalid data
            const validPosts = posts.filter(post => post?.data && post.data.id);

            // 🚨 Check if any were dropped
            if (validPosts.length < posts.length) {
                console.warn(`⚠️ Dropped ${posts.length - validPosts.length} malformed posts`);
            }

            // ✅ Clean and map posts
            const cleanPosts = validPosts.map((post, index) => ({
                data: {
                    id: post.data.id,
                    title: post.data.title || '',
                    url: post.data.url || '',
                    permalink: post.data.permalink || '',
                    subreddit: post.data.subreddit || '',
                    score: post.data.score || 0,
                    is_video: Boolean(post.data.is_video),
                    domain: post.data.domain || '',
                    author: post.data.author || '',
                    created_utc: post.data.created_utc || 0,
                    num_comments: post.data.num_comments || 0,
                    over_18: Boolean(post.data.over_18),
                    selftext: post.data.selftext || '',
                    body: post.data.body || '',
                    is_gallery: Boolean(post.data.is_gallery),
                    gallery_data: post.data.gallery_data || null,
                    media_metadata: post.data.media_metadata || null,
                    crosspost_parent_list: post.data.crosspost_parent_list || [],
                    content_type: post.data.content_type || '',
                    icon_url: post.data.icon_url || null,
                    locked: Boolean(post.data.locked),
                    stickied: Boolean(post.data.stickied),
                    preview: post.data.preview || null,
                    position: index
                }
            }));

            // Send to server 
            fetch(`${API_BASE}/api/save-posts`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    posts: cleanPosts,
                    page_group: pageGroup
                })
            })
                .then(res => {
                    if (!res.ok) {
                        throw new Error(`Server error: ${res.status}`);
                    }
                    return res.json();
                })
                .catch(err => console.error(`Save failed: ${err.message}`));
        }

        function getThumbnailUrl(post) {

            // For Reddit videos without preview, construct DASH thumbnail URL
            if (post.is_video && post.url && post.url.includes('v.redd.it')) {
                const cleanUrl = post.url.split('?')[0];
                const videoId = cleanUrl.split('/').pop();
                const dashUrl = `https://v.redd.it/${videoId}/DASH_480.mp4`;
                // DON'T proxy video files - return direct URL
                return dashUrl;
            }

            // Check if it's a regular thumbnail
            if (post.thumbnail && !['self', 'default', 'nsfw', 'spoiler', 'image'].includes(post.thumbnail.toLowerCase())) {
                return post.thumbnail;
            }

            // Final fallback: use real_thumbnail if available
            if (post.real_thumbnail && !['self', 'default', 'nsfw', 'spoiler', 'image'].includes(post.real_thumbnail.toLowerCase())) {
                return post.real_thumbnail;
            }

            // Check if the URL is a direct link to media
            if (post.url) {
                const mediaExtensions = [
                    '.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.svg',
                    '.mp4', '.webm', '.mov', '.avi', '.mkv', '.m4v'
                ];

                const mediaHosts = [
                    'i.redd.it', 'v.redd.it', 'preview.redd.it',
                    'i.imgur.com', 'media.giphy.com', 'gfycat.com',
                    'streamable.com'
                ];

                const urlLower = post.url.toLowerCase();
                const isDirectMedia = mediaExtensions.some(ext => urlLower.endsWith(ext)) ||
                    mediaHosts.some(host => urlLower.includes(host));

                if (isDirectMedia) {
                    return post.url;
                }
            }

            return null;
        }

        function decodeEntities(input) {
            const txt = document.createElement('textarea');
            txt.innerHTML = input;
            return txt.value;
        }

        function parseMarkdown(text) {
            let processed = text;

            // Headers (h1-h6) - ADD THIS HERE, FIRST!
            processed = processed.replace(/^#{1,6}\s*(.+)$/gm, (match, content) => {
                const level = match.match(/^#+/)[0].length;
                return `<h${level}>${content}</h${level}>`;
            });

            // Bold
            processed = processed.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
            processed = processed.replace(/__(.+?)__/g, '<strong>$1</strong>');

            // Italic - use word boundaries
            processed = processed.replace(/\*([^*]+?)\*/g, '<em>$1</em>');
            processed = processed.replace(/\b_(.+?)_\b/g, '<em>$1</em>');

            // Strikethrough (~~text~~)
            processed = processed.replace(/~~([^~]+)~~/g, '<del>$1</del>');

            // Inline code (`code`)
            processed = processed.replace(/`([^`]+)`/g, '<code>$1</code>');

            // Reddit spoilers (>!text!<)
            processed = processed.replace(/>!([^!]+)!</g, '<span class="spoiler">$1</span>');

            // Quotes (lines starting with >)
            processed = processed.replace(/^>\s?(.+)$/gm, '<blockquote>$1</blockquote>');

            // Links with text [text](url)
            processed = processed.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, text, url) => {
                // Sanitize URL
                if (url.startsWith('javascript:') || url.startsWith('data:') || url.startsWith('vbscript:')) {
                    return text; // Strip malicious links
                }
                // Ensure it's a valid HTTP/HTTPS URL
                if (!url.match(/^https?:\/\//)) {
                    return text; // Strip non-HTTP links
                }
                return `<a href="${url}" target="_blank" rel="noopener noreferrer">${text}</a>`;
            });

            // Line breaks (Reddit uses two spaces at end of line or double newline)
            if (processed.match(/[\[\(][^\]\)]*$/)) {
                processed = processed.replace(/[\[\(][^\]\)]*$/, '...');
            }

            processed = processed.replace(/  \n/g, '<br>');
            processed = processed.replace(/\n\n/g, '<br><br>');

            return processed;
        }

        function renderCommentBody(rawBody) {

            const wrapper = document.createElement('div');
            wrapper.className = 'comment-body';
            wrapper.tabIndex = 0;
            wrapper.setAttribute('aria-label', 'Comment content');

            // Decode HTML entities
            const txt = document.createElement("textarea");
            txt.innerHTML = rawBody.trim();
            let decoded = txt.value;

            // Check for Reddit images first
            const imageRegex = /(https:\/\/preview\.redd\.it\/[^\s]+?\.(jpeg|jpg|png|gif|webp)(\?[^\s]*)?)/i;
            const imageMatch = decoded.match(imageRegex);

            // Check for different GIF formats
            const giphyRegex = /!\[gif\]\(giphy\|([^|)]+)(?:\|[^)]*)?\)/i;
            const redditGifRegex = /!\[gif\]\(emote\|[^|]*\|([^\)]+)\)/i;
            const directGifRegex = /(https?:\/\/[^\s]+\.gif(\?[^\s]*)?)/i;

            const giphyMatch = decoded.match(giphyRegex);
            const redditGifMatch = decoded.match(redditGifRegex);
            const directGifMatch = decoded.match(directGifRegex);

            if (imageMatch) {
                // Handle Reddit images
                const img = document.createElement('img');
                img.src = imageMatch[1];
                img.alt = 'Image from comment';
                img.style.maxWidth = '100%';
                img.style.borderRadius = '8px';
                wrapper.appendChild(img);
            } else if (giphyMatch) {
                // Handle Giphy GIFs
                const gifId = giphyMatch[1];
                const img = document.createElement('img');
                img.src = `https://media.giphy.com/media/${gifId}/giphy.gif`;
                img.alt = 'GIF from comment';
                img.style.maxWidth = '100%';
                img.style.borderRadius = '8px';
                wrapper.appendChild(img);
            } else if (redditGifMatch) {
                // Handle Reddit native GIFs
                const gifId = redditGifMatch[1];
                const img = document.createElement('img');
                img.src = `https://www.redditstatic.com/desktop2x/img/gold/badges/award-silver-large.png`; // You'll need the actual Reddit gif URL format
                img.alt = 'Reddit GIF from comment';
                img.style.maxWidth = '100%';
                img.style.borderRadius = '8px';
                wrapper.appendChild(img);
            } else if (directGifMatch) {
                // Handle direct GIF URLs
                const img = document.createElement('img');
                img.src = directGifMatch[1];
                img.alt = 'GIF from comment';
                img.style.maxWidth = '100%';
                img.style.borderRadius = '8px';
                wrapper.appendChild(img);
            } else {
                // Parse markdown ONLY for non-image content
                decoded = parseMarkdown(decoded);
                // Handle text content
                const urlRegex = /(https?:\/\/[^\s<]+)/g;
                const lines = decoded.split('\n');
                lines.forEach(line => {
                    const lineEl = document.createElement('div');
                    if (line.trim().startsWith('>')) {
                        lineEl.className = 'quote';
                        lineEl.textContent = line.replace(/^>\s?/, '');
                    } else {
                        // Process and sanitize URLs
                        if (!line.includes('<a href=')) {
                            line = line.replace(urlRegex, url => {
                                // Block dangerous URLs
                                if (url.toLowerCase().startsWith('javascript:') ||
                                    url.toLowerCase().startsWith('data:')) {
                                    return url; // Just show text
                                }
                                return `<a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`;
                            });
                        }
                        lineEl.innerHTML = line;
                    }
                    wrapper.appendChild(lineEl);
                });
            }
            return wrapper;
        }

    </script>

    <script>
        fetch('words.json')
            .then(res => res.json())
            .then(words => {
                window.englishWords = words;
                setupSearchSuggestions('search-input', 'suggestions', window.englishWords);
            })
            .catch(err => {
                console.error("❌ Failed to load word list:", err);
            });
    </script>

    <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2/dist/fuse.min.js"></script>
    <script src="bookmarks.js"></script>

    <div class="hermes-context-menu" id="hermesContextMenu">
        <div class="hermes-context-menu-item" id="muteHermes">
            <span class="bell-unmute"></span>
            <span>Mute Hermes</span>
        </div>
        <div class="hermes-context-menu-item" id="toggleAnimations">
            <span class="checkmark">✓</span>
            <span>Animations</span>
        </div>
    </div>
</body>

</html>