<!DOCTYPE html>
<html lang="en">

<head>
<link rel="stylesheet" href="styles.css" />
<link rel="stylesheet" href="bookmarks.css">
<link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon-32x32.png">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta property="og:title" content="KarmaFinder - Reddit Search Engine">
    <meta name="description" content="Search Reddit like Google. Find exactly what you're looking for across any subreddit.">
    <meta name="keywords" content="reddit search, reddit finder, search reddit posts, reddit search engine, reddit viewer">
    <meta property="og:description" content="Reddit Search Engine. Find exactly what you're looking for on Reddit">
    <title>KarmaFinder - Better Reddit Search</title>
    
</head>

<body>

<script>
    
    try {
        if (localStorage.getItem('theme') === 'dark') {
            document.body.classList.add('dark-mode');
        }
    } catch (e) { }

    window.stripeCustomerId = "cus_ABC123";

</script>

    <a href="donopage.html" class="donate-btn floating-button">Support the Site</a>
    <div class="container">
        <header
            style="display: flex; justify-content: center; align-items: center; position: relative; padding: 1rem 0;">
            <div style="text-align: center;">
            <a href="karmafinder.html" class="link-container">
                <div class="logo">KarmaFinder</div>
                </a>
                <div class="tagline">Find exactly what you're looking for on Reddit üîé</div>
                <img src="../assets/hermes.png" alt="Hermes Detective Cat" class="hermes-cat">
            </div>
        </header>

        <button id="themeToggle" class="theme-toggle" aria-label="Toggle Dark Mode">
            <img id="themeIcon" alt="Toggle theme" />
        </button>

        <a href="?page=bookmarks" class="bookmark-link">
            <span class="bookmark-tiny"></span>
            Bookmarks
        </a>

        <div class="search-container">
          <div class="search-top-row">
            <div class="search-input-container">
                <svg class="search-icon" width="22" height="22" viewBox="0 0 24 24" fill="none">
                    <circle cx="10" cy="10" r="7" stroke="currentColor" stroke-width="2" fill="none" />
                    <path d="m15.8 15.8 4.2 4.2" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
                </svg>
                    <input type="text" id="search-input" class="search-input" placeholder="Search Reddit">
                    <div id="suggestions"></div>
                        <button id="search-button" class="search-button"></button>
                    </div>
                <img src="../assets/iconny thingy.png" alt="filter icon" id="filter-icon" />
                <button id="comfy-toggle" aria-label="Toggle Comfy Mode">
                    <img src="../assets/comfy-default.png" alt="Toggle comfy layout" />
                </button>
                <button id="compact-toggle" aria-label="Toggle Compact Mode">
                    <img src="../assets/compact-default.png" alt="Toggle compact layout" />
                </button>
            </div>

            <div class="advanced-options">
                <div class="option-group">
                    <label for="sort-select">Sort By</label>
                    <select id="sort-select">
                        <option value="hot">Hot</option>
                        <option value="top">Top</option>
                        <option value="new">New</option>
                        <option value="relevance">Relevance</option>
                    </select>
                </div>

                <div class="option-group">
                    <label for="time-select">Time Period</label>
                    <select id="time-select">
                        <option value="all">All Time</option>
                        <option value="year">Past Year</option>
                        <option value="month">Past Month</option>
                        <option value="week">Past Week</option>
                        <option value="day">Past 24 Hours</option>
                        <option value="hour">Past Hour</option>
                    </select>

                </div>

                <div class="option-group">
                    <label for="safesearch-select">SafeSearch</label>
                    <select id="safesearch-select">
                        <option value="on">On</option>
                        <option value="off">Off</option>
                    </select>
                </div>

                <div class="option-group subreddit-dropdown">
                    <label for="subreddit-input">Subreddit (optional)</label>
                    <input type="text" id="subreddit-input" placeholder="e.g., AskReddit">
                    <div id="subreddit-suggestions-container">
                        <div id="subreddit-suggestions" class="subreddit-suggestions"></div>
                    </div>
                    <div class="filter-chip-container" id="subreddit-chip-container">
                        <span class="chip-text"></span>
                        <span class="remove-chip">√ó</span>
                    </div>
                </div>

                <div class="option-group">
                    <label for="content-select">Content Type</label>
                    <select id="content-select">
                        <option value="all">All Content</option>
                        <option value="video">Video Posts Only</option>
                        <option value="image">Picture Posts Only</option>
                        <option value="text">Text Posts Only</option>
                    </select>
                </div>
            </div>
        </div>
        
        <div id="results" class="results-container">
            <!-- Results will be populated here -->
        </div>

        <div id="pagination" class="pagination">
            <!-- Pagination will be added here -->
        </div>
        <footer>
            <p>KarmaFinder is an independent search utility and is not affiliated with Reddit Inc.</p>
            <br>
            <a href="https://github.com/hawaiichair23/KarmaFinder" class="github-button" id="button" target="_blank" 
   rel="noopener noreferrer">
            <svg width="24" height="24" viewBox="0 0 16 16" fill="white" alt="Github">
                <path
                    d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z" />
            </svg>
                    Github</a>
                    <br>
                    <br>
            <p class="footie">Made by hawaiichair23</p>
        </footer>
    </div>

    <script>
        
        // Seven minutes. Seven minutes is all I can spare to play with you.
        const CACHE_DURATION_MS = 7 * 60 * 1000;
        
        // Configuration 
        const API_ENDPOINT = 'http://localhost:3000/reddit';

        const RESULTS_PER_PAGE = 10;

        const IMAGE_PROXY_BASE = location.hostname === 'localhost'
                ? 'http://localhost:3000'
                : 'https://karmafinder.onrender.com';

        let searchTimeout = null;

        let POPULAR_SUBREDDITS = [];

    function preloadBookmarks(stripeCustomerId, callback) {

        if (!stripeCustomerId) {
            console.log('No customer ID available, skipping bookmark preload');
            if (callback) callback();
            return;
        }
            fetch(`http://localhost:3000/api/bookmarks/${stripeCustomerId}?limit=1000`)
                .then(res => res.json())
                .then(data => {
                    const bookmarks = {};
                    data.bookmarks.forEach(post => {
                        bookmarks[post.reddit_post_id] = true;
                    });

                    sessionStorage.setItem('bookmarks', JSON.stringify(bookmarks));

                    // ‚úÖ Apply bookmarks to any currently rendered icons
                    document.querySelectorAll('.bookmark-icon').forEach(icon => {
                        const postId = icon.dataset.postId;
                        if (bookmarks[postId]) {
                            icon.classList.add('saved');
                        } else {
                            icon.classList.remove('saved');
                        }
                    });

                    if (callback) callback();
                })
                .catch(err => {
                    console.error('‚ùå Failed to preload bookmarks:', err);
                    if (callback) callback();
                });
        }

    // DOM Elements
    const searchInput = document.getElementById('search-input');
    const suggestionsDiv = document.getElementById('suggestions');
    const searchButton = document.getElementById('search-button');
    const sortSelect = document.getElementById('sort-select');
    const timeSelect = document.getElementById('time-select');
    const subredditInput = document.getElementById('subreddit-input');
    const contentSelect = document.getElementById('content-select');
    const resultsContainer = document.getElementById('results');
    const paginationContainer = document.getElementById('pagination');
    const subredditSuggestions = document.getElementById('subreddit-suggestions');
    const subredditChipContainer = document.getElementById('subreddit-chip-container');
    const dropdown = document.getElementById('subreddit-suggestions');

    // State
    const savedCommentCache = localStorage.getItem('commentCache');
    const commentCache = savedCommentCache ? JSON.parse(savedCommentCache) : {};

    window.cachedMediaByUrl = {};

    let navigationHistory = [];
    let activeQueryToken = 0;
    let cachedPostsById = {};
    let currentPageIndex = 0;
    let lastQuery = "";
    let currentAfter = null;
    let currentBefore = null;
    let isLoading = false;
    let currentFilters = {
        sort: 'hot',
        time: 'all',
        subreddit: '',
    };
    
    // Data for html injection
        if (window.preloadedSearchData && window.preloadedQuery !== undefined) { 
            console.log('üöÄ Using preloaded search data');

            // Set the search input
            searchInput.value = window.preloadedQuery;

            // Set the subreddit if one was preloaded
            if (window.preloadedSubreddit) {

                const subredditInput = document.getElementById('subreddit-input'); 
                if (subredditInput) {
                    subredditInput.value = window.preloadedSubreddit;
                }
                console.log('üéØ Set subreddit to:', window.preloadedSubreddit);
            }

            // Process the data the same way performSearch does
            const data = window.preloadedSearchData;
            currentAfter = data.data.after || null;
            currentBefore = data.data.before || null;
            const trimmedData = data.data.children.map(post => ({
                id: post.data.id,
                title: post.data.title,
                url: post.data.url,
                permalink: post.data.permalink,
                subreddit: post.data.subreddit,
                score: post.data.score,
                is_video: post.data.is_video,
                domain: post.data.domain,
                author: post.data.author,
                created_utc: post.data.created_utc,
                num_comments: post.data.num_comments,
                over_18: post.data.over_18,
                preview: post.data.preview,
                selftext: post.data.selftext,
                body: post.data.body,
                is_gallery: post.data.is_gallery,
                gallery_data: post.data.gallery_data,
                media_metadata: post.data.media_metadata,
                crosspost_parent_list: post.data.crosspost_parent_list || [],
                content_type: post.content_type,
                icon_url: null,
                locked: post.data.locked,
                stickied: post.data.stickied
            }));
            displayResults(trimmedData);
            preloadBookmarks(window.stripeCustomerId);
            updatePagination();

            // Clean up
            delete window.preloadedSearchData;
            delete window.preloadedQuery;
            delete window.preloadedSubreddit;
        }

    function loadPaginationState(fromPopState = false, direction = 'refresh') {
        const params = new URLSearchParams(window.location.search);
        const pageIndex = parseInt(params.get('page'), 10) || 0;
        const subreddit = params.get('sub') || '';
        const query = params.get('q') || '';
        const sort = params.get('sort') || 'hot';
        const time = params.get('time') || 'all';
        const contentType = params.get('type') || 'all';

        // Determine direction if not provided
        if (fromPopState && direction === 'refresh') {
            const oldPageIndex = currentPageIndex;
            direction = pageIndex > oldPageIndex ? 'forward' : pageIndex < oldPageIndex ? 'backward' : 'same';
        }

        currentPageIndex = pageIndex;
        currentFilters = { subreddit, query, sort, time, contentType };

        // RESTORE FROM SESSIONSTORAGE
        const savedAfter = sessionStorage.getItem('kf_current_after') || null;
        const savedHistory = JSON.parse(sessionStorage.getItem('kf_navigation_history') || '[]');
        currentAfter = savedAfter;
        currentBefore = null;
        navigationHistory = savedHistory;

        console.log('üîÑ Restored from sessionStorage - after:', currentAfter, 'history length:', navigationHistory.length);

        // üñºÔ∏è Update UI
        sortSelect.value = sort;
        timeSelect.value = time;
        contentSelect.value = contentType;
        searchInput.value = query;
        subredditInput.value = subreddit;
        if (subreddit) {
            selectSubreddit(subreddit);
        } else {
            subredditInput.value = '';
            subredditChipContainer.style.display = 'none';
        }

        console.log('üîÑ URL restored state:', currentFilters, 'Page:', currentPageIndex);

        // ‚úÖ Only rewrite the URL if NOT handling a popstate event
        if (!fromPopState) {
            const cleanParams = new URLSearchParams();
            if (currentPageIndex > 0) cleanParams.set('page', currentPageIndex);
            if (query) cleanParams.set('q', query);
            if (subreddit) cleanParams.set('sub', subreddit);
            if (sort !== 'hot') cleanParams.set('sort', sort);
            if (time !== 'all') cleanParams.set('time', time);
            if (contentType !== 'all') cleanParams.set('type', contentType);
            const newUrl = cleanParams.toString() ? '?' + cleanParams.toString() : window.location.pathname;
            window.history.replaceState({}, '', newUrl);
        }

        // Only perform search if called from popstate
        if (fromPopState) {
            let targetToken;
            if (direction === 'forward') {
                targetToken = navigationHistory[currentPageIndex]?.after || currentAfter;
                console.log("üîú Going FORWARD, using token:", targetToken);
            } else {
                targetToken = navigationHistory[currentPageIndex - 1]?.after;
                console.log("üîô Going BACKWARD, using token:", targetToken);
            }
            performSearch(targetToken, null, false, true);
        }

        // Return true if we successfully restored state
        return true;
    }

    function randomBlink() {
            const img = document.querySelector('.hermes-cat');

            // First blink
            img.src = '../assets/hermes-blink.png';
            setTimeout(() => img.src = '../assets/hermes.png', 150);

            // Random delay between blinks (400-3000ms)
            const delayBetween = Math.random() * 400 + 3000;

            setTimeout(() => {
                // Second blink
                img.src = '../assets/hermes-blink.png';
                setTimeout(() => img.src = '../assets/hermes.png', 150);
            }, delayBetween);

            // Random delay until next double blink (4-12 seconds)
            const nextBlink = Math.random() * 12000 + 4000;
            setTimeout(randomBlink, nextBlink);
        }

        // Start the blinking
        randomBlink();

    // Event Listeners
    searchButton.addEventListener('click', async () => {
            searchButton.style.backgroundImage = "url('../assets/search-pressed.png')";

            currentPageIndex = 0;

            // Clear the subreddit chip immediately when search is clicked
            currentFilters.subreddit = '';
            subredditChipContainer.style.display = 'none';
            

            if (currentFilters.sort === 'relevance' && (!searchInput.value || searchInput.value.trim() === '')) {
                showError("No search terms detected. üîé");
                return;
            }

            const subreddit = subredditInput.value.trim();

            if (subreddit && subreddit !== 'undefined' && subreddit !== 'null') {
                // üåê Check if the subreddit exists using about.json
                try {
                    const res = await fetch(`http://localhost:3000/reddit?url=https://www.reddit.com/r/${subreddit}/about.json`);
                    if (!res.ok) throw new showError("Couldn't find a valid subreddit. üîé");
                    const json = await res.json();

                    if (!json || !json.data || json.data.subreddit_type === 'private') {
                        showError("This subreddit is private.");
                        return;
                    }
                } catch (err) {
                    showError("Couldn't find a valid subreddit. üîé");
                    return;
                }
            }
            
            // Store the search suggestion
        const searchTerm = searchInput.value.trim();
        if (searchTerm) {
            try {
                await fetch('http://localhost:3000/api/suggestions/store', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        query: searchTerm,
                        subreddit: (subreddit && subreddit !== 'undefined' && subreddit !== 'null') ? subreddit : null
                    })
                });
            } catch (err) {
                console.error("Failed to store suggestion:", err);
            }
        }

        // ‚úÖ Passed all checks
        performSearch();
        setTimeout(() => {
            searchButton.style.backgroundImage = "url('../assets/search-default.png')";
        }, 500);
    });

    [subredditInput, searchInput].forEach(input => {
            input.addEventListener('keydown', async (e) => {
                if (e.key === 'Tab') {
                    let dropdown, suggestions, currentHighlighted;

                    // Check suggestions dropdown first
                    dropdown = document.querySelector('#suggestions');
                    if (dropdown && dropdown.style.display !== 'none') {
                        suggestions = dropdown.querySelectorAll('div');
                        currentHighlighted = dropdown.querySelector('.highlighted');
                    } else {
                        // Check subreddit dropdown
                        dropdown = document.querySelector('.subreddit-suggestions');
                        if (dropdown && dropdown.classList.contains('active')) {
                            suggestions = dropdown.querySelectorAll('.subreddit-suggestion');
                            currentHighlighted = dropdown.querySelector('.highlighted');
                        }
                    }

                    if (suggestions && suggestions.length > 0) {
                        e.preventDefault();

                        // Remove current highlight
                        if (currentHighlighted) {
                            currentHighlighted.classList.remove('highlighted');
                        }

                        // Find next item to highlight
                        let nextIndex = 0;
                        if (currentHighlighted) {
                            const currentIndex = Array.from(suggestions).indexOf(currentHighlighted);
                            nextIndex = (currentIndex + 1) % suggestions.length;
                        }

                        // Highlight next item
                        suggestions[nextIndex].classList.add('highlighted');
                        return;
                    }
                }

                if (e.key === 'Enter') {
                    // Check both dropdowns
                    let highlighted = document.querySelector('#suggestions .highlighted') ||
                        document.querySelector('.subreddit-suggestions .highlighted');

                    if (highlighted) {
                        e.preventDefault();
                        highlighted.click();
                        highlighted.classList.remove('highlighted');
                        return
                    }
    
                // Reset state
                currentFilters.subreddit = '';
                subredditChipContainer.style.display = 'none';
                currentPageIndex = 0;

                const searchTerm = searchInput.value.trim();
                const subreddit = subredditInput.value?.trim();

                // Block empty search terms if relevance is selected
                if (currentFilters.sort === 'relevance' && !searchTerm) {
                    showError("No search terms detected. üîé");
                    return;
                }

                // Only validate subreddit if one was entered
                if (subreddit && subreddit !== 'undefined' && subreddit !== 'null') {
                    try {
                        const res = await fetch(`http://localhost:3000/reddit?url=${encodeURIComponent(`https://www.reddit.com/r/${subreddit}/about.json`)}`);
                        if (!res.ok) {
                            showError("Couldn't find a valid subreddit. üîé");
                            return;
                        }

                        const json = await res.json();

                        if (!json || !json.data || json.data.subreddit_type === 'private') {
                            showError("This subreddit is private.");
                            return;
                        }

                    } catch (err) {
                        console.error("‚ùå Subreddit validation error:", err.message);
                        showError("Couldn't find a valid subreddit. üîé");
                        return;
                    }
                }
                // Store the search suggestion only when triggered from searchInput
                if (searchTerm) {
                    try {
                        await fetch('http://localhost:3000/api/suggestions/store', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                query: searchTerm,
                                subreddit: (subreddit && subreddit !== 'undefined' && subreddit !== 'null') ? subreddit : null
                            })
                        });
                    } catch (err) {
                        console.error("Failed to store suggestion:", err);
                    }
                }
                performSearch();
                }

                // Reset highlight when typing
                if (e.key.length === 1 || e.key === 'Backspace') {
                    highlightedIndex = -1;
                    const dropdown = document.querySelector('.suggestions-dropdown');
                    if (dropdown) {
                        const suggestions = dropdown.querySelectorAll('.suggestion-item');
                        suggestions.forEach(item => item.classList.remove('highlighted'));
                    }
                }
            
            });
    });

    // Add popular subs on click
        document.querySelector('#subreddit-input').addEventListener('focus', (e) => {
            // Only show popular subs if input is empty
            if (!e.target.value.trim()) {
                const popularSubs = [
                    { name: 'AskReddit', icon: null },
                    { name: 'pics', icon: null },
                    { name: 'mildlyinteresting', icon: null },
                    { name: 'explainlikeimfive', icon: null },
                    { name: 'politics', icon: null },
                    { name: 'MadeMeSmile', icon: null },
                    { name: 'funny', icon: null }
                ];
                populateSubredditSuggestions(popularSubs);
                document.querySelector('.subreddit-suggestions').classList.add('active');
            }
        });

        sortSelect.addEventListener('change', () => {
            currentFilters.sort = sortSelect.value;

            // Only perform search if NOT relevance
            if (sortSelect.value !== 'relevance') {

                // Reset pagination state
                currentIndex = 0;
                performSearch();
            
            }
        });

        timeSelect.addEventListener('change', () => {
            currentFilters.time = timeSelect.value;

                // Reset pagination state
                currentIndex = 0;
            performSearch();
        });

        document.getElementById('safesearch-select').addEventListener('change', function () {
            const enabled = this.value === 'on';
            document.body.classList.toggle('safe-search-enabled', enabled);
            console.log(`SafeSearch is now ${enabled ? 'ON' : 'OFF'}`);
        });

        contentSelect.addEventListener('change', () => {
            currentFilters.contentType = contentSelect.value;
            // Reset pagination state
            currentIndex = 0;
            performSearch();
        });

        const comfyToggle = document.getElementById('comfy-toggle');
        const compactToggle = document.getElementById('compact-toggle');

        let isComfyActive = false;
        let isCompactActive = true;
        let hasClickedOnce = false;

        comfyToggle.querySelector('img').src = '../assets/comfy-default.png';
        compactToggle.querySelector('img').src = '../assets/compact-default.png';

            comfyToggle.addEventListener('click', () => {
                    if (isComfyActive) {
                        if (hasClickedOnce && !isCompactActive) return; 
                        isComfyActive = false;
                        comfyToggle.querySelector('img').src = '../assets/comfy-default.png';
                    } else {
                        isComfyActive = true;
                        comfyToggle.querySelector('img').src = '../assets/comfy-pressed.png';

                        isCompactActive = false;
                        compactToggle.querySelector('img').src = '../assets/compact-default.png';
                    }

                    hasClickedOnce = true;
                    document.body.classList.add('hasClickedOnce');
                
                    if (isComfyActive) {
                    document.body.classList.add('comfy-mode');
                } else {
                    document.body.classList.remove('comfy-mode');
                }

                });

           compactToggle.addEventListener('click', () => {
                hasClickedOnce = true;
                document.body.classList.add('hasClickedOnce');

                    compactToggle.querySelector('img').src = '../assets/compact-pressed.png';
                    document.body.classList.remove('comfy-mode');
                    isComfyActive = false;
                    comfyToggle.querySelector('img').src = '../assets/comfy-default.png';

            });

        document.addEventListener('click', function (event) {
                const suggestionsDiv = document.getElementById('suggestions');
                const input = document.getElementById('search-input');

                // If the click target is NOT the input or a suggestion
                if (!suggestionsDiv.contains(event.target) && event.target !== input) {
                    suggestionsDiv.innerHTML = '';
                    suggestionsDiv.style.display = 'none';
                }
            });

        document.querySelector('#search-input').addEventListener('focus', function () {
            if (this.value === '') {

                fetch('http://localhost:3000/api/top-searches')
                    .then(res => res.json())
                    .then(data => {
                        const suggestionsDiv = document.querySelector('#suggestions');
                        displaySuggestions(data, suggestionsDiv);
                    });
            }
        });

        document.querySelector('.search-input-container').addEventListener('click', function (e) {
                // Only focus if they didn't click the input itself, search button, or filter icon
                if (!e.target.matches('.search-input') &&
                    !e.target.matches('.search-button') &&
                    !e.target.matches('#filter-icon') &&
                    !e.target.closest('.search-button')) {
                    document.querySelector('#search-input').focus();
                }
            });

        // Grow comment images
        document.addEventListener('click', function (e) {
                if (e.target.matches('.comment-body img')) {
                    let currentWidth = e.target.offsetWidth;
                    e.target.style.transition = 'width 0.07s ease';

                    if (e.target.style.width) {
                        e.target.style.width = '';
                    } else {
                        e.target.style.width = (currentWidth * 1.7) + 'px';
                    }
                }
            });

        // Remove subreddit filter when clicking X
        subredditChipContainer.querySelector('.remove-chip').addEventListener('click', () => {
            currentFilters.subreddit = '';
            subredditChipContainer.style.display = 'none';
        });

        // Handle suggestion selection
        subredditSuggestions.addEventListener('click', (e) => {
            const suggestion = e.target.closest('.subreddit-suggestion');
            if (suggestion) {
                const subName = suggestion.getAttribute('data-name');
                selectSubreddit(subName);
            }
        });     

        // Handle typing in subreddit input
        subredditInput.addEventListener('input', () => {
            const query = subredditInput.value.toLowerCase().trim();
            lastQuery = query;

            // Show dropdown immediately with a loading spinner
            if (query.length > 0) {
                if (!subredditSuggestions.querySelector('.custom-spinner-wrapper')) {
                    subredditSuggestions.innerHTML = '';
                    subredditSuggestions.appendChild(createCanvasSpinner());
                }

                subredditSuggestions.classList.add('active');
            } else {
                subredditSuggestions.classList.remove('active');
            }

            // Debounce Reddit API call
            if (searchTimeout) clearTimeout(searchTimeout);

            searchTimeout = setTimeout(() => {
                handleSubredditSuggestions(query);
            }, 200); // delay debounce here
        });

        // Cubic-bezier easing 
        function cubicBezier(p0, p1, p2, p3) {
            return function (t) {
                const cx = 3 * (p1 - p0);
                const bx = 3 * (p2 - p1) - cx;
                const ax = 1 - cx - bx;

                const cy = 3 * (p1 - p0);
                const by = 3 * (p2 - p1) - cy;
                const ay = 1 - cy - by;

                let x = t, t2 = t;
                for (let i = 0; i < 5; i++) {
                    const f = ax * t2 * t2 * t2 + bx * t2 * t2 + cx * t2 - x;
                    const df = 3 * ax * t2 * t2 + 2 * bx * t2 + cx;
                    t2 = t2 - f / df;
                    t2 = Math.max(0, Math.min(t2, 1));
                }

                return ay * t2 * t2 * t2 + by * t2 * t2 + cy * t2;
            };
        }

        // Begin animation
        function startSpinnerAnimation(ctx) {
            const easeCustom = cubicBezier(0.1, 0.83, 0.37, 1);
            const cycleDuration = 700;
            let startTime = null;

            function animate(timestamp) {
                if (!startTime) startTime = timestamp;

                const elapsed = timestamp - startTime;
                const t = (elapsed % cycleDuration) / cycleDuration;
                const ramp = Math.pow(t, 0.8);
                const eased = easeCustom(ramp);

                const angle = (eased * 6.28 + 7.8) % 6.28;
                const shrinkEase = easeCustom(t);
                const sinePhase = Math.sin(shrinkEase * Math.PI);
                const shrinkPhase = easeCustom(sinePhase);
                const shrink = 0.5 + 0.5 * shrinkPhase;
                const arcLength = Math.PI * 0.7 * shrink;

                ctx.clearRect(0, 0, 50, 50);
                ctx.beginPath();
                const arcStart = angle - arcLength;
                ctx.arc(25, 25, 18, arcStart, angle);
                ctx.strokeStyle = "#C1C0C1";
                ctx.lineWidth = 4;
                ctx.stroke();

                requestAnimationFrame(animate);
            }

            requestAnimationFrame(animate);
        }

        // SPINNY
        function createCanvasSpinner() {
            const wrapper = document.createElement('div');
            wrapper.className = 'custom-spinner-wrapper';

            const canvas = document.createElement('canvas');
            canvas.width = 50;
            canvas.height = 50;
            canvas.id = 'main-spinner-placeholder';
            wrapper.appendChild(canvas);

            const ctx = canvas.getContext('2d');
            startSpinnerAnimation(ctx); 

            return wrapper;
        }

        document.getElementById('content-select').addEventListener('change', function () {
                currentFilters.contentType = this.value;
                updateURL();
            });

        async function handleSubredditSuggestions(query) {
            // Don't search for empty queries
            if (!query || query.trim() === '') {
                subredditSuggestions.innerHTML = '';
                return;
            }
                // Strip r/ prefix if present
                const cleanQuery = query.replace(/^r\//, '');
                
                const queryToken = ++activeQueryToken;
                console.log(`üîé Fetching subreddit suggestions for: "${cleanQuery}"`);
                let matches = [];
                try {
                    const res = await fetch(`http://localhost:3000/reddit?url=https://www.reddit.com/subreddits/search.json?q=${encodeURIComponent(query)}`);
                    const data = await res.json();
                    if (data?.data?.children) {
                        const filtered = [];
                        for (const child of data.data.children) {
                            if (
                                child?.data?.display_name &&
                                child.data.display_name.toLowerCase().startsWith(cleanQuery.toLowerCase())
                            ) {
                                filtered.push(child.data.display_name);
                                if (filtered.length === 7) break; // ‚úÖ TRUE early exit
                            }
                        }

                        // Show dropdown immediately without icons
                        matches = filtered.map(name => ({ name, icon: null }));
                    }

                    if (queryToken !== activeQueryToken) {
                        return; 
                    }

                    populateSubredditSuggestions(matches);

                } catch (err) {
                    console.error("‚ùå Subreddit suggestion fetch failed:", err);
                }


                const merged = [...matches].filter(
                    (sub, index, self) => index === self.findIndex(s => s.name === sub.name)
                );

                if (query !== lastQuery) return;
                subredditSuggestions.innerHTML = '';
                if (merged.length === 0) {
                    subredditSuggestions.innerHTML = '<div class="subreddit-suggestion-err">No subreddits found</div>';
                    return;
                }
                renderSubredditSuggestions(merged);
            }

        function populateSubredditSuggestions(subreddits) {
        
            // Sort subreddits by relevance to the search query
            const query = subredditInput.value.toLowerCase().trim();
            if (query.length > 0) {
                subreddits.sort((a, b) => {
                    const aName = a.name.toLowerCase();
                    const bName = b.name.toLowerCase();

                    // Exact matches first
                    if (aName === query && bName !== query) return -1;
                    if (bName === query && aName !== query) return 1;

                    // Then starts with matches
                    if (aName.startsWith(query) && !bName.startsWith(query)) return -1;
                    if (bName.startsWith(query) && !aName.startsWith(query)) return 1;

                    // Then contains matches (already handled by filtering)
                    // Finally alphabetical
                    return aName.localeCompare(bName);
                });
            }

            // If there are results from filtering, add them
            if (subreddits.length > 0) {

                // Wait for all icon fetches to complete
                Promise.all(subreddits.map(sub => Promise.resolve(sub))).then(() => {
                    subredditSuggestions.innerHTML = '';
                    subreddits.forEach(sub => {

                        // Skip if no name
                        if (!sub.name) {
                            console.warn('Skipping subreddit with undefined name:', sub);
                            return;
                        }

                        const suggestion = document.createElement('div');
                        suggestion.className = 'subreddit-suggestion';
                        suggestion.setAttribute('data-name', sub.name);
                        const iconEl = document.createElement('div');
                        iconEl.className = 'subreddit-icon';

                        if (sub.icon && sub.icon.startsWith('http')) {
                            const img = document.createElement('img');
                            img.alt = sub.name;
                            img.src = sub.icon;
                            img.onerror = () => {
                                console.warn(`üîª Broken image for: ${sub.name}, using fallback`);
                                img.remove();
                                const fallback = document.createElement('span');
                                fallback.textContent = sub.name.charAt(0).toUpperCase();
                                iconEl.appendChild(fallback);
                            };
                            iconEl.appendChild(img);
                            // Force a repaint
                            iconEl.offsetHeight;
                        } else {
                            // Fallback if icon is missing or invalid
                            iconEl.textContent = sub.name.charAt(0).toUpperCase();
                        }

                        suggestion.appendChild(iconEl);
                        suggestion.appendChild(document.createTextNode(sub.name));
                        subredditSuggestions.appendChild(suggestion);

                    if (sub.name) {
                    console.log('Fetching icon for:', sub.name, typeof sub.name);
                        // Fetch icon async and replace when it loads
                        getSubredditIcon(sub.name).then(iconUrl => {
                            if (iconUrl && iconUrl.startsWith('http')) {
                                const img = document.createElement('img');
                                img.alt = sub.name;
                                img.src = iconUrl;
                                img.onload = () => {
                                    iconEl.textContent = ''; // Clear the letter
                                    iconEl.appendChild(img);
                                    iconEl.classList.add('icon-loaded');
                                };
                                img.onerror = () => {
                                    console.warn(`üîª Broken image for: ${sub.name}, keeping fallback`);
                                    // Keep the letter fallback
                                };
                            }
                        }).catch(err => {
                            console.error("‚ùå Error fetching icon:", err);
                            // Keep the letter fallback if fetch fails
                        });
                    }
                });
                    subredditSuggestions.setAttribute('data-has-results', 'true');
                })
                    .catch(err => {
                        console.error("‚ùå Error rendering suggestions:", err);
                        subredditSuggestions.innerHTML = '<div class="subreddit-suggestion-err">Error loading suggestions</div>';
                    });
                }
            }


    function getCurrentFiltersFromUI() {
        const query = searchInput.value.trim();
        const subredditTyped = document.getElementById('subreddit-input').value.trim();
        const chipVisible = subredditChipContainer.style.display === 'flex';
        const subreddit = chipVisible
            ? subredditChipContainer.querySelector('.chip-text').textContent.replace('r/', '')
            : subredditTyped;
        return {
            query,
            time: document.getElementById('time-select').value,
            sort: document.getElementById('sort-select').value,
            contentType: document.getElementById('content-select').value,  
            subreddit
        };
    }

    function setupSearchSuggestions(inputId, suggestionsId, dictionary) {
            let timeout;

            const input = document.getElementById(inputId);
            const suggestionsDiv = document.getElementById(suggestionsId);

            input.addEventListener('input', function (e) {
                const query = e.target.value.trim();
                clearTimeout(timeout);

                timeout = setTimeout(() => {
                    getSmartSuggestions(query, suggestionsDiv, dictionary);
                }, 300);
            });
        }

    async function getSmartSuggestions(query, suggestionsDiv, dictionary) {
            const trimmedQuery = query.trim();

            // If empty, show top searches instead
            if (!trimmedQuery) {
                const response = await fetch('http://localhost:3000/api/top-searches');
                const data = await response.json();
                displaySuggestions(data, suggestionsDiv);
                return;
            }

            const words = trimmedQuery.split(' ');
            const lastWord = words[words.length - 1];
            const fuse = new Fuse(dictionary, { threshold: 0.4 });

            // Get stored suggestions from database first
            let storedSuggestions = [];
            try {
                const subreddit = subredditInput.value?.trim() || '';
                const url = `http://localhost:3000/api/suggestions?q=${encodeURIComponent(trimmedQuery)}`;
                const response = await fetch(url);
                const data = await response.json();
                storedSuggestions = data.map(item => ({
                    query: item.query,
                    subreddit: item.subreddit, 
                    isStored: true
                }));
            } catch (error) {
                console.error("‚ùå Stored suggestions error:", error);
            }

            // Calculate remaining slots for pattern suggestions
            const remainingSlots = Math.max(0, 7 - storedSuggestions.length);
            let patternSuggestions = [];

            if (remainingSlots > 0) {
                const isElonMode = words.length === 1 && dictionary.includes(trimmedQuery.toLowerCase());
                if (isElonMode) {
                    console.log("ü§° ELON MODE");
                    try {
                        const apiUrl = `https://api.datamuse.com/words?rel_trg=${encodeURIComponent(trimmedQuery)}&max=${remainingSlots}`;
                        const response = await fetch(apiUrl);
                        const data = await response.json();
                        const apiWords = data.map(item => `${trimmedQuery} ${item.word}`);
                        patternSuggestions = [trimmedQuery, ...apiWords].slice(0, remainingSlots);
                    } catch (error) {
                        console.error("‚ùå Datamuse error:", error);
                        patternSuggestions = [trimmedQuery];
                    }
                } else {
                    console.log("üêî CHICKEN MODE");
                    const results = fuse.search(lastWord).slice(0, remainingSlots - 1);
                    const fullSuggestions = results.map(result => {
                        const newWords = [...words];
                        newWords[newWords.length - 1] = result.item;
                        return newWords.join(' ');
                    });
                    patternSuggestions = [trimmedQuery, ...fullSuggestions].slice(0, remainingSlots);
                }
            }

            patternSuggestions = patternSuggestions.filter(suggestion =>
                suggestion.toLowerCase() !== trimmedQuery.toLowerCase()
            );

            // Combine: stored suggestions FIRST, then pattern suggestions
            const allSuggestions = [...storedSuggestions, ...patternSuggestions];
            displaySuggestions(allSuggestions, suggestionsDiv);
        }

    function isIncompleteWord(word, dictionary) {
            return !dictionary.includes(word.toLowerCase());
        }

    function correctLastWord(query, dictionary) {
            const words = query.trim().split(' ');
            const lastWord = words[words.length - 1];

            const fuse = new Fuse(dictionary, {
                threshold: 0.4,
                includeScore: true,
            });

            const results = fuse.search(lastWord);

            if (results.length > 0 && results[0].score < 0.4) {
                words[words.length - 1] = results[0].item; // replace with best match
                return words.join(' ');
            }

            return query; // leave unchanged if no good match
        }

    function displaySuggestions(suggestions, suggestionsDiv) {
        const suggestionsHtml = suggestions.map(suggestion => {
            const word = typeof suggestion === 'string' ? suggestion : suggestion.query;
            const suggestionSubreddit = typeof suggestion === 'object' ? suggestion.subreddit : null;
            
            const iconContent = suggestionSubreddit ? 
                `<span class="suggestion-icon subreddit-icon">${suggestionSubreddit.charAt(0).toUpperCase()}</span>` :
                '<img src="../assets/search-favicon.png" class="suggestion-favicon" alt="Search">';
            
            return `<div onclick="selectSuggestion('${word}', 'search-input', 'suggestions', '${suggestionSubreddit || ''}')" data-subreddit="${suggestionSubreddit || ''}" class="suggestion-item">
                ${iconContent}
                ${word}
            </div>`;
        }).join('');

            suggestionsDiv.innerHTML = suggestionsHtml;
            suggestionsDiv.style.display = 'block';

            // Add real icons for suggestions that have subreddit data
            const suggestionElements = suggestionsDiv.querySelectorAll('[data-subreddit]');
            suggestionElements.forEach(element => {
                const subredditName = element.getAttribute('data-subreddit');
                if (subredditName) {
                    addIconToSuggestion(element, subredditName);
                }
            });
        }

    async function addIconToSuggestion(suggestionElement, subreddit) {
            if (!subreddit) return;

            suggestionElement.querySelector('.suggestion-favicon')?.remove();
                
            const iconContainer = suggestionElement.querySelector('.suggestion-icon');

            // Start with letter fallback
            iconContainer.textContent = subreddit.charAt(0).toUpperCase();

            const storageKey = `subreddit_icon_${subreddit}`;
            const cachedIcon = sessionStorage.getItem(storageKey);

            // Check sessionStorage first
            if (cachedIcon && cachedIcon !== 'null' && cachedIcon !== '/api/placeholder/20/20') {
                const img = document.createElement('img');
                img.src = cachedIcon;
                img.alt = `Icon for r/${subreddit}`;
                img.className = 'subreddit-icon-img';
                iconContainer.textContent = '';
                iconContainer.appendChild(img);
                setTimeout(() => img.classList.add('fade-in'), 10);
                iconContainer.classList.add('icon-loaded');
            } else if (!cachedIcon || cachedIcon === 'null') {
                // Fetch from API
                getSubredditIcon(subreddit).then(iconUrl => {
                    if (iconUrl && iconUrl !== '/api/placeholder/20/20') {
                        const img = document.createElement('img');
                        img.src = iconUrl;
                        img.alt = `Icon for r/${subreddit}`;
                        img.className = 'subreddit-icon-img';
                        iconContainer.textContent = '';
                        iconContainer.appendChild(img);
                        setTimeout(() => img.classList.add('fade-in'), 10);
                        iconContainer.classList.add('icon-loaded');
                        sessionStorage.setItem(storageKey, iconUrl);
                    }
                });
        }
    }

    function selectSuggestion(word, inputId, suggestionsId, subreddit = null) {
            document.getElementById(inputId).value = word;
            document.getElementById(suggestionsId).innerHTML = '';

            // If this suggestion has a subreddit, auto-select it
            if (subreddit) {
                selectSubreddit(subreddit);
            }

            sortSelect.value = 'relevance';
            currentFilters.sort = 'relevance';

            // Store/increment the suggestion
            if (word) {
                try {
                    fetch('http://localhost:3000/api/suggestions/store', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            query: word,
                            subreddit: (subreddit && subreddit !== 'undefined' && subreddit !== 'null') ? subreddit : null
                        })
                    });
                } catch (err) {
                    console.error("Failed to store suggestion:", err);
                }
            }

            // Reset page index and history for new search
            currentPageIndex = 0;

            // Perform the search
            performSearch();
        }

    function selectSubreddit(subName) {
        if (!subName || subName.toLowerCase() === 'all') {
            subredditChipContainer.style.display = 'none';
            
            return; // ‚õî don't show chip for default
        }

        subredditChipContainer.style.display = 'flex';
        subredditChipContainer.querySelector('.chip-text').textContent = 'r/' + subName;
        subredditInput.value = '';
        subredditSuggestions.classList.remove('active');
    }

    function buildCacheKey(baseToken, filters) {
        const encode = str => encodeURIComponent(str || '');

        const query = encode(filters.query);
        const subreddit = encode((filters.subreddit || 'all').toLowerCase());
        const sort = encode(filters.sort || 'hot');
        const time = encode(filters.time || 'all');

        return `${baseToken}__${subreddit}__${sort}__${query}__${time}`;
    }

    function needsProgressiveFiltering(filters) {
        console.log('üîç Checking filters for progressive filtering:', filters);

        // Progressive filtering needed for:
        // 1. "new" or "hot" sort with time filtering (not "all" time)
        // 2. "new" sort with content filtering (not "all" content)
        if ((filters.sort === 'new' || filters.sort === 'hot') && filters.time !== 'all') {
            console.log('üîÑ Progressive filtering needed: new/hot sort + time filtering');
            return true;
        }

        if (filters.sort === 'new' && filters.contentType !== 'all') {
            console.log('üîÑ Progressive filtering needed: new sort + content filtering');
            return true;
        }

        console.log('‚úÖ No progressive filtering needed');
        return false;
    }

    async function performProgressiveSearch(after = null, before = null, navigateBack = false, isInitialLoad = false) {
        console.log('üîÑ performProgressiveSearch() called with:', { after, before, navigateBack, isInitialLoad });

        const query = currentFilters.query?.trim() || '';
        const subreddit = currentFilters.subreddit || '';
        const sort = currentFilters.sort;
        const time = currentFilters.time;
        const contentType = currentFilters.contentType;
        const limit = 10;
        const MAX_FETCHES = 5;

        let fetchCount = 0;
        let allFilteredPosts = [];
        let currentAfterToken = (currentPageIndex === 0) ? null : (after || currentAfter);

        async function fetchBatch() {
            // Build Reddit URL (same logic as performSearch)
            let finalUrl = '';
            const isQuerying = query.length > 0;
            const encodedQuery = encodeURIComponent(query);

            if (isQuerying) {
                finalUrl = `https://www.reddit.com${subreddit ? `/r/${subreddit}` : ''}/search.json?q=${encodedQuery}&sort=${sort}&restrict_sr=1&limit=${limit}&t=${time}`;
            } else if (subreddit) {
                finalUrl = `https://www.reddit.com/r/${subreddit}/${sort}.json?limit=${limit}&t=${time}`;
            } else {
                finalUrl = `https://www.reddit.com/r/all/${sort}.json?limit=${limit}&t=${time}`;
            }

            if (currentAfterToken) finalUrl += `&after=${currentAfterToken}`;

            console.log('üåê Fetching batch from:', finalUrl);

            const response = await fetch(`http://localhost:3000/reddit?url=${encodeURIComponent(finalUrl)}`);
            const data = await response.json();
            console.log('üîç Raw response data:', data);
            return data;
        }

        // Progressive fetch loop
        while (allFilteredPosts.length < 10 && fetchCount < MAX_FETCHES) {
            fetchCount++;
            console.log(`üîÑ Fetch attempt ${fetchCount}/${MAX_FETCHES}`);
            try {
                const batchData = await fetchBatch();

                if (!batchData.data.children || batchData.data.children.length === 0) {
                    console.log('üõë No more posts available');
                    break;
                }

                // Trim the data (same as performSearch)
                const trimmedData = batchData.data.children.map(post => ({
                    id: post.data.id,
                    title: post.data.title,
                    url: post.data.url,
                    permalink: post.data.permalink,
                    subreddit: post.data.subreddit,
                    score: post.data.score,
                    is_video: post.data.is_video,
                    domain: post.data.domain,
                    author: post.data.author,
                    created_utc: post.data.created_utc,
                    num_comments: post.data.num_comments,
                    over_18: post.data.over_18,
                    preview: post.data.preview,
                    selftext: post.data.selftext,
                    body: post.data.body,
                    is_gallery: post.data.is_gallery,
                    gallery_data: post.data.gallery_data,
                    media_metadata: post.data.media_metadata,
                    crosspost_parent_list: post.data.crosspost_parent_list || [],
                    icon_url: null,
                    locked: post.data.locked,
                    stickied: post.data.stickied,
                    content_type: post.content_type
                }));

                // Apply filters 
                let filteredBatch = filterPostsByTime(trimmedData, time);

                // Early termination: if we got raw posts but some did not pass time filter, stop
                if (trimmedData.length > 0 && filteredBatch.length === 0 && time !== 'all') {
                    console.log('üõë Early termination: got posts but none within time range, stopping');
                    break;
                }

                console.log(`üì¶ Batch: ${trimmedData.length} raw posts ‚Üí ${filteredBatch.length} filtered posts`);

                // Add to our collection
                allFilteredPosts.push(...filteredBatch);

                console.log(`üéØ Total filtered posts so far: ${allFilteredPosts.length}`);

                currentAfterToken = batchData.data.after;
                if (!currentAfterToken) {
                    console.log('üõë Reached end of Reddit feed');
                    break;
                }

            } catch (error) {
                console.error('‚ùå Error in progressive fetch:', error);
                break;
            }
        }

        console.log('üéØ Progressive search complete, found:', allFilteredPosts.length, 'posts');

        // Take only the first 10 results (in case we got a few extra)
        const finalResults = allFilteredPosts.slice(0, 10);

        // Save to navigation history
        navigationHistory[currentPageIndex] = {
            query: currentFilters.query,
            subreddit: currentFilters.subreddit,
            after: currentAfterToken, 
            before: null,          
            nextBefore: null,
            results: finalResults
        };

        // Display the results
        displayResults(finalResults);
        preloadBookmarks(window.stripeCustomerId);
        updatePagination();
        updateURL();
        window.scrollTo(0, 0);

        console.log('‚úÖ Progressive search displayed:', finalResults.length, 'posts');
    }












    function performSearch(after = null, before = null, navigateBack = false, isInitialLoad = false) {

            if (window.location.search.includes('page=bookmarks')) {
                const newUrl = window.location.pathname;
                window.history.replaceState({}, '', newUrl);
                const tabsSection = document.querySelector('.tabs-section');
                if (tabsSection) tabsSection.remove();
            }

            console.log('üü¢ performSearch() called with:', { after, before, navigateBack, isInitialLoad });
            console.log('üîç Current Index:', currentPageIndex);

            // Navigation back logic
            if (navigateBack) {
            const targetPage = navigationHistory[currentPageIndex];

            // For going back, we need the after token from the NEXT page
            const nextPageIndex = currentPageIndex + 1;
            const nextPage = navigationHistory[currentPageIndex];

            currentAfter = nextPage?.after || null;
            currentBefore = targetPage?.before || null;

            // Then check for cached results
            if (targetPage?.results?.length &&
                targetPage.query === currentFilters.query &&
                targetPage.subreddit === currentFilters.subreddit) {

                console.log("‚¨ÖÔ∏è Using cached results for back navigation");
                displayResults(targetPage.results);
                preloadBookmarks(window.stripeCustomerId);
                updatePagination();
                window.scrollTo(0, 0);
                return;
                }
            }

            // On initial load, filters should already be set externally
            if (!isInitialLoad) {
            currentFilters = getCurrentFiltersFromUI();
            }

            // Move the else logic here and change it to handle non-navigate-back cases
            if (!navigateBack) {
                currentAfter = after || currentAfter;
                currentBefore = before || currentBefore;
            }

            const query = currentFilters.query?.trim() || '';
            const subreddit = currentFilters.subreddit || '';
            const sort = currentFilters.sort;
            const time = currentFilters.time;
            const contentType = currentFilters.contentType;
            const limit = 10;

            const tokenForThisPage = buildCacheKey(currentPageIndex === 0 ? 'page_1' : currentAfter, currentFilters);
            console.log('üè∑Ô∏è Token for this page:', tokenForThisPage);
            console.log('üè∑Ô∏è Building token with currentAfter:', currentAfter);
            console.log('üè∑Ô∏è currentPageIndex:', currentPageIndex);
       
            // Construct Reddit API URL
            let finalUrl = '';
            const isQuerying = query.length > 0;
            const encodedQuery = encodeURIComponent(query);

            if (isQuerying) {
                finalUrl = `https://www.reddit.com${subreddit ? `/r/${subreddit}` : ''}/search.json?q=${encodedQuery}&sort=${sort}&restrict_sr=1&limit=${limit}&t=${time}`;
            } else if (subreddit) {
                finalUrl = `https://www.reddit.com/r/${subreddit}/${sort}.json?limit=${limit}&t=${time}`;
            } else {
                finalUrl = `https://www.reddit.com/r/all/${sort}.json?limit=${limit}&t=${time}`;
            }

            if (after) finalUrl += `&after=${after}`;
            if (before) finalUrl += `&before=${before}`;

            console.log('üîç Filters applied:', currentFilters);
            console.log('üîó Final Reddit URL:', finalUrl);

            // Prepare backend query params
            const params = new URLSearchParams();
            if (subreddit && subreddit !== 'all') params.append('subreddit', subreddit);
            if (query) params.append('query', query);
            if (time !== 'all') params.append('time', time);
            if (sort) params.append('sort', sort);
            if (after) params.append('after', after);
            params.append('limit', limit.toString());

            showLoading();

            // Check if progressive filtering is needed
            if (needsProgressiveFiltering(currentFilters)) {
                console.log('üîÑ Progressive filtering needed, calling performProgressiveSearch()');
                performProgressiveSearch(after, before, navigateBack, isInitialLoad);
                return;
            }

            // Fetch from database
            fetch(`http://localhost:3000/api/db-posts?${params.toString()}`)
                .then(res => res.json())
                .then(dbResult => {
                    if (!dbResult || !dbResult.data || !Array.isArray(dbResult.data.children) || dbResult.data.children.length === 0) {
                        console.log('No database results, skipping to Reddit API...');
                        // Continue to Reddit API fetch
                    } else {
                        console.log(`üóÉÔ∏è Using database results (found ${dbResult.data.children.length} posts)`);

                        currentAfter = dbResult.data.after || null;
                        currentBefore = dbResult.data.before || null;

                        const trimmedData = dbResult.data.children.map(post => ({
                            id: post.data.id,
                            title: post.data.title,
                            url: post.data.url,
                            permalink: post.data.permalink,
                            subreddit: post.data.subreddit,
                            score: post.data.score,
                            is_video: post.data.is_video,
                            domain: post.data.domain,
                            author: post.data.author,
                            created_utc: post.data.created_utc,
                            num_comments: post.data.num_comments,
                            over_18: post.data.over_18,
                            preview: post.data.preview,
                            selftext: post.data.selftext,
                            body: post.data.body,
                            is_gallery: post.data.is_gallery,
                            gallery_data: post.data.gallery_data,
                            media_metadata: post.data.media_metadata,
                            crosspost_parent_list: post.data.crosspost_parent_list || [],
                            content_type: post.data.content_type || '',
                            icon_url: null,
                            locked: post.data.locked,
                            stickied: post.data.stickied
                        }));

                        // console.log('üíæ SAVED navigationHistory[' + currentPageIndex + ']:', navigationHistory[currentPageIndex]);
                        
                        const filtered = filterPostsByTime(trimmedData, currentFilters.time);
                        console.log("üì¶ Raw post in frontend before filtering:", trimmedData);

                        // Save to history
                        navigationHistory[currentPageIndex] = {
                            query: currentFilters.query,
                            subreddit: currentFilters.subreddit,
                            after: dbResult.data.after,
                            before: dbResult.data.before,  
                            nextBefore: trimmedData.length > 0 ? `t3_${trimmedData[0].id}` : null,
                            results: filtered
                        };

                        displayResults(filtered);
                        preloadBookmarks(window.stripeCustomerId);
                        window.scrollTo(0, 0);
                        updatePagination();
                        updateURL();

                        return; // ‚úÖ Stop here ‚Äî don‚Äôt go to Reddit
                    }

                    // ‚¨áÔ∏è FALLBACK TO REDDIT API
                    console.log('üåê Not enough database results, fetching from Reddit API');
                    return fetch(`http://localhost:3000/reddit?url=${encodeURIComponent(finalUrl)}`)
                        .then(res => {
                            if (!res.ok) throw new Error('Reddit API failed');
                            return res.json();
                        })
                        .then(data => {

                            currentAfter = data.data.after || null;
                            currentBefore = data.data.before || null;

                            const trimmedData = data.data.children.map(post => {
          
                                return {
                                    id: post.data.id,
                                    title: post.data.title,
                                    url: post.data.url,
                                    permalink: post.data.permalink,
                                    subreddit: post.data.subreddit,
                                    score: post.data.score,
                                    is_video: post.data.is_video,
                                    domain: post.data.domain,
                                    author: post.data.author,
                                    created_utc: post.data.created_utc,
                                    num_comments: post.data.num_comments,
                                    over_18: post.data.over_18,
                                    preview: post.data.preview,
                                    selftext: post.data.selftext,
                                    body: post.data.body,
                                    is_gallery: post.data.is_gallery,
                                    gallery_data: post.data.gallery_data,
                                    media_metadata: post.data.media_metadata,
                                    crosspost_parent_list: post.data.crosspost_parent_list || [],
                                    icon_url: null,
                                    locked: post.data.locked,
                                    stickied: post.data.stickied,
                                    content_type: post.content_type
                                };
                            });

                            const filtered = filterPostsByTime(trimmedData, currentFilters.time);

                            // Update tokens
                            navigationHistory[currentPageIndex] = {
                                query: currentFilters.query,
                                subreddit: currentFilters.subreddit,
                                after: data.data.after,   
                                before: data.data.before,
                                nextBefore: trimmedData.length > 0 ? `t3_${trimmedData[0].id}` : null
                            };

                            // Use currentAfter which is the token that was used to fetch this page
                            if (data.data.children.length > 0) {
                                savePostsToDatabase(trimmedData.map(p => ({ data: p })), tokenForThisPage);
                                // console.log('üíæ Saved posts to database with page group:', tokenForThisPage);
                            }

                            fetch('http://localhost:3000/api/get-cached-posts')
                                .then(res => res.json())
                                .then(cached => {
                                    cached.forEach(post => {
                                        cachedPostsById[post.reddit_post_id] = post;
                                    });

                                    displayResults(filtered);
                                    preloadBookmarks(window.stripeCustomerId);
                                    setTimeout(() => {
                                        if (!filtered.length) {
                                            showError("Couldn't find those terms. üîé");
                                        }
                                    }, 0);

                                    window.scrollTo(0, 0);
                                    updatePagination();
                                    updateURL();
                                    
                                });
                        });
                })
                .catch(err => {
                    console.error('‚ùå Final catch triggered:', err);
                    showError("Something went wrong. Please try again.");
                });           
        }

  function tryGalleryPatch(fullPost, permalink, resultCard, attempt = 1) {

        const mediaId = fullPost.gallery_data?.items?.[0]?.media_id;
        const media = fullPost.media_metadata?.[mediaId];

        // Don‚Äôt proceed if essential pieces are missing
        if (!media || !resultCard) {
            if (!resultCard && attempt < 5) {               
                setTimeout(() => tryGalleryPatch(fullPost, permalink, resultCard, attempt + 1), 100);
            }
            return;
        }

        const imgContainer = resultCard.querySelector('.img-container');
        const imgWrapper = resultCard.querySelector('.image-wrapper');

        if (!imgContainer || !imgWrapper) {
            return;
        }

        // Force container visible if valid
        if (imgContainer.style.visibility === 'hidden') {
            imgContainer.style.visibility = 'visible';
        }

        // Ensure shimmer exists
        let shimmer = resultCard.querySelector('.image-placeholder');
        if (!shimmer) {
            shimmer = document.createElement('div');
            shimmer.className = 'image-placeholder shimmer';
            imgWrapper.prepend(shimmer);
        } else {
            shimmer.style.display = 'block';
        }

        // Gather best available image sources
        const original = media?.s?.u?.replace(/&amp;/g, '&');
        const resolutionFallback = media?.p?.[media.p.length - 1]?.u?.replace(/&amp;/g, '&');
        const fallbacks = [original, resolutionFallback].filter(Boolean);

        // Fallback loader function
        const patchImage = (img) => {
            const trySrc = (index = 0) => {
                if (index >= fallbacks.length) {
                    img.style.display = 'none';
                    showNewsIcon(imgWrapper, shimmer);
                    return;
                }

                const fallbackURL = `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(fallbacks[index])}&t=${Date.now()}`;

                img.onerror = () => {
                    trySrc(index + 1);
                };

                img.onload = () => {
                    console.log('‚úÖ Image loaded from fallback:', fallbackURL);
                    img.classList.add('show');
                    img.style.opacity = '1';
                    shimmer.style.display = 'none';
                };

                img.src = fallbackURL;
            };

            trySrc();
        };

        const resultImg = resultCard.querySelector('img.result-image');

        if (resultImg) {
            patchImage(resultImg);
        } else if (attempt < 3) {
            setTimeout(() => tryGalleryPatch(fullPost, permalink, resultCard, attempt + 1), 100);
        } else {
        }
    }

    function showNewsIcon(imgWrapper, shimmer) {
            // Hide shimmer
            shimmer.style.display = 'none';
            
            // Find and remove the existing result-image
            const existingImg = imgWrapper.querySelector('.result-image');
            if (existingImg) {
                existingImg.remove();
            }
            // Create and show news icon
            const newsIcon = document.createElement('div');
            newsIcon.className = 'news-icon-fallback';
            newsIcon.setAttribute('aria-label', 'Article thumbnail');
            imgWrapper.appendChild(newsIcon);
        }

    function renderSubredditSuggestions(subreddits) {
        // First, check if we already have results
        const hasResults = subredditSuggestions.getAttribute('data-has-results') === 'true';

        // If we have new suggestions and no existing ones, remove any "no results" message
        const isErrorMessageVisible = subredditSuggestions.querySelector('.subreddit-suggestion-err');
        if (subreddits.length > 0 && isErrorMessageVisible) {
            subredditSuggestions.innerHTML = '';
        }

        subreddits.forEach(sub => {
        if (!sub.name) {
                console.warn('‚ö†Ô∏è Skipping subreddit with undefined name in renderSubredditSuggestions:', sub);
                return;
            }
            const suggestion = document.createElement('div');
            suggestion.className = 'subreddit-suggestion';
            suggestion.setAttribute('data-name', sub.name);

            const iconEl = document.createElement('div');
            iconEl.className = 'subreddit-icon';

            if (sub.icon && sub.icon.startsWith('http')) {
   
                console.log(`‚û°Ô∏è Setting icon for ${sub.name} to:`, sub.icon);

                const img = document.createElement('img');
                img.alt = sub.name;
                img.src = sub.icon;

                iconEl.appendChild(img);
                suggestion.appendChild(iconEl);
                suggestion.appendChild(document.createTextNode(sub.name));
                subredditSuggestions.appendChild(suggestion);
                return
                // Don't append the image yet - wait for onload
            } else {
                // Placeholder
                iconEl.textContent = sub.name.charAt(0).toUpperCase();
            }
    
        });
    }

    function filterPostsByContent(posts, contentType) {
            if (contentType === 'all') {
                return posts;
            }

            return posts.filter(post => {
                const postContentType = classifyContentType(post);
                return postContentType === contentType;
        });
    }

    function filterPostsByTime(posts, timeFilter) {
            if (timeFilter === 'all') {
                return posts;
            }

            const now = Math.floor(Date.now() / 1000);
            let timeCutoff = 0;

                switch (timeFilter) {
            case "hour": timeCutoff = now - 7200; break;   
            case "day": timeCutoff = now - 172800; break;   
            case "week": timeCutoff = now - 1209600; break;  
            case "month": timeCutoff = now - 5184000; break; 
            case "year": timeCutoff = now - 63072000; break; 
            default: timeCutoff = 0;
            }

        return posts.filter(post => post.created_utc >= timeCutoff);
    }


    async function displayResults(data, isAppend = false) {
            // For append mode in bookmarks
            if (!isAppend) {
                resultsContainer.style.opacity = 0;
                resultsContainer.innerHTML = '';
            }

            const selectedFilter = document.getElementById('content-select').value;
            // console.log('Number of posts:', data.length);
            // console.log('First post:', data[0]);

            const isFromCache = Array.isArray(data);
            const posts = isFromCache
                ? data
                : data.data?.children.map(item => item.data) || [];

            if (!isFromCache) {
                currentAfter = data.data?.after || null;
                currentBefore = data.data?.before || null;
            //    console.log("üîÑ Updated pagination tokens from API:", { currentAfter, currentBefore });
            }

        // Display results
        for (const post of posts) {
            const postId = post.id || (post.permalink?.split("/")[4] ?? "unknown_id");
            const bookmarkId = post.id || post.reddit_post_id;
            const redditPostId = post.reddit_post_id || (post.name?.startsWith('t3_') ? post.name.slice(3) : undefined);

            let postContentType;

            // console.log('BOOKMARK ID:', bookmarkId)

            // Display domain in url
            console.log(post)

            const title = decodeEntities(post.title?.toLowerCase() || '');
            const isProbablyNSFW = post.over_18 || /\b(tits|titties|rape|raped|tiddies|nudes|onlyfans|boobs|cum|cock|cocks|cunt|gape|gooning|gooner|goon|pussy)\b/i.test(title);

            const resultCard = document.createElement('div');
            resultCard.className = 'result-card';
            resultCard.dataset.permalink = post.permalink;
            resultCard.dataset.bookmarkId = bookmarkId;
            
            if (isProbablyNSFW) {
                resultCard.classList.add('nsfw');
            }

            // Create comments section outer shell
            const commentsSection = document.createElement('div');
            commentsSection.className = 'comments-section';
        
            // Create inner scrollable area
            const commentsScroll = document.createElement('div');
            commentsScroll.className = 'comments-scroll';

            // Put a loading message in the scroll area
            commentsScroll.innerHTML = '<div class="no-comments">Loading comments...</div>';

            // Append scrollable div inside the outer container
            commentsSection.appendChild(commentsScroll);

            // Fetch comments INTO the inner scrollable div
            fetchComments(post.permalink, commentsScroll);

            // Vote section
            const voteSection = document.createElement('div');
            voteSection.className = 'vote-section';
            
            if (post.stickied) {
                // Pushpin for sticky posts
                const pushpinIcon = document.createElement('div');
                pushpinIcon.className = 'pushpin-icon';
                voteSection.appendChild(pushpinIcon);
            }

            const permalinkUrl = `https://www.reddit.com${post.permalink}`;

            const upvoteBtn = document.createElement('a');
            upvoteBtn.href = permalinkUrl;
            upvoteBtn.target = '_blank';
            upvoteBtn.className = 'vote-button-red';
            upvoteBtn.innerHTML = `
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="18 15 12 9 6 15"></polyline>
        </svg>`;

            const voteCount = document.createElement('div');
            voteCount.className = 'vote-count';
            voteCount.textContent = formatNumber(post.score);

            const downvoteBtn = document.createElement('a');
            downvoteBtn.href = permalinkUrl;
            downvoteBtn.target = '_blank';
            downvoteBtn.className = 'vote-button';
            downvoteBtn.innerHTML = `
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="6 9 12 15 18 9"></polyline>
        </svg>`;
            
            voteSection.appendChild(upvoteBtn);
            voteSection.appendChild(voteCount);
            voteSection.appendChild(downvoteBtn);

            // Content section
            const contentSection = document.createElement('div');
            contentSection.className = 'content-section';

            // Result header with subreddit, author, time
            const resultHeader = document.createElement('div');
            resultHeader.className = 'result-header';

            const subredditLink = document.createElement('a');
            subredditLink.className = 'result-subreddit';
            subredditLink.href = `https://www.reddit.com/r/${post.subreddit}`;
            subredditLink.target = '_blank';

            // Add this after creating the subredditLink (around line 211)
            subredditLink.addEventListener('click', (e) => {
                e.preventDefault(); // Stop it from going to Reddit

                // Get the subreddit name from the post data
                const subredditName = post.subreddit;

                // Clear any existing search term (for hot posts behavior)
                searchInput.value = '';

                // Set the subreddit in the input
                subredditInput.value = subredditName;
                // Set filter to hot
                sortSelect.value = 'hot';
                currentFilters.sort = 'hot';

                // Update the chip to show this subreddit
                if (subredditChipContainer) {
                    subredditChipContainer.querySelector('.chip-text').textContent = `r/${subredditName}`;
                    subredditChipContainer.style.display = 'flex';
                }

                // Reset page index and history for new search
                currentPageIndex = 0;

                // Perform the search
                performSearch();
            });
            
            const bookmarkContainer = document.createElement('div');
            bookmarkContainer.className = 'bookmark-container';

            const bookmarkIcon = document.createElement('div');
            bookmarkIcon.className = 'bookmark-icon';
            bookmarkIcon.title = 'Save post';
            bookmarkIcon.dataset.postId = bookmarkId;
            
            const stripeCustomerId = window.stripeCustomerId;

            const savedBookmarks = JSON.parse(sessionStorage.getItem('bookmarks') || '{}');
            if (savedBookmarks[bookmarkId]) {
                bookmarkIcon.classList.add('saved');
            }

            bookmarkContainer.appendChild(bookmarkIcon);
            resultCard.appendChild(bookmarkContainer);

            // Subreddit icon
            const subredditIcon = document.createElement('div');
            subredditIcon.className = 'subreddit-icon';

            // Always show letter immediately
            subredditIcon.textContent = post.subreddit.charAt(0).toUpperCase();

            const storageKey = `subreddit_icon_${post.subreddit}`;
            const cachedIcon = sessionStorage.getItem(storageKey);

            // Check sessionStorage first, then backend, then fetch
            if (cachedIcon && cachedIcon !== 'null' && cachedIcon !== '/api/placeholder/20/20') {
                // Use cached icon from sessionStorage
                const img = document.createElement('img');
                img.src = cachedIcon;
                img.alt = `Icon for r/${post.subreddit}`;
                img.className = 'subreddit-icon-img';
                subredditIcon.textContent = '';
                subredditIcon.appendChild(img);
                setTimeout(() => img.classList.add('fade-in'), 10);
                subredditIcon.classList.add('icon-loaded');
                post.icon_url = cachedIcon;
            } else if (post.icon_url && post.icon_url !== null) {
                // Use the icon URL from the backend response
                console.log(`üåê Using backend icon for r/${post.subreddit}:`, post.icon_url);
                const img = document.createElement('img');
                img.src = post.icon_url;
                img.alt = `Icon for r/${post.subreddit}`;
                img.className = 'subreddit-icon-img';
                subredditIcon.textContent = '';
                subredditIcon.appendChild(img);
                setTimeout(() => img.classList.add('fade-in'), 10);
                subredditIcon.classList.add('icon-loaded');
                // Cache it in sessionStorage for next time
                sessionStorage.setItem(storageKey, post.icon_url);
            } else if (!cachedIcon || cachedIcon === 'null') {
                // Only fetch if backend didn't provide an icon AND no sessionStorage cache
                getSubredditIcon(post.subreddit).then(iconUrl => {
                    if (iconUrl && iconUrl !== '/api/placeholder/20/20') {
                        console.log(`üåè Fetched icon for r/${post.subreddit}:`, iconUrl);
                        const img = document.createElement('img');
                        img.src = iconUrl;
                        img.alt = `Icon for r/${post.subreddit}`;
                        img.className = 'subreddit-icon-img';
                        subredditIcon.textContent = '';
                        subredditIcon.appendChild(img);
                        setTimeout(() => img.classList.add('fade-in'), 10);
                        subredditIcon.classList.add('icon-loaded');
                        post.icon_url = iconUrl;
                        sessionStorage.setItem(storageKey, iconUrl);
                    }
                });
            }

            subredditLink.appendChild(subredditIcon);
            subredditLink.appendChild(document.createTextNode('r/' + post.subreddit));

            const authorSpan = document.createElement('span');
            authorSpan.className = 'result-author';
            authorSpan.textContent = 'Posted by u/' + post.author;

            // Wrap the span in a link
            const authorLink = document.createElement('a');
            authorLink.className = 'result-author';
            authorLink.href = `https://www.reddit.com/user/${post.author}`;
            authorLink.target = '_blank';
            authorLink.appendChild(authorSpan);

            const timeSpan = document.createElement('span');
            timeSpan.className = 'result-time';
            timeSpan.textContent = formatTimestamp(post.created_utc);

            const metaRow = document.createElement('div');
            metaRow.className = 'result-meta';

            metaRow.appendChild(subredditLink);
            metaRow.appendChild(authorLink);
            metaRow.appendChild(timeSpan);

            resultHeader.appendChild(metaRow);

            // Result title
            const resultTitle = document.createElement('div');
            resultTitle.className = 'result-title';

            const titleLink = document.createElement('a');
            titleLink.href = `https://www.reddit.com${post.permalink}`;
            titleLink.target = '_blank';
            titleLink.textContent = decodeEntities(post.title || 'Comment in thread');

            // Detect long title length for CSS
            if (post.title.length > 100) {
                resultTitle.classList.add('long-title');
            }

            resultTitle.appendChild(titleLink);

            // Result content (text or snippet)
            const resultContent = document.createElement('div');
            resultContent.className = 'result-content';

            let snippet = '';
            let isFromCrosspost = false;

            if (post.selftext && post.selftext.trim() !== '') {
                const decodedText = decodeEntities(post.selftext);
                snippet = decodedText.length > 300
                    ? decodedText.substring(0, 300) + '...'
                    : decodedText;
            } else if (post.body && post.body.trim() !== '') {
                const decodedBody = decodeEntities(post.body);
                snippet = decodedBody.length > 300
                    ? decodedBody.substring(0, 300) + '...'
                    : decodedBody;
            } else if (
                post.crosspost_parent_list?.[0]?.selftext &&
                post.crosspost_parent_list[0].selftext !== ''
            ) {
                // Set flag for crossposted content
                isFromCrosspost = true;
                const decodedCrosspostText = decodeEntities(post.crosspost_parent_list[0].selftext);
                snippet = decodedCrosspostText.length > 300
                    ? decodedCrosspostText.substring(0, 300) + '...'
                    : decodedCrosspostText;
            }

            // Clear the content area
            resultContent.innerHTML = '';

            if (isFromCrosspost) {
                const quoteEl = document.createElement('div');
                quoteEl.className = 'el-quote';
                quoteEl.innerHTML = parseMarkdown(snippet);
                resultContent.appendChild(quoteEl);
            } else {
                resultContent.innerHTML = parseMarkdown(snippet);
            }

            // After creating your snippet, clean up incomplete links
            if (snippet.match(/\[[^\]]+\]\([^)]*$/)) {
                // Remove the incomplete link syntax at the end
                snippet = snippet.replace(/\[[^\]]+\]\([^)]*$/, '...');
            }

            // Result actions (comments, save, share)
            const resultActions = document.createElement('div');
            resultActions.className = 'result-actions';

            const commentsAction = document.createElement('div');
            commentsAction.className = 'result-action';
            commentsAction.innerHTML = `
        <svg class="action-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
        </svg>
        ${post.num_comments || 0} Comments`;

            commentsAction.style.cursor = 'pointer';

            commentsAction.addEventListener('click', () => {
                const url = 'https://www.reddit.com' + post.permalink;
                window.open(url, '_blank');
            });

            const saveAction = document.createElement('div');
            saveAction.className = 'result-action';
            saveAction.innerHTML = `
        <svg class="action-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>
        </svg>
        Save`;
            saveAction.addEventListener('click', () => {
                const url = 'https://www.reddit.com' + post.permalink;
                window.open(url, '_blank');
            });

            const shareAction = document.createElement('div');
            shareAction.className = 'result-action';
            shareAction.innerHTML = `
        <svg class="action-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="18" cy="5" r="3"></circle>
            <circle cx="6" cy="12" r="3"></circle>
            <circle cx="18" cy="19" r="3"></circle>
            <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
            <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
        </svg>
        Share`;
            shareAction.addEventListener('click', () => {
                const url = 'https://www.reddit.com' + post.permalink;
                window.open(url, '_blank');
            });

            resultActions.appendChild(commentsAction);
            resultActions.appendChild(saveAction);
            resultActions.appendChild(shareAction);

            // Add all sections to content area
            contentSection.appendChild(resultHeader);
            contentSection.appendChild(resultTitle);

            if (snippet) {
                contentSection.appendChild(resultContent);
            }

            contentSection.appendChild(resultActions);
            
            // Domain and thumbnail checks
            const knownNewsDomains = new Set([
                "nytimes.com", "apnews.com", "reuters.com", "cnn.com", "bbc.com",
                "cnbc.com", "abcnews.go.com", "aljazeera.com", "nbcnews.com", "independent.co.uk",
                "kstp.com", "nbcnews.to", "nzherald.co.nz", "cnet.com", "latimes.com", "cbsnews.com",
                "spin.com", "xxlmag.com", "newschannel9.com", "kutv.com", "deadline.com",
                "wbez.org", "rawstory.com", "abc15.com", "npr.org", "foxnews.com",
                "washingtonpost.com", "theguardian.com", "wired.com", "bloomberg.com", "politico.com"
            ]);

            const badThumbs = new Set(['self', 'default', 'nsfw', 'spoiler', 'image', '']);
            const normalizedThumb = (post.thumbnail || '').toLowerCase();
            const isGarbageThumb = badThumbs.has(normalizedThumb);

            const domain = post.domain || getDomainFromUrl(post.url);

            // Determine whether to analyze the media type for if it's moving
            let mediaUrlForAnalysis = null;

            const url = post.url?.toLowerCase() || '';
            const allowedExts = ['.mp4', '.webm', '.mov', '.mkv', '.avi', '.flv', '.wmv', '.gif'];

            const hasValidExtension = allowedExts.some(ext => url.endsWith(ext));

            if (hasValidExtension) {
                mediaUrlForAnalysis = post.url;
            } else if (post.preview?.images?.[0]?.variants?.gif?.source?.url?.toLowerCase().endsWith('.gif')) {
                mediaUrlForAnalysis = post.preview.images[0].variants.gif.source.url;
            }
            
            // End of analyzing media type

            const knownMediaDomains = [
                "i.redd.it", "v.redd.it", "streamable.com", "imgur.com", "preview.redd.it", "reddit.com", "wikipedia.com",
                "gfycat.com", "redgifs.com", "tenor.com", "youtube.com", "youtu.be"
            ];

            const isKnownMediaDomain = knownMediaDomains.includes(domain);
            const isSelfPost = post.is_self || (post.domain || '').startsWith('self.');
            const isLinkPost = !isSelfPost;
            const isBareLink = post.selftext === "";
            const isRedditMedia =
                post.url?.includes('v.redd.it') ||
                post.url?.includes('i.redd.it') ||
                post.url?.includes('gfycat.com') ||
                post.url?.includes('imgur.com') ||
                post.url?.includes('redgifs.com') ||
                post.url?.endsWith('.gif') ||
                post.url?.endsWith('.mp4') ||
                post.url?.endsWith('.webm');

            const shouldSaveToBackend = (
                isLinkPost &&
                isBareLink &&
                isGarbageThumb &&
                !isRedditMedia && // ‚úÖ filters out gif/video stuff
                (!isKnownMediaDomain || domain === 'youtube.com')
            );

            let thumbnailURL = getThumbnailUrl(post);

            // YOUTUBE THUMBNAIL LOGIC 
            if ((domain === 'youtube.com' || domain === 'youtu.be')) {
                console.log('üîç YouTube URL:', post.url);
                const youtubeThumb = getYouTubeThumbnail(post.url);
                console.log('üì∫ getYouTubeThumbnail returned:', youtubeThumb);
                if (youtubeThumb) {
                    thumbnailURL = youtubeThumb;
                    console.log('üì∫ Using YouTube thumbnail:', youtubeThumb);
                }
            }

            // Special handling for Reddit videos without preview
            if (!thumbnailURL && post.url && post.url.includes('v.redd.it')) {
                const videoId = post.url.split('/').pop();
                const dashUrl = `https://v.redd.it/${videoId}/DASH_480.mp4`;
                console.log('üé• Using Reddit video thumbnail:', dashUrl);
                return `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(dashUrl)}`; 
            }

            const hasPreviewImage = post.preview?.images?.[0]?.source?.url;
            const isVideo = post.is_video ||
                (post.domain && post.domain.includes('youtu')) ||
                (post.url && post.url.includes('v.redd.it')) ||
                (post.domain && post.domain.includes('streamable')) ||
                (post.url && post.url.endsWith('.gifv'));
            const isGalleryWithData = post.is_gallery && post.gallery_data && post.media_metadata;

            const isGarbage = !thumbnailURL || ['self', 'default', 'nsfw', 'spoiler', 'image'].includes(thumbnailURL.toLowerCase());
            const hasVisualMedia = (!isGarbage || isGalleryWithData || isVideo || shouldSaveToBackend ||
                hasPreviewImage || !post.is_self && !domain.startsWith('self.'));

            const imgContainer = document.createElement('div');
            imgContainer.className = 'img-container';

            // Append sections
            resultCard.appendChild(voteSection);
            resultCard.appendChild(contentSection);
            resultCard.appendChild(commentsSection);

            //console.log('üîç Post debug:', {
            //    id: post.id,
            //    title: post.title,
            //    is_self: post.is_self,
            //   domain: post.domain,
            //    hasVisualMedia: hasVisualMedia
            //});
            
            // Check database cache before patches
            if (!window.imageHandler) {
                window.imageHandler = new ImageHandler();
            }

            // Only handle images if there's actually visual media
            if (hasVisualMedia) {
                window.imageHandler.handleImageLoad(post, resultCard);
            }
            
            const mediaContainer = createMediaElement(post, thumbnailURL, domain, resultCard);
            resultCard.appendChild(mediaContainer);
            addPlayIconIfNeeded(post, resultCard);

            // Classify content
                if (selectedFilter !== 'all') {
                    postContentType = classifyContentType(post);
                    console.log('Selected filter:', selectedFilter);
                    console.log('Post classified as:', postContentType); 
                if (postContentType !== selectedFilter) {
                    continue;
                }       
            }

            PATCHES(post, resultCard);

            // Add resultCard to the main results container
            resultsContainer.appendChild(resultCard);
            
            // Bookmark click handler
            bookmarkIcon.addEventListener('click', async (e) => {
                e.stopPropagation();
                const bookmarkId = bookmarkIcon.dataset.postId;
                const isSaved = bookmarkIcon.classList.contains('saved');

                try {
                    // Get current bookmarks from sessionStorage
                    const savedBookmarks = JSON.parse(sessionStorage.getItem('bookmarks') || '{}');

                    if (isSaved) {
                        // Remove from database
                        await fetch(`http://localhost:3000/api/bookmarks/${stripeCustomerId}/${bookmarkId}`, {
                            method: 'DELETE',
                        });

                        // Update UI
                        bookmarkIcon.classList.remove('saved');

                        // Update sessionStorage
                        delete savedBookmarks[bookmarkId];
                        sessionStorage.setItem('bookmarks', JSON.stringify(savedBookmarks));

                        console.log('Bookmark with ID of', bookmarkId, 'removed.');
                    } else {
                        // Add to database
                        await fetch('http://localhost:3000/api/bookmarks', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                postId: bookmarkId,
                                stripeCustomerId,
                                title: post.title || '',
                                url: post.url || '',
                                permalink: post.permalink || '',
                                subreddit: post.subreddit || '',
                                score: post.score || 0,
                                is_video: Boolean(post.is_video),
                                domain: post.domain || '',
                                author: post.author || '',
                                created_utc: post.created_utc || 0,
                                num_comments: post.num_comments || 0,
                                over_18: Boolean(post.over_18),
                                selftext: post.selftext || '',
                                body: post.body || '',
                                is_gallery: Boolean(post.is_gallery),
                                gallery_data: post.gallery_data || null,
                                media_metadata: post.media_metadata || null,
                                crosspost_parent_list: post.crosspost_parent_list || [],
                                content_type: post.content_type || '',
                                icon_url: post.icon_url || null,
                                locked: Boolean(post.locked),
                                stickied: Boolean(post.stickied),
                                preview: post.preview || null 
                            }),
                        });

                        // Update UI
                        bookmarkIcon.classList.add('saved');

                        // Update sessionStorage
                        savedBookmarks[bookmarkId] = true;
                        sessionStorage.setItem('bookmarks', JSON.stringify(savedBookmarks));

                        console.log('Bookmark with ID of', bookmarkId, 'saved.');
                    }
                } catch (err) {
                    console.error('Failed to toggle bookmark:', err);
                }
            });

            // Filter NSFW
            const safeSearchSelect = document.getElementById('safesearch-select');
            if (safeSearchSelect?.value === 'on') {
                document.body.classList.add('safe-search-enabled');
            } else {
                document.body.classList.remove('safe-search-enabled');
            }
        }

        // Visibility code 
        applyStaggeredAnimation('.result-card', 'visible', 40);
        resultsContainer.style.opacity = 1;
        updatePagination();

        // After the loop, add these logs:
        const allCards = document.querySelectorAll('.result-card');
        const visibleCards = Array.from(allCards).filter(card =>
            window.getComputedStyle(card).display !== 'none'
        );

        if (visibleCards.length === 0) {
            showError("No results found. Try different search terms or filters.");
            paginationContainer.innerHTML = '';
            return;
        }
    }
        
        
        
        
        
        
        
        
        
    
        
        
        
    function PATCHES(post, resultCard) {   
       // Patch media on timeout
        tryMediaPatch(post, resultCard);
        setTimeout(() => {
            addPlayIconIfNeeded(post, resultCard);
        }, 100);

        // Gallery post check, trigger gallery patch if needed
        if (post.is_gallery && post.gallery_data && post.media_metadata) {
            setTimeout(() => {
                tryGalleryPatch(post, post.permalink, resultCard);
            }, 0);
        }
    } 

        // Media handling
        function createMediaElement(post, thumbnailURL, domain, resultCard) {
            const imgContainer = document.createElement('div');
            const imageWrapper = document.createElement('div');
            const imagePlaceholder = document.createElement('div');

            imgContainer.className = 'img-container';
            imageWrapper.className = 'image-wrapper';
            imagePlaceholder.className = 'image-placeholder shimmer';

            // Determine media type and sources
            const mediaInfo = analyzeMediaType(post, thumbnailURL, domain);

            if (!mediaInfo.hasVisualMedia && domain && domain !== 'reddit.com' && domain.includes('.')) {
                const imgContainer = document.createElement('div');
                const imageWrapper = document.createElement('div');
                const imagePlaceholder = document.createElement('div');

                // ADD THIS - create the img element that updateImageSuccess expects
                const img = document.createElement('img');
                img.className = 'result-image';

                imgContainer.className = 'img-container';
                imageWrapper.className = 'image-wrapper';
                imagePlaceholder.className = 'image-placeholder shimmer';

                imageWrapper.appendChild(imagePlaceholder);
                imageWrapper.appendChild(img); // Add the img element
                imgContainer.appendChild(imageWrapper);

                window.imageHandler.handleBackendScrapedImage(post, resultCard);
                return imgContainer;
            }
  
            // Create the appropriate media element
            const mediaElement = createMediaElementByType(mediaInfo);
            mediaElement.style.opacity = '0';
            mediaElement.style.transition = 'opacity 0.3s ease-in-out';

            // Set up error handling with retry chain
            setupMediaErrorHandling(mediaElement, mediaInfo);

            // Set up load event handling
            setupMediaLoadHandling(mediaElement, imagePlaceholder);

            // Set up click modal
            setupImageModal(imageWrapper);

            // Assemble the DOM
            imageWrapper.appendChild(imagePlaceholder);
            imageWrapper.appendChild(mediaElement);
            imageWrapper.style.cursor = 'pointer';
            imgContainer.appendChild(imageWrapper);

            return imgContainer;
        }

        function analyzeMediaType(post, thumbnailURL, domain) {
            // Get all possible image sources in priority order
            const previewImage = post.preview?.images?.[0]?.source?.url?.replace(/&amp;/g, '&');
            const gifVariant = post.preview?.images?.[0]?.variants?.gif?.source?.url;
            const cleanThumbnail = thumbnailURL?.replace(/&amp;/g, '&');

            // Media type detection
            const isVideo = post.is_video || post.url?.includes('v.redd.it');
            const isGif = post.url?.endsWith('.gif') || gifVariant;
            const isMp4 = post.url?.endsWith('.mp4');
            const isYouTube = domain === 'youtube.com' || domain === 'youtu.be';
            const isGallery = post.is_gallery && post.gallery_data && post.media_metadata;

            // Determine if we should show visual media
            const isGarbageThumbnail = !thumbnailURL ||
                ['self', 'default', 'nsfw', 'spoiler', 'image'].includes(thumbnailURL.toLowerCase());

            const hasVisualMedia = (!isGarbageThumbnail ||
                isGallery ||
                isVideo ||
                previewImage) &&
                !(post.domain || '').startsWith('self.');

            // Build source priority list
            const sources = [];

            if (gifVariant) {
                sources.push({ url: gifVariant, type: 'gif', priority: 1 });
            }
            if (post.url?.endsWith('.gif')) {
                sources.push({ url: post.url, type: 'gif', priority: 2 });
            }
            if (isMp4) {
                sources.push({ url: post.url, type: 'video', priority: 3 });
            }
            if (isVideo && cleanThumbnail?.includes('DASH_')) {
                sources.push({ url: cleanThumbnail, type: 'video', priority: 4 });
            }
            if (previewImage) {
                sources.push({
                    url: `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(previewImage)}`,
                    type: 'image',
                    priority: 3
                });
            }
            if (cleanThumbnail && !cleanThumbnail.includes('DASH_')) {
                sources.push({
                    url: `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(cleanThumbnail)}`,
                    type: 'image',
                    priority: 2
                });
            }
            if (post.url) {
                sources.push({ url: post.url, type: 'fallback', priority: 7 });
            }

            // Sort by priority
            sources.sort((a, b) => a.priority - b.priority);

            return {
                hasVisualMedia,
                sources,
                isVideo,
                isGif,
                isMp4,
                isYouTube,
                primarySource: sources[0] || null
            };
        }

        function createMediaElementByType(mediaInfo) {
            if (!mediaInfo.primarySource) {
                return document.createElement('img');
            }

            const source = mediaInfo.primarySource;
            let mediaElement;

            if (source.type === 'video' || mediaInfo.isMp4) {
                mediaElement = document.createElement('video');
                mediaElement.muted = true;
                mediaElement.playsInline = true;
                mediaElement.preload = 'metadata';

                if (mediaInfo.isMp4) {
                    mediaElement.autoplay = true;
                    mediaElement.loop = true;
                } else {
                    mediaElement.currentTime = 0.1; // For preview frame
                }
            } else {
                mediaElement = document.createElement('img');
            }

            // Set standard attributes
            mediaElement.className = 'result-image';
            mediaElement.alt = 'Post thumbnail';
            mediaElement.setAttribute('loading', 'lazy');
            mediaElement.setAttribute('decoding', 'async');
            mediaElement.setAttribute('fetchpriority', 'low');
            mediaElement.setAttribute('crossorigin', 'anonymous');

            // Set initial source
            mediaElement.src = source.url;

            return mediaElement;
        }

        function setupMediaErrorHandling(mediaElement, mediaInfo) {
            let currentSourceIndex = 0;

            function tryNextSource() {
                currentSourceIndex++;

                if (currentSourceIndex >= mediaInfo.sources.length) {
                    // All sources failed
                    console.error('üö´ All media sources failed for:', mediaInfo.sources);
                    setTimeout(() => {
                        const resultCard = mediaElement.closest('.result-card');
                        const shimmer = resultCard?.querySelector('.image-placeholder');
                        if (shimmer) shimmer.style.display = 'none';

                        const imageWrapper = mediaElement.closest('.image-wrapper');
                        if (imageWrapper) {
                            showNewsIcon(imageWrapper, shimmer);
                        }
                    }, 1000);
                    return;
                }

                const nextSource = mediaInfo.sources[currentSourceIndex];
                console.warn(`üîÅ Trying source ${currentSourceIndex + 1}/${mediaInfo.sources.length}:`, nextSource.url);

                // Update element type if needed
                if (nextSource.type === 'video' && mediaElement.tagName !== 'VIDEO') {
                    // Need to replace with video element
                    const newElement = document.createElement('video');
                    newElement.className = mediaElement.className;
                    newElement.alt = mediaElement.alt;

                    // Copy attributes
                    ['loading', 'decoding', 'fetchpriority', 'crossorigin'].forEach(attr => {
                        newElement.setAttribute(attr, mediaElement.getAttribute(attr));
                    });

                    newElement.muted = true;
                    newElement.playsInline = true;
                    newElement.preload = 'metadata';

                    mediaElement.parentNode.replaceChild(newElement, mediaElement);
                    mediaElement = newElement;

                    // Re-setup error handling for new element
                    setupMediaErrorHandling(newElement, mediaInfo);
                }

                mediaElement.src = nextSource.url;
            }

            mediaElement.addEventListener('error', (e) => {
                // Skip retry for DASH URLs that should work as videos
                if (mediaElement.src.includes('DASH_') && mediaElement.tagName === 'VIDEO') {
                    console.log('üé¨ DASH video error, but this is expected behavior');
                    return;
                }

                console.warn('‚ùå Media load failed:', mediaElement.src);
                tryNextSource();
            });
        }

    function setupMediaLoadHandling(mediaElement, imagePlaceholder) {
        const handleSuccess = () => {
            console.log('‚úÖ Media loaded successfully:', mediaElement.src);

            // Start both animations simultaneously
            // Fade out shimmer
            imagePlaceholder.style.opacity = '0';
            imagePlaceholder.style.transition = 'opacity 0.3s ease-in-out';

            // Fade in media
            mediaElement.style.opacity = '1';

            // Remove shimmer after fade completes
            setTimeout(() => {
                imagePlaceholder.style.display = 'none';
                // or imagePlaceholder.remove(); if you want to completely remove it
            }, 300);
        };

        if (mediaElement.tagName === 'VIDEO') {
            mediaElement.addEventListener('loadeddata', handleSuccess);
            mediaElement.addEventListener('canplay', handleSuccess);
        } else {
            mediaElement.addEventListener('load', () => {
                if (mediaElement.naturalWidth > 0 && mediaElement.naturalHeight > 0) {
                    handleSuccess();
                }
            });
        }
    }

    function setupImageModal(imageWrapper) {
        imageWrapper.addEventListener('click', function () {
            // Remove any existing modals first
            const existingModal = document.querySelector('.modal-overlay');
            if (existingModal) {
                existingModal.remove();
            }
            const modalOverlay = document.createElement('div');
            modalOverlay.className = 'modal-overlay';
            modalOverlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s ease;
        `;

            const modalImageWrapper = imageWrapper.cloneNode(true);
            modalImageWrapper.style.cssText = `
            width: auto !important;
            height: auto !important;
            cursor: pointer;
            max-width: 90vw;
            max-height: 90vh;
            display: block !important;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.1s ease;
            border-radius: 25px;
        `;

            // FIX: Clean up the cloned modal content
            const imageInside = modalImageWrapper.querySelector('img, video');
            const shimmerPlaceholder = modalImageWrapper.querySelector('.image-placeholder');

            if (imageInside) {
                imageInside.style.cssText = `
                width: 100% !important;
                height: auto !important;
                max-width: 90vw;
                max-height: 90vh;
                opacity: 1 !important;  // Make sure image is visible in modal
            `;
            }

            // Remove shimmer from modal (it shouldn't be there)
            if (shimmerPlaceholder) {
                shimmerPlaceholder.remove();
            }

            modalOverlay.appendChild(modalImageWrapper);
            document.body.appendChild(modalOverlay);

            // Trigger animations with proper timing
            setTimeout(() => {
                modalOverlay.style.backgroundColor = 'rgba(0,0,0,0.8)';
                modalImageWrapper.style.opacity = '1';
                modalImageWrapper.style.transform = 'scale(1)';
            }, 10);

            // Close modal
            modalOverlay.addEventListener('click', function () {
                modalOverlay.style.backgroundColor = 'rgba(0,0,0,0)';
                modalImageWrapper.style.opacity = '0';
                modalImageWrapper.style.transform = 'scale(0.8)';
                setTimeout(() => {
                    if (document.body.contains(modalOverlay)) {
                        document.body.removeChild(modalOverlay);
                    }
                }, 300);
            });
        });
    }

    class ImageHandler {
        constructor() {
            this.knownNewsDomains = new Set([
                "nytimes.com", "apnews.com", "reuters.com", "cnn.com", "bbc.com",
                "cnbc.com", "abcnews.go.com", "aljazeera.com", "nbcnews.com", "independent.co.uk",
                "kstp.com", "nbcnews.to", "nzherald.co.nz", "cnet.com", "latimes.com", "cbsnews.com",
                "spin.com", "xxlmag.com", "newschannel9.com", "kutv.com", "deadline.com",
                "wbez.org", "rawstory.com", "abc15.com", "npr.org", "foxnews.com",
                "washingtonpost.com", "theguardian.com", "wired.com", "bloomberg.com", "politico.com"
            ]);

            this.knownMediaDomains = [
                "i.redd.it", "v.redd.it", "streamable.com", "imgur.com", "preview.redd.it",
                "reddit.com", "wikipedia.com", "gfycat.com", "redgifs.com", "tenor.com",
                "youtube.com", "youtu.be"
            ];

            this.badThumbs = new Set(['self', 'default', 'nsfw', 'spoiler', 'image', '']);
            this.failureCount = new Map(); // Track failures per post
        }

        // Determine if post needs backend scraping
        shouldUseBackendScraper(post) {
            const domain = post.domain || this.getDomainFromUrl(post.url);
            const isGarbageThumb = this.badThumbs.has((post.thumbnail || '').toLowerCase());
            const isSelfPost = post.is_self || (post.domain || '').startsWith('self.');
            const isLinkPost = !isSelfPost;
            const isBareLink = post.selftext === "";
            const isRedditMedia = this.isRedditMediaUrl(post.url);
            const isKnownMediaDomain = this.knownMediaDomains.includes(domain);

            return (
                isLinkPost &&
                isBareLink &&
                isGarbageThumb &&
                !isRedditMedia &&
                (!isKnownMediaDomain || domain === 'youtube.com')
            );
        }

        // Check if URL is Reddit media
        isRedditMediaUrl(url) {
            if (!url) return false;
            return url.includes('v.redd.it') ||
                url.includes('i.redd.it') ||
                url.includes('gfycat.com') ||
                url.includes('imgur.com') ||
                url.includes('/comments/') ||
                url.includes('redgifs.com') ||
                url.endsWith('.gif') ||
                url.endsWith('.mp4') ||
                url.endsWith('.webm');
        }

        // Extract domain from URL
        getDomainFromUrl(url) {
            try {
                return new URL(url).hostname.replace('www.', '');
            } catch {
                return '';
            }
        }

        // Helper function to check if URL is a Reddit domain
        isRedditDomain(url) {
            if (!url) return false;
            const redditDomains = ['i.redd.it', 'v.redd.it', 'reddit.com', 'preview.redd.it', 'external-preview.redd.it'];
            return redditDomains.some(domain => url.includes(domain));
        }

        // Handle image loading with retry logic
        async handleImageLoad(post, resultCard) {
            const postId = post.id;

            // Don't handle images for text posts
            if (post.is_self || (post.domain || '').startsWith('self.')) {
                return; // Exit early for text posts
            }

            // Skip Reddit image domains entirely
            if (this.isRedditDomain(post.url)) {
                // console.log(`üö´ Skipping Reddit image domain: ${post.url}`);
                return;
            }

            const shouldScrape = this.shouldUseBackendScraper(post);

            if (shouldScrape) {
                await this.handleBackendScrapedImage(post, resultCard);
            } else {
                await this.handleDirectImage(post, resultCard);
            }
        }

        // Handle backend-scraped images
        async handleBackendScrapedImage(post, resultCard) {
            const postId = post.id;

            try {
                // Try cached first
                const cached = await this.getCachedImage(postId);
                if (cached.success && cached.data.thumbnail) {
                    this.updateImageSuccess(resultCard, cached.data.thumbnail);
                    this.createLinkPreview(post, resultCard);
                    return;
                }

                // Try scraping
                const scraped = await this.scrapeImage(post);
                if (scraped.success && scraped.data?.thumbnail) {
                    this.updateImageSuccess(resultCard, scraped.data.thumbnail);
                    this.updateCache(postId, scraped);
                    this.createLinkPreview(post, resultCard);
                    return;
                }

                // Failed - increment counter and maybe show news icon
                this.handleImageFailure(postId, resultCard);

            } catch (error) {
                console.error('‚ùå Backend image handling failed:', error);
                this.handleImageFailure(postId, resultCard);
            }
        }

        // Handle direct images (non-scraped)
        async handleDirectImage(post, resultCard) {
            // Skip Reddit domains
            if (this.isRedditDomain(post.url)) {
                console.log(`üö´ Skipping Reddit domain: ${post.url}`);
                return;
            }

            // Save to backend for analytics/caching WITHOUT scraping
            try {
                await fetch('http://localhost:3000/api/save-image', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        reddit_post_id: post.id,
                        subreddit: post.subreddit,
                        title: post.title,
                        url: post.url,
                        thumbnail: post.thumbnail
                    })
                });
            } catch (error) {
                console.log('‚ö†Ô∏è Backend save failed (non-critical):', error);
            }
        }

        // Handle image failure with retry logic
        handleImageFailure(postId, resultCard) {
            const failures = this.failureCount.get(postId) || 0;
            this.failureCount.set(postId, failures + 1);

            console.log(`‚ùå Image failure ${failures + 1} for post ${postId}`);

            // Show news icon only after multiple failures (3+ attempts)
            if (failures >= 2) {
                console.log('üóûÔ∏è Multiple failures detected, showing news icon');
                this.showNewsIcon(resultCard);
            } else {
                // Just hide the shimmer for now
                this.hideShimmer(resultCard);
            }
        }

      // Update image on success
        updateImageSuccess(resultCard, thumbnailUrl) {
            console.log('üîç updateImageSuccess called with:', thumbnailUrl);
            const image = resultCard.querySelector('img.result-image');
            image.style.opacity = '0';
            image.style.transition = 'opacity 0.3s ease-in-out';
            if (!image) return;

            const proxyUrl = `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(thumbnailUrl)}&t=${Date.now()}`;
            console.log('üîç Setting image src to:', proxyUrl);
            let hasRetried = false;

            const handleLoad = () => {
                console.log('‚úÖ Image loaded successfully');

                // Get shimmer element
                const shimmer = resultCard.querySelector('.image-placeholder');

                // Add styling class
                image.classList.add('show');

                // Make image visible but still transparent
                image.style.display = 'block';

                // Handle fade transitions simultaneously
                if (shimmer) {
                    shimmer.style.opacity = '0';
                    shimmer.style.transition = 'opacity 0.3s ease-in-out';

                    setTimeout(() => {
                        shimmer.style.display = 'none';
                    }, 300);
                }

                // Small delay to ensure display:block is applied, then fade in
                setTimeout(() => {
                    image.style.opacity = '1';
                }, 10);

                // Make container visible
                const container = resultCard.querySelector('.img-container');
                if (container) container.style.visibility = 'visible';

                // Set up modal for scraped images  
                const imgWrapper = resultCard.querySelector('.image-wrapper');
                if (imgWrapper && !imgWrapper._hasModalSetup) {
                    setupImageModal(imgWrapper);
                    imgWrapper._hasModalSetup = true;
                }
            };

            const handleError = () => {
                if (!hasRetried) {
                    console.log('üö´ Proxy failed, retrying raw URL:', thumbnailUrl);
                    hasRetried = true;
                    image.src = thumbnailUrl; // Try raw URL without proxy
                } else {
                    console.log('‚ùå Image load error even after retry');
                    this.handleImageFailure(resultCard.dataset.postId, resultCard);
                }
            };

            // Check if image is already cached/loaded
            if (image.complete && image.naturalWidth > 0) {
                handleLoad();
            } else {
                image.addEventListener('load', handleLoad);
                image.addEventListener('error', handleError);
            }

            image.src = proxyUrl; // Start with proxy
        }

        // Show news icon
        showNewsIcon(resultCard) {
            const imgContainer = resultCard.querySelector('.img-container');
            const shimmer = resultCard.querySelector('.image-placeholder');

            if (shimmer) {
                shimmer.classList.add('hide');
                setTimeout(() => shimmer.style.display = 'none', 300);
            }

            if (imgContainer && !imgContainer.querySelector('.news-icon')) {
                showNewsIcon(imgContainer, shimmer); // Your existing function
            }
        }

        // Hide shimmer animation
        hideShimmer(resultCard) {
            const shimmer = resultCard.querySelector('.image-placeholder');
            if (shimmer) {
                shimmer.classList.add('hide');
                setTimeout(() => shimmer.style.display = 'none', 300);
            }
        }

        // API calls
        async getCachedImage(postId) {
            const response = await fetch(`http://localhost:3000/api/get-cached-image/${postId}`);
            return await response.json();
        }

        // Updated scrapeImage function
        async scrapeImage(post) {
            // Skip Reddit domains
            if (this.isRedditDomain(post.url)) {
                console.log(`üö´ Skipping Reddit domain scraping: ${post.url}`);
                return { success: false, message: 'Skipped Reddit domain' };
            }

            const response = await fetch('http://localhost:3000/api/save-image', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    reddit_post_id: post.id,
                    subreddit: post.subreddit,
                    title: post.title,
                    url: post.url,
                    thumbnail: post.thumbnail
                })
            });
            const text = await response.text();
            if (response.ok) {
                return JSON.parse(text);
            } else {
                console.error('Error:', text);
                return { success: false, message: 'Failed' };
            }
        }

        // Update cache
        updateCache(postId, data) {
            window.cachedPostsById = window.cachedPostsById || {};
            window.cachedPostsById[postId] = data;
        }

        // Create link preview for scraped posts
        createLinkPreview(post, resultCard) {
            if (resultCard.querySelector('.link-preview-card')) return;

            const domain = this.getDomainFromUrl(post.url);
            const linkPreview = document.createElement('div');
            linkPreview.className = 'link-preview-card';
            linkPreview.style.position = 'absolute';
            linkPreview.style.opacity = '0'; 
            linkPreview.style.transition = 'opacity 0.3s ease-in-out'; 
            linkPreview.innerHTML = `
        <div class="link-preview-container">
            <span class="link-domain">${domain}</span>
            <a href="${post.url}" target="_blank" rel="noopener noreferrer" class="link-preview-btn">
                Open
            </a>
        </div>
    `;

            const resultAction = resultCard.querySelector('.result-actions');
            if (resultAction) {
                resultAction.after(linkPreview);

                setTimeout(() => {
                    linkPreview.style.opacity = '1';
                }, 10);
            }
        }
    }

    // Add cache management utility function
    function clearExpiredCaches() {
        const now = Date.now();
        const cachePrefix = 'kf_search_';

        // Loop through all localStorage items
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);

            // Only process our cache keys
            if (key && key.startsWith(cachePrefix)) {
                try {
                    const cachedData = JSON.parse(localStorage.getItem(key));

                    // Remove if expired
                    if (now - cachedData.timestamp >= CACHE_DURATION_MS) {
                        localStorage.removeItem(key);
                        console.log('üßπ Removed expired cache:', key);
                    }
                } catch (e) {
                    // If we can't parse it, remove it
                    localStorage.removeItem(key);
                }
            }
        }
    }

    function createAuthorLink(author) {
            const authorLink = document.createElement('a');
            authorLink.className = 'author-link';
            authorLink.href = `https://www.reddit.com/user/${author}`;
            authorLink.target = '_blank';
            authorLink.textContent = `${author}`;
            return authorLink;
    }

    function applyStaggeredAnimation(selector, classToAdd, delayBetween = 30) {
            const elements = document.querySelectorAll(selector);
            elements.forEach((element, index) => {
                setTimeout(() => {
                    requestAnimationFrame(() => {
                        element.classList.add(classToAdd);
                    });
                }, index * delayBetween);
            });
    }

    function showLoading() {
    
        isLoading = true;
        resultsContainer.innerHTML = '';
        resultsContainer.innerHTML = `
    <div class='results-error' id='spinner-box' style="opacity: 0; transition: opacity 0.25s ease;"></div>
`;
            const spinnerWrapper = createCanvasSpinner();
        const spinnerBox = document.getElementById('spinner-box');
        spinnerBox.appendChild(spinnerWrapper);

        // Trigger the fade-in animation
        setTimeout(() => {
            requestAnimationFrame(() => {
                spinnerBox.style.opacity = '1';
            });
        }, 10);

        paginationContainer.innerHTML = '';
        resultsContainer.style.opacity = 1;
    }

    // Function to fetch and cache comments for a post
        async function fetchComments(permalink, commentsContainer, post) {
            const postId = permalink;
            const now = Date.now();

            // Validate permalink first
            if (!permalink || typeof permalink !== 'string' || !permalink.startsWith('/r/')) {
                console.error('‚ùå Invalid permalink provided to fetchComments:', permalink);
                return;
            }



            // Check database for cached comments
            try {
                const cacheResponse = await fetch(`http://localhost:3000/api/get-comments${permalink}`);
                const cacheData = await cacheResponse.json();

                if (cacheData.success && cacheData.cached && cacheData.comments.length > 0) {
                    // console.log(`‚úÖ Using ${cacheData.comments.length} cached comments from database`);

                    // Keep first 15
                    const dbComments = cacheData.comments.slice(0, 8).map(comment => ({
                        author: comment.author,
                        body: comment.body,
                        score: comment.score,
                        created_utc: comment.created_utc
                    }));


                    renderComments({
                        data: {
                            children: dbComments,
                            totalCount: cacheData.comments.length,
                        }
                    }, commentsContainer, permalink, false, post, cacheData.post_total_comments);

                    // Apply the stagger animation
                    requestAnimationFrame(() => {
                        const comments = commentsContainer.querySelectorAll('.comment');
                        comments.forEach((el, i) => {
                            el.classList.remove('visible');
                            setTimeout(() => {
                                el.classList.add('visible');
                            }, i * 60);
                        });
                    });

                    return;
                }
            } catch (error) {
                console.error('Error checking database cache:', error);
            }

            // If no cache, fetch from Reddit
            const fixedPermalink = permalink.endsWith('.json') ? permalink : `${permalink}.json`;
            const commentsUrl = `http://localhost:3000/reddit?url=https://www.reddit.com${fixedPermalink}%3Flimit%3D15`;

            try {
                const response = await fetch(commentsUrl);
                if (!response.ok) {
                    console.log('Failed to fetch comments.');
                    return;
                }

                const data = await response.json();

                // Grab gallery posts while you're at it
                const fullPost = data?.[0]?.data?.children?.[0]?.data;
                // Only patch if it's actually a gallery post with the required data
                if (fullPost && fullPost.is_gallery && fullPost.gallery_data && fullPost.media_metadata) {
                    const resultCard = document.querySelector(`[data-permalink="${permalink}"]`);
                    if (resultCard) {
                        tryGalleryPatch(fullPost, permalink, resultCard);
                    }
                }

                if (!Array.isArray(data) || !data[1]?.data?.children) {
                    console.warn('‚ö†Ô∏è No comments found in response for permalink:', permalink);
                    return;
                }

                const commentsData = data[1].data.children;
                console.log(`üìä Reddit sent ${commentsData.length} items`);

                    function flattenComments(items) {
                    let allComments = [];
                    items.forEach(item => {
                        if (item.kind === 't1' && item.data && item.data.author && item.data.body) {
                            allComments.push(item);
                        }
                        if (item.data && item.data.replies && item.data.replies.data && item.data.replies.data.children) {
                            const nestedComments = flattenComments(item.data.replies.data.children);
                            allComments = allComments.concat(nestedComments);
                        }
                    });
                    return allComments;
                }

                const flattenedComments = flattenComments(commentsData);
                const allComments = flattenedComments
                    .slice(0, 8)  // 8 comments for THIS post
                    .map(c => ({
                        id: c.data.id,
                        author: c.data.author,
                        body: c.data.body,
                        score: c.data.score,
                        created_utc: c.data.created_utc
                    }));
                const reduced = allComments.slice(0, 8);

                // Validate post id to avoid empty strings
                if (!postId || postId.trim() === '') {
                    console.error('Invalid postId for comment cache:', postId);
                    return;
                }

                renderComments({
                    data: {
                        children: reduced,
                        totalCount: commentsData.length
                    }
                }, commentsContainer, permalink, fullPost?.locked || false, fullPost, null); 

                // Save comments to database
                if (allComments.length > 0) {
                    saveCommentsToDatabase(permalink, allComments, fullPost?.num_comments, fullPost?.stickied);
                }

                // Force a paint first ‚Äî delay after .comment elements exist
                requestAnimationFrame(() => {
                    const comments = commentsContainer.querySelectorAll('.comment');
                    comments.forEach((el, i) => {
                        // Just to be safe, reset first
                        el.classList.remove('visible');
                        setTimeout(() => {
                            el.classList.add('visible');
                        }, i * 60); // stagger
                    });
                });

            } catch (error) {
                console.error('‚ùå Fetch error for', permalink, error);
            }
        }

        function saveCommentsToDatabase(permalink, comments, totalComments, isStickied) {
            fetch('http://localhost:3000/api/save-comments', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    permalink: permalink,
                    comments: comments,
                    total_comments: totalComments,
                    is_stickied: isStickied
                })
            })
                .then(res => res.json())
                .then(data => {
                    if (data.success) {
                        console.log(`üíæ Saved ${data.savedCount} comments to database`);
                    }
                })
                .catch(err => console.error('Save comments failed:', err));
        }

    function showError(message) {
            resultsContainer.innerHTML = `
    <div class='results-error'>
        <p>${message}</p>
    </div>
    `;
        resultsContainer.style.opacity = 0;
    applyStaggeredAnimation('.results-error', 'visible', 60);
        paginationContainer.innerHTML = '';
        resultsContainer.style.opacity = 1;
    }

    function renderComments(data, commentsContainer, permalink, isPostLocked, post, cachedCommentCount) {
    
            // Don't try to access gallery data if this is just comment data
        // Only try gallery patches when we have the actual post data
        if (data?.kind === 'Listing' && data?.data?.children?.[0]?.kind === 't3') {
            // 't3' is the prefix for posts (not comments)
            const fullPost = data?.data?.children?.[0]?.data;
            if (fullPost?.is_gallery && fullPost?.gallery_data && fullPost?.media_metadata) {
                console.log("üì∏ Triggering gallery patch with full metadata:", fullPost);
                const resultCard = document.querySelector(`[data-permalink="${permalink}"]`);
                tryGalleryPatch(fullPost, permalink, resultCard);

            }
        }

        // Parsing data to show if comments locked or no comments found
        const commentsData = data?.data?.children || [];
        const totalCommentsCount = data?.data?.totalCount 

        const isLocked = isPostLocked;

        if (commentsData.length === 0) {
            commentsContainer.innerHTML = `
        <div class="no-comments">
            ${isLocked ? 'Comments have been locked.' : 'No comments found.'}
            ${isLocked ? '<div class="lock-icon"></div>' : ''}
        </div>
        `;
            return;
        }

            // Sort comments by score (highest first)
            commentsData.sort((a, b) => (b.score || 0) - (a.score || 0));
            commentsContainer.innerHTML = '';

            const topComments = commentsData.slice(0, 8);
            topComments.forEach(comment => {
                const c = comment;

                const commentEl = document.createElement('div');
                commentEl.className = 'comment';

                const authorEl = document.createElement('div');
                authorEl.className = 'comment-author';
                const authorIconEl = document.createElement('div');
                authorIconEl.className = 'comment-author-icon';
                authorIconEl.textContent = c.author.charAt(0).toUpperCase();
                authorEl.appendChild(authorIconEl);
                authorEl.appendChild(createAuthorLink(c.author));

                const textEl = document.createElement('div');
                textEl.className = 'comment-text';
                
                textEl.appendChild(renderCommentBody(c.body));

                const metaEl = document.createElement('div');
                metaEl.className = 'comment-meta';
                const scoreEl = document.createElement('span');
                scoreEl.className = 'comment-score';
                scoreEl.textContent = formatNumber(c.score) + ' points';
                const timeEl = document.createElement('span');
                timeEl.className = 'comment-time';
                timeEl.textContent = formatTimestamp(c.created_utc);
                metaEl.appendChild(scoreEl);
                metaEl.appendChild(timeEl);

                commentEl.appendChild(authorEl);
                commentEl.appendChild(textEl);
                commentEl.appendChild(metaEl);
                commentsContainer.appendChild(commentEl);
            });
                // Use comments count from one source
                const actualCommentCount = cachedCommentCount || post?.num_comments || totalCommentsCount;

                // Then change the if statement:
                if (actualCommentCount > 0) { 
                    const seeMoreEl = document.createElement('div');
                    seeMoreEl.className = 'see-more-comments';
                    seeMoreEl.textContent = `See all ${actualCommentCount} comments`; 

                    seeMoreEl.addEventListener('click', () => {
                        window.open(`https://www.reddit.com${permalink}`, '_blank');
                    });

                    commentsContainer.appendChild(seeMoreEl);
                    
                } else {
                    const seeMoreE2 = document.createElement('div');
                        seeMoreE2.className = 'see-more-comments';
                        seeMoreE2.textContent = `View on Reddit`;

                        seeMoreE2.addEventListener('click', () => {
                            window.open(`https://www.reddit.com${permalink}`, '_blank');
                });

                        commentsContainer.appendChild(seeMoreE2);
            }
    }

    function updatePagination(targetPage = currentPageIndex) {
        const visibleCards = document.querySelectorAll('.result-card:not([style*="display: none"])');
        if (visibleCards.length < 10) {
            paginationContainer.innerHTML = '';
            return;
        }
        // console.log('‚úÖ currentAfter exists:', currentAfter);
        paginationContainer.innerHTML = '';

        let prevButton;

        if (currentPageIndex > 0) {
            const prevButton = document.createElement('button');
            prevButton.className = 'pagination-button';
            prevButton.textContent = '‚Üê Previous';
            prevButton.disabled = currentPageIndex === 0;
            prevButton.addEventListener('click', () => {
                if (currentPageIndex === 0) {
                return;
            }

            const targetPage = navigationHistory[currentPageIndex];
            const prevToken = targetPage.nextBefore;
            currentPageIndex--; 
                console.log('üîç About to use prevToken:', prevToken);
                console.log('üîç This came from navigationHistory[' + currentPageIndex + '].nextBefore');
                console.log('üîç Full targetPage data:', targetPage);
            performSearch(null, prevToken, true, false); 
            savePaginationState();
        });
        paginationContainer.appendChild(prevButton);
    }            

        if (currentAfter) {
            const nextButton = document.createElement('button');
            nextButton.className = 'pagination-button';
            nextButton.textContent = 'Next ‚Üí';
            nextButton.disabled = false;
            nextButton.addEventListener('click', () => {
    
                const tokenToUse = currentAfter;

                currentPageIndex++;

                // Use the saved token explicitly
                performSearch(tokenToUse, null, false);
                savePaginationState();
            });

            paginationContainer.appendChild(nextButton);
        }
    }

    function savePaginationState() {
        sessionStorage.setItem('kf_current_page_index', currentPageIndex);
        sessionStorage.setItem('kf_current_after', currentAfter || '');
        sessionStorage.setItem('kf_current_filters', JSON.stringify(currentFilters));
        sessionStorage.setItem('kf_navigation_history', JSON.stringify(navigationHistory));
    }

    function formatTimestamp(timestamp) {
        const date = new Date(timestamp * 1000);
        const now = new Date();
        const diffSeconds = Math.floor((now - date) / 1000);

        if (diffSeconds < 60) {
            return `${diffSeconds} second${diffSeconds !== 1 ? 's' : ''} ago`;
        }

        const diffMinutes = Math.floor(diffSeconds / 60);
        if (diffMinutes < 60) {
            return `${diffMinutes} minute${diffMinutes !== 1 ? 's' : ''} ago`;
        }

        const diffHours = Math.floor(diffMinutes / 60);
        if (diffHours < 24) {
            return `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
        }

        const diffDays = Math.floor(diffHours / 24);
        if (diffDays < 30) {
            return `${diffDays} day${diffDays !== 1 ? 's' : ''} ago`;
        }

        const diffMonths = Math.floor(diffDays / 30);
        if (diffMonths < 12) {
            return `${diffMonths} month${diffMonths !== 1 ? 's' : ''} ago`;
        }

        const diffYears = Math.floor(diffMonths / 12);
        return `${diffYears} year${diffYears !== 1 ? 's' : ''} ago`;
    }

    function formatNumber(num) {
        if (num >= 1000000) {
            return (num / 1000000).toFixed(1) + 'm';
        }
        if (num >= 1000) {
            return (num / 1000).toFixed(1) + 'k';
        }
        return num.toString();
    }

    function getDomainFromUrl(url) {
        try {
            return new URL(url).hostname.replace('www.', '');
        } catch {
            return null;
        }
    }

    // Security function to prevent XSS
    function sanitizeHTML(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    async function getSubredditIcon(subreddit) {
        console.log('üîç getSubredditIcon called with:', subreddit, typeof subreddit);
        
            // Validate subreddit parameter
            if (!subreddit || subreddit === 'undefined' || subreddit === 'null' || typeof subreddit !== 'string') {
                console.warn('‚ö†Ô∏è getSubredditIcon called with invalid subreddit:', subreddit);
                return '/api/placeholder/20/20';
            }

            // Clean and validate subreddit name
            const cleanSubreddit = subreddit.trim();
            if (cleanSubreddit.length === 0) {
                console.warn('‚ö†Ô∏è getSubredditIcon called with empty subreddit');
                return '/api/placeholder/20/20';
            }

            const storageKey = `subreddit_icon_${cleanSubreddit}`;

            // Check if icon is in sessionStorage
            const cachedIcon = sessionStorage.getItem(storageKey);
            if (cachedIcon !== null) {
                if (cachedIcon === 'null') {
                    return '/api/placeholder/20/20';
                }
                return cachedIcon;
            }

        try {
            const response = await fetch(`http://localhost:3000/reddit/icons?subreddits=${encodeURIComponent(cleanSubreddit)}`);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            const data = await response.json();
            const iconUrl = data[cleanSubreddit];
            if (!iconUrl) {
                sessionStorage.setItem(storageKey, 'null');
                return '/api/placeholder/20/20';
            }
            // Save to sessionStorage
            sessionStorage.setItem(storageKey, iconUrl);
            return iconUrl;
        } catch (err) {
            console.error(`‚ùå Failed to fetch icon for r/${cleanSubreddit}:`, err.message);
            sessionStorage.setItem(storageKey, 'null');
            return '/api/placeholder/20/20';
        }
    }

    function tryMediaPatch(fPost, resultCard, attempt = 1) {
            const cacheKey = fPost.url;
            const cached = window.cachedMediaByUrl[cacheKey];

            // üïó If cache isn't ready yet, wait for it
            if (!window.cachedMediaByUrl) {
                console.log(`‚è≥ Waiting for cache to initialize for URL: ${cacheKey}`);
                document.addEventListener('cachedPostsReady', () => {
                    tryMediaPatch(fPost, resultCard, attempt);
                }, { once: true });
                return;
            }

            if (!cached) {
                if (attempt < 10) { // Increased retry attempts
                    setTimeout(() => tryMediaPatch(fPost, resultCard, attempt + 1), 200); // Longer wait
                } else {
                    // console.warn(`‚ö†Ô∏è No cached media found after ${attempt} tries for ${cacheKey}`);
                }
                return;
            }

            // Preserve original URL before overwriting
            if (!fPost.originalUrl) {
                fPost.originalUrl = fPost.url;
            }

            // Patch media fields from cache with safety checks
            fPost.animated = cached.animated !== undefined ? cached.animated : fPost.animated;
            fPost.frame_count = cached.frame_count !== undefined ? cached.frame_count : fPost.frame_count;
            fPost.duration = cached.duration !== undefined ? cached.duration : fPost.duration;
            fPost.url = cached.url || fPost.url;

            // Only analyze potentially animated content that we don't have data for
            const couldBeAnimated = fPost.originalUrl?.toLowerCase().includes('gif') ||
                fPost.originalUrl?.endsWith('.webp') ||
                fPost.originalUrl?.endsWith('.apng') ||
                cached.url?.toLowerCase().includes('gif');

            const needsAnalysis = (fPost.animated === undefined || fPost.animated === null) &&
                (cached.animated === undefined || cached.animated === null);

            if (couldBeAnimated && needsAnalysis) {
                console.log(`üß™ Analyzing potentially animated media: ${cacheKey}`);
                fetch('http://localhost:3000/api/analyze-media', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url: cacheKey })
                })
                    .then(res => res.json())
                    .then(json => {
                        console.log('üìä Media analysis result:', json);
                    })
                    .catch(err => {
                        console.error('‚ùå Media analysis failed:', err);
                    });
            }

            // Rest of your media loading code stays the same...
            const imgContainer = resultCard.querySelector('.img-container');
            const imgWrapper = resultCard.querySelector('.image-wrapper');
            if (!imgContainer || !imgWrapper) return;

            if (imgContainer.style.visibility === 'hidden') {
                imgContainer.style.visibility = 'visible';
            }

            let shimmer = resultCard.querySelector('.image-placeholder');
            if (!shimmer) {
                shimmer = document.createElement('div');
                shimmer.className = 'image-placeholder shimmer';
                imgWrapper.prepend(shimmer);
            } else {
                shimmer.style.display = 'block';
            }

            const fallbackURL = `${IMAGE_PROXY_BASE}/image?url=${encodeURIComponent(cached.url)}&t=${Date.now()}`;
            const mediaElement = resultCard.querySelector('.result-image');
            if (!mediaElement) {
                console.warn(`‚ùå No media element found for URL key: ${cacheKey}`);
                return;
            }

            // Check if image-wrapper exists, create if missing
            if (!imgWrapper) {
                // Create the missing wrapper structure
                imgWrapper = document.createElement('div');
                imgWrapper.className = 'image-wrapper';
                imgWrapper.style.cursor = 'pointer';

                // Move the image inside the wrapper
                const parent = mediaElement.parentNode;
                parent.insertBefore(imgWrapper, mediaElement);
                imgWrapper.appendChild(mediaElement);
            }

            mediaElement.onerror = () => {
                console.warn(`üö´ Failed to load media for ${cacheKey}, retrying raw URL`);
                mediaElement.src = cached.url;
            };

            mediaElement.onload = () => {
            console.log(`‚úÖ Patched media loaded for ${cacheKey}`);
            shimmer.style.display = 'none';
            mediaElement.classList.add('show');
            };

            mediaElement.src = fallbackURL;

            // Detect media types
            const isGif = mediaElement.src?.toLowerCase().includes('gif');
            const isActuallyAnimated = fPost.animated === true;
            const isVideo = fPost.is_video ||
                (fPost.domain && fPost.domain.includes('youtu')) ||
                (fPost.url && fPost.url.includes('v.redd.it')) ||
                (fPost.domain && fPost.domain.includes('streamable')) ||
                (fPost.url && fPost.url.endsWith('.gifv'));
        }

    function classifyContentType(post) {
        // Text detection first (most specific)
        if (post.is_self === true) return 'text';
        if (post.domain && post.domain.startsWith('self.')) return 'text';
        if (post.url && post.url.includes('/comments/')) return 'text';

        // Video detection
        if (post.is_video === true) return 'video';
        const videoDomains = ['youtube.com', 'youtu.be', 'streamable.com', 'twitch.tv', 'vimeo.com', 'gfycat.com', 'v.redd.it'];
        if (post.domain && videoDomains.some(domain => post.domain.includes(domain))) {
            return 'video';
        }

        // Picture detection
        if (post.is_gallery === true) return 'image';
        if (post.preview && post.preview.images && post.preview.images.length > 0) return 'image';
        if (post.media_metadata && Object.keys(post.media_metadata).length > 0) return 'image';

        // If it's not i.redd.it and not a video domain, it's probably external/news = image
        if (post.domain && post.domain !== 'i.redd.it' && !videoDomains.some(domain => post.domain.includes(domain))) {
            return 'image';
        }

        return 'text';
    }

    function loadCachedPosts() {
            // Initialize global cache objects if they don't exist
            if (typeof window !== 'undefined') {
                if (!window.cachedPostsById) window.cachedPostsById = {};
                if (!window.cachedMediaByUrl) window.cachedMediaByUrl = {};
            }

            console.log("loadCachedPosts: Initiating fetch from API...");
            return fetch('http://localhost:3000/api/get-cached-posts')
                .then(res => {
                    console.log("loadCachedPosts: Fetch response received. Status:", res.status);
                    if (!res.ok) {
                        console.error("loadCachedPosts: HTTP error! Status:", res.status, res.statusText);
                        throw new Error(`HTTP error! status: ${res.status}`);
                    }
                    return res.json();
                })
                .then(cachedPosts => {
                //    console.log("loadCachedPosts: Parsed JSON data. Number of items:", cachedPosts ? cachedPosts.length : "null/undefined");

                    let mediaPopulatedCount = 0;
                    if (Array.isArray(cachedPosts)) {
                        cachedPosts.forEach(post => {
                        if (post.url) {
                            // --- NORMALIZATION FOR CACHE KEY ---
                            let normalizedCacheKeyUrl = post.url;
                            normalizedCacheKeyUrl = normalizedCacheKeyUrl.split('?')[0]; // Remove query parameters
                            normalizedCacheKeyUrl = normalizedCacheKeyUrl.replace('preview.redd.it', 'i.redd.it');
                            normalizedCacheKeyUrl = normalizedCacheKeyUrl.replace('v.redd.it', 'i.redd.it');
                            normalizedCacheKeyUrl = normalizedCacheKeyUrl.replace('external-preview.redd.it', 'i.redd.it');
                            // --- END NORMALIZATION ---

                            window.cachedMediaByUrl[normalizedCacheKeyUrl] = post; // Store post with normalized URL as key
                            mediaPopulatedCount++;
                        }

                        // Populate cachedPostsById using reddit_post_id (if available)
                        const postId = post.reddit_post_id;
                        if (postId) {
                            window.cachedPostsById[postId] = { ...post };
                        }
                    });
                }
            //    console.log("loadCachedPosts: Number of items added to cachedMediaByUrl:", mediaPopulatedCount);
            //    console.log(`‚úÖ Cached ${Object.keys(window.cachedPostsById).length} posts by ID.`);
            //    console.log("CachedMediaByUrl (after load):", window.cachedMediaByUrl); // Inspect this object
            })
            .catch(err => {
                console.error('‚ùå Failed to load cached posts:', err);
                // Re-throw the error so that subsequent .then() blocks don't run if this fails
                throw err;
            });
        }

    function addPlayIconIfNeeded(fPost, resultCard) {
            const imgContainer = resultCard.querySelector('.img-container');
            const mediaElement = resultCard.querySelector('.result-image');
            if (!imgContainer || !mediaElement) return;
            if (imgContainer.querySelector('.play-icon')) return;
            const isGif = fPost.url?.toLowerCase().includes('gif');
            const isActuallyAnimated = fPost.animated === true;
            const isGalleryGif = (
                fPost.media_metadata &&
                typeof fPost.media_metadata === 'object' &&
                Object.values(fPost.media_metadata).some(item => item.e === 'AnimatedImage')
            );
            const isVideo = fPost.is_video ||
                (fPost.domain && fPost.domain.includes('youtu')) ||
                (fPost.url && fPost.url.includes('v.redd.it')) ||
                (fPost.domain && fPost.domain.includes('streamable')) ||
                (fPost.url && fPost.url.endsWith('.gifv'));

            const isImgur = (fPost.url && fPost.url.includes('imgur')) && (fPost.url && fPost.url.endsWith('.gifv')) && isActuallyAnimated;
            // ‚úÖ Show play icon if it's a gallery gif, or if it's a video and not actually animated
            const shouldShowPlayIcon = isGalleryGif || (isVideo && !isActuallyAnimated);
            // console.log('üé¨ shouldShowPlayIcon:', shouldShowPlayIcon, fPost);
            if (shouldShowPlayIcon && !isImgur) {
                const playIcon = document.createElement('div');
                playIcon.className = 'play-icon';
                playIcon.innerHTML = '‚ñ∂';
                imgContainer.appendChild(playIcon);
            }
        }
    let isPopstateEvent = false;

    window.addEventListener('popstate', (event) => {
            isPopstateEvent = true;
            loadPaginationState(true);
        });

    function updateURL() {
            const params = new URLSearchParams();
            if (currentFilters.query) params.set('q', currentFilters.query);
            if (currentFilters.subreddit) params.set('sub', currentFilters.subreddit);
            if (currentFilters.contentType && currentFilters.contentType !== 'all') params.set('type', currentFilters.contentType);
            if (currentFilters.sort && currentFilters.sort !== 'hot') params.set('sort', currentFilters.sort);
            if (currentFilters.time && currentFilters.time !== 'all') params.set('time', currentFilters.time);
            if (currentPageIndex > 0) params.set('page', currentPageIndex);

            const newURL = `${window.location.pathname}?${params.toString()}`;

            if (isPopstateEvent) {
                // Don't modify history during popstate
                return;
            } else {
                history.pushState(null, '', newURL);
            }
        }

    function initPage() {   

        const isBookmarksPage = window.location.search.includes('page=bookmarks');

            // ‚úÖ 1. Load cached media posts at startup, not on bookmarks page
            if (!isBookmarksPage) {
                loadCachedPosts();
            }

            // ‚úÖ 2. Setup dropdown
            const input = document.querySelector('#subreddit-input');
            const dropdown = document.querySelector('.subreddit-suggestions');

            if (input && dropdown) {
                // CLICKING OUTSIDE ‚Üí closes dropdown
                document.addEventListener('mousedown', (e) => {
                    if (!input.contains(e.target) && !dropdown.contains(e.target)) {
                        dropdown.classList.remove('active');
                    }
                });

                // CLICKING ON A SUGGESTION ‚Üí apply + close dropdown
                dropdown.addEventListener('click', (e) => {
                    const clickedItem = e.target.closest('.subreddit-suggestion');
                    if (clickedItem) {
                        input.value = clickedItem.dataset.name || clickedItem.innerText;
                        dropdown.classList.remove('active');
                    }
                });
            }

        // ‚úÖ 3. Only do search stuff on main page
        if (isBookmarksPage) {
            loadSectionContent(1, false);
            return;
        }

        // Main page logic
        const isPageRefresh = performance.navigation
            ? performance.navigation.type === 1
            : performance.getEntriesByType('navigation')[0]?.type === 'reload';

        const isBackForward = performance.navigation
            ? performance.navigation.type === 2
            : performance.getEntriesByType('navigation')[0]?.type === 'back_forward';

        const restored = (isPageRefresh || isBackForward) && loadPaginationState(isBackForward);

        if (!restored || isPageRefresh) {
            // Fresh load - setup defaults and search
            console.log("üõéÔ∏è Loading r/all...");
            currentPageIndex = 0;
            currentAfter = null;
            currentBefore = null;
            currentFilters = {
                sort: 'hot',
                time: 'all',
                subreddit: '',
                query: '',
                contentType: 'all'
            };
            if (window.stripeCustomerId) {
                preloadBookmarks(window.stripeCustomerId, performSearch);
            } else {
                performSearch();
            }
        }
    }
            
    // ‚úÖ Reliable DOM load wrapper
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initPage);
    } else {
        initPage();
    }

    function getYouTubeThumbnail(url) {
        // Extract video ID from various YouTube URL formats
        const match = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/);
        
        if (match && match[1]) {
            const videoId = match[1];
            return `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;
        }
        
        return null;
    }

    function savePostsToDatabase(posts, pageGroupParam) {
            const pageGroup = pageGroupParam;

            const cleanPosts = posts.map((post, index) => ({
                data: {
                    id: post.data.id,
                    title: post.data.title || '',
                    url: post.data.url || '',
                    permalink: post.data.permalink || '',
                    subreddit: post.data.subreddit || '',
                    score: post.data.score || 0,
                    is_video: Boolean(post.data.is_video),
                    domain: post.data.domain || '',
                    author: post.data.author || '',
                    created_utc: post.data.created_utc || 0,
                    num_comments: post.data.num_comments || 0,
                    over_18: Boolean(post.data.over_18),
                    selftext: post.data.selftext || '',
                    body: post.data.body || '',
                    is_gallery: Boolean(post.data.is_gallery),
                    gallery_data: post.data.gallery_data || null,
                    media_metadata: post.data.media_metadata || null,
                    crosspost_parent_list: post.data.crosspost_parent_list || [],
                    content_type: post.data.content_type || '',
                    icon_url: post.data.icon_url || null,
                    locked: Boolean(post.data.locked),
                    stickied: Boolean(post.data.stickied),
                    preview: post.data.preview || null,
                    position: index
                }
            }));
       
        // Send to server with better error handling
        fetch('http://localhost:3000/api/save-posts', {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify({
             posts: cleanPosts,
             page_group: pageGroup 
         })
     })
            .then(res => {
                if (!res.ok) {
                    throw new Error(`Server error: ${res.status}`);
                }
                return res.json();
            })
            .then(data => console.log(`Saved ${data.savedIds?.length || 0} posts`))
            .catch(err => console.error(`Save failed: ${err.message}`));
    }

    function getThumbnailUrl(post) {
    
            // For Reddit videos without preview, construct DASH thumbnail URL
            if (post.is_video && post.url && post.url.includes('v.redd.it')) {
                const cleanUrl = post.url.split('?')[0];
                const videoId = cleanUrl.split('/').pop();
                const dashUrl = `https://v.redd.it/${videoId}/DASH_480.mp4`;
                // console.log('üé¨ Constructing Reddit video thumbnail:', dashUrl);
                // DON'T proxy video files - return direct URL
                return dashUrl;
            }

            // Check if it's a regular thumbnail
            if (post.thumbnail && !['self', 'default', 'nsfw', 'spoiler', 'image'].includes(post.thumbnail.toLowerCase())) {
                return post.thumbnail;
            }

            // Final fallback: use real_thumbnail if available
            if (post.real_thumbnail && !['self', 'default', 'nsfw', 'spoiler', 'image'].includes(post.real_thumbnail.toLowerCase())) {
                return post.real_thumbnail;
            }

            // Check if the URL is a direct link to media
            if (post.url) {
                const mediaExtensions = [
                    '.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.svg',
                    '.mp4', '.webm', '.mov', '.avi', '.mkv', '.m4v'
                ];

                const mediaHosts = [
                    'i.redd.it', 'v.redd.it', 'preview.redd.it',
                    'i.imgur.com', 'media.giphy.com', 'gfycat.com',
                    'streamable.com'
                ];

                const urlLower = post.url.toLowerCase();
                const isDirectMedia = mediaExtensions.some(ext => urlLower.endsWith(ext)) ||
                    mediaHosts.some(host => urlLower.includes(host));

                if (isDirectMedia) {
                    return post.url;
                }
            }

            return null;
        }

    function decodeEntities(input) {
            const txt = document.createElement('textarea');
            txt.innerHTML = input;
            return txt.value;
    }

    function parseMarkdown(text) {
            let processed = text;

        // Headers (h1-h6) - ADD THIS HERE, FIRST!
        processed = processed.replace(/^#{1,6}\s*(.+)$/gm, (match, content) => {
            const level = match.match(/^#+/)[0].length;
            return `<h${level}>${content}</h${level}>`;
        });

        // Bold
        processed = processed.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
        processed = processed.replace(/__(.+?)__/g, '<strong>$1</strong>');

        // Italic - use word boundaries
        processed = processed.replace(/\*([^*]+?)\*/g, '<em>$1</em>');
        processed = processed.replace(/\b_(.+?)_\b/g, '<em>$1</em>');
        
            // Strikethrough (~~text~~)
            processed = processed.replace(/~~([^~]+)~~/g, '<del>$1</del>');

            // Inline code (`code`)
            processed = processed.replace(/`([^`]+)`/g, '<code>$1</code>');

            // Reddit spoilers (>!text!<)
            processed = processed.replace(/>!([^!]+)!</g, '<span class="spoiler">$1</span>');

            // Quotes (lines starting with >)
            processed = processed.replace(/^>\s?(.+)$/gm, '<blockquote>$1</blockquote>');

            // Links with text [text](url)
            processed = processed.replace(/\[([^\]]+)\]\(([^)]+)\)/g,
                '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
            
            // Line breaks (Reddit uses two spaces at end of line or double newline)
                  if (processed.match(/[\[\(][^\]\)]*$/)) {
            processed = processed.replace(/[\[\(][^\]\)]*$/, '...');
        }
            
            processed = processed.replace(/  \n/g, '<br>');
            processed = processed.replace(/\n\n/g, '<br><br>');

            return processed;
    }

   function renderCommentBody(rawBody) {

        const wrapper = document.createElement('div');
        wrapper.className = 'comment-body';
            
        // Decode HTML entities
        const txt = document.createElement("textarea");
        txt.innerHTML = rawBody.trim();
        let decoded = txt.value;

        // Check for Reddit images first
        const imageRegex = /(https:\/\/preview\.redd\.it\/[^\s]+?\.(jpeg|jpg|png|gif|webp)(\?[^\s]*)?)/i;
        const imageMatch = decoded.match(imageRegex);

        // Check for different GIF formats
        const giphyRegex = /!\[gif\]\(giphy\|([^|)]+)(?:\|[^)]*)?\)/i;
        const redditGifRegex = /!\[gif\]\(emote\|[^|]*\|([^\)]+)\)/i;
        const directGifRegex = /(https?:\/\/[^\s]+\.gif(\?[^\s]*)?)/i;

        const giphyMatch = decoded.match(giphyRegex);
        const redditGifMatch = decoded.match(redditGifRegex);
        const directGifMatch = decoded.match(directGifRegex);

        if (imageMatch) {
            // Handle Reddit images
            const img = document.createElement('img');
            img.src = imageMatch[1];
            img.alt = 'Image from comment';
            img.style.maxWidth = '100%';
            img.style.borderRadius = '8px';
            wrapper.appendChild(img);
        } else if (giphyMatch) {
            // Handle Giphy GIFs
            const gifId = giphyMatch[1];
            const img = document.createElement('img');
            img.src = `https://media.giphy.com/media/${gifId}/giphy.gif`;
            img.alt = 'GIF from comment';
            img.style.maxWidth = '100%';
            img.style.borderRadius = '8px';
            wrapper.appendChild(img);
        } else if (redditGifMatch) {
            // Handle Reddit native GIFs
            const gifId = redditGifMatch[1];
            const img = document.createElement('img');
            img.src = `https://www.redditstatic.com/desktop2x/img/gold/badges/award-silver-large.png`; // You'll need the actual Reddit gif URL format
            img.alt = 'Reddit GIF from comment';
            img.style.maxWidth = '100%';
            img.style.borderRadius = '8px';
            wrapper.appendChild(img);
        } else if (directGifMatch) {
            // Handle direct GIF URLs
            const img = document.createElement('img');
            img.src = directGifMatch[1];
            img.alt = 'GIF from comment';
            img.style.maxWidth = '100%';
            img.style.borderRadius = '8px';
            wrapper.appendChild(img);
        } else {
            // Parse markdown ONLY for non-image content
            decoded = parseMarkdown(decoded);
            // Handle text content
            const urlRegex = /(https?:\/\/[^\s<]+)/g;
            const lines = decoded.split('\n');
            lines.forEach(line => {
                const lineEl = document.createElement('div');
                if (line.trim().startsWith('>')) {
                    lineEl.className = 'quote';
                    lineEl.textContent = line.replace(/^>\s?/, '');
                } else {
                    // Only process plain URLs if no anchor tags exist
                    if (!line.includes('<a href=')) {
                        line = line.replace(urlRegex, url => {
                            return `<a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`;
                        });
                    }
                    lineEl.innerHTML = line;
                }
                wrapper.appendChild(lineEl);
            });
        }
        return wrapper;
    }

    </script>
    <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2/dist/fuse.min.js"></script>

    <script>
        fetch('words.json')
            .then(res => res.json())
            .then(words => {
                console.log("‚úÖ Word list loaded:", words.length);
                window.englishWords = words;
                setupSearchSuggestions('search-input', 'suggestions', window.englishWords);
            })
            .catch(err => {
                console.error("‚ùå Failed to load word list:", err);
            });
    </script>


<script src="themetoggle.js" defer></script>
<script src="bookmarks.js"></script>

</body>

</html>